{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/hash.png","path":"images/hash.png","modified":0,"renderable":0},{"_id":"source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0,"renderable":0},{"_id":"source/images/home.JPG","path":"images/home.JPG","modified":0,"renderable":0},{"_id":"source/images/webpack_01.jpg","path":"images/webpack_01.jpg","modified":0,"renderable":0},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Git Flow & 常用Git命名和操作.md","hash":"19d5ad2a9db5f2fa40c1790c7b55f16ad4a80b49","modified":1643464630257},{"_id":"source/_posts/Js防抖与节流.md","hash":"0bf9160e24f62af50b02cdada62bf764d4b5bc1e","modified":1643464653766},{"_id":"source/_posts/lodash源码 chunk.md","hash":"2a82e1bbdeadbe68232907b9648c5fcd85b7fa0a","modified":1643464691366},{"_id":"source/_posts/lodash源码 compact.md","hash":"28f21cf6d3fe1caa21b6a626ee5742247596a151","modified":1643464694031},{"_id":"source/_posts/lodash源码 eq.md","hash":"367b535447cc194bb0eba17fc6090af5d7a2f62e","modified":1643464696774},{"_id":"source/_posts/lodash源码 slice.md","hash":"e76c86d5f1f7fd67353c5a1e212cca5cb22f0b61","modified":1643464699470},{"_id":"source/_posts/lodash源码 内部 Hash缓存.md","hash":"ea587a12a43f0e0bfc937c31c2fa5185d9132085","modified":1643465862893},{"_id":"source/_posts/lodash源码 内部 assocIndexOf.md","hash":"9d65d94b7284f5e3d11bcc61eca98c331c3c4865","modified":1643464681006},{"_id":"source/_posts/lodash源码 内部 baseFindIndex.md","hash":"e2f0126fa5995221ea2fc6d8675ba84eb247b2d3","modified":1643464685941},{"_id":"source/_posts/promise.md","hash":"059a5127ad5db3d39f30f875ad051177b8ea244f","modified":1643464711230},{"_id":"source/_posts/webpack.md","hash":"702f7329fcd51c40223c4b1a71421852f51db392","modified":1643465875303},{"_id":"source/_posts/yarn和npm命令对比.md","hash":"e92555601e726255b7fa00845267b93b3de60c1d","modified":1643462006165},{"_id":"source/_posts/事件循环EventLoop.md","hash":"54e62de9bd3a0ec59e9d06a3edc9f58a644c7b36","modified":1643464592919},{"_id":"source/_posts/地址.md","hash":"3ac53973af35a1feb41b1fcc32b7686d2e87aabc","modified":1643464508084},{"_id":"source/_posts/移位运算符.md","hash":"a47f8949feca8b7890f61312b7d80fe570ae7835","modified":1643464600532},{"_id":"source/_posts/箭头函数的部分简写方式.md","hash":"b0998fc0df541f9726b1328b376956004bea36aa","modified":1643464575841},{"_id":"source/images/webpack_01.jpg","hash":"81f577db9cda0f05744f416d47966af598724520","modified":1643446566848},{"_id":"source/categories/index.md","hash":"7091183261fede975ea213cc5a81f000f4b91077","modified":1643459601255},{"_id":"source/tags/index.md","hash":"00fdc5410610091db22ef515d350149fd0e25477","modified":1643459594618},{"_id":"source/images/hash.png","hash":"58d742868a6a65b3e0e84d71732b76ea9ccbc3f5","modified":1643446566848},{"_id":"source/images/avatar.jpeg","hash":"7fa0903c91c0edf0b9b04b8498f15a07a21c5d9c","modified":1643460642795},{"_id":"source/images/home.JPG","hash":"e66d7d5e32fe41135d8c1e14b0609392b23c1e12","modified":1643457409369},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1643456585779},{"_id":"themes/butterfly/README.md","hash":"2555c3e418157a0fda35d3deaf029f12e5a12f12","modified":1643456585779},{"_id":"themes/butterfly/README_CN.md","hash":"84fa5880f5358abe919eb295aad3cfd17b69b631","modified":1643456585780},{"_id":"themes/butterfly/_config.yml","hash":"ae72295a47254d39e2638104d0e9fde006f7ec47","modified":1643456585780},{"_id":"themes/butterfly/package.json","hash":"c2c2dee595d35ff195badaa85790e9c5c118ad65","modified":1643456585802},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1643456585779},{"_id":"themes/butterfly/languages/default.yml","hash":"36682776bbf5c95c144a52b8159883701b308ae8","modified":1643456585780},{"_id":"themes/butterfly/languages/en.yml","hash":"cca2b24e8f51bc82933951840c7ab24b8153891f","modified":1643456585781},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"f95e4f86bde74a8a118f72e68f7874a33d525b38","modified":1643456585781},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"497751dad5007d168d2466a9d4c0c21ebaf9cb97","modified":1643456585781},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1643456585781},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1643456585782},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1643456585802},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1643456585802},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1643456585802},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1643456585802},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1643456585778},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1643456585778},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1643456585779},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1643456585779},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1643456585782},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"8459729db2978bebd7f3668f6dc00a5bb100e633","modified":1643456585782},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1643456585782},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"131634cc862247d636965cb4490118adbf15451c","modified":1643456585782},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"f2e1d8a05d2e409c4804f67a98f5f59f527d6627","modified":1643456585786},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"bb1847f45e713cc88b1c0a97035ec01f0209c995","modified":1643456585788},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"52dae507bb73d53604c51f45a20103c8e11353d0","modified":1643456585788},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"2cf68619af17ece9acea71aa2cb06737097890a5","modified":1643456585788},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1643456585803},{"_id":"themes/butterfly/scripts/events/config.js","hash":"ceb741d562dc082672734194bc3b21fbd6c4a990","modified":1643456585803},{"_id":"themes/butterfly/scripts/events/init.js","hash":"b321a97420082101a4d41e6e571db1a166475e06","modified":1643456585803},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1643456585803},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1643456585803},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1643456585804},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"6c3b7d0874fa499800a4fd49894c481b05ec750c","modified":1643456585804},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1643456585804},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1643456585804},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"22a2c69b3e68b0e3f80decfd4a2b9c9cc213ff5c","modified":1643456585805},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"384de3c04809ec5fa996e8aa0628f770cd4bff3e","modified":1643456585805},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"26dd1900e68a3e10a5cf3f3484a93139a0f1340e","modified":1643456585805},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1643456585805},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"6d4cd2393945a9316339351cab588265f5c18d73","modified":1643456585805},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"aadeb65a7838f45c175807658ee857d82d306b58","modified":1643456585806},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1643456585806},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1643456585806},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1643456585806},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1643456585806},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1643456585807},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1643456585807},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1643456585818},{"_id":"themes/butterfly/source/css/var.styl","hash":"584ef7b18d5e677eb2e62f9b139097d3b714a993","modified":1643456585818},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1643456585818},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1643456585818},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1643456585819},{"_id":"themes/butterfly/source/js/main.js","hash":"220d48432a33155e385c53355c147a1a333d2739","modified":1643456585819},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1643456585820},{"_id":"themes/butterfly/source/js/utils.js","hash":"99632cb4458795c97db0179b0196e4977d3caa07","modified":1643456585820},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"07380718ed3af19a7e64b30e8c13726fe5983947","modified":1643456585783},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"b8e3e07b0e8f3cf25af9550c6361725a05045b92","modified":1643456585783},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c1e45d4d0bd905ddcd2282de4fe89be92e67847d","modified":1643456585783},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1643456585783},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1643456585783},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1643456585783},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fc3e67e5ae4774d9e89964ba96beed28f34ee8f0","modified":1643456585784},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1643456585784},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1643456585784},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"3a2797d2744607ba6cdb5a02853851957c0f7e29","modified":1643456585785},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1643456585785},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"a9e56b1c41bf327859b0a7bcb8e72b458bd851b2","modified":1643456585785},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"3b0b2053fe9f08cbc21b3baa53163adc2f76c19a","modified":1643456585785},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1643456585785},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"2e1ab0c2ca59a1ff5a5ba9b6ef60f3e34af5430c","modified":1643456585786},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1643456585786},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"971038debf539333b1687b4a1d87cf4fc965a846","modified":1643456585786},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"9c8e65939d048a579ea08d063c0f98550376f536","modified":1643456585787},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1643456585787},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1643456585787},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"8f43fdeaf8cff4a35bab74b48c963786ca015620","modified":1643456585787},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e2eba0fcb8332cb333b2aff9c76664e40e2e1974","modified":1643456585787},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1643456585788},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1643456585788},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1643456585789},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1643456585794},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d06dafe7faf3a2e328ef62f26166a51ffe7a5579","modified":1643456585797},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1643456585798},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"61a220bf134201bdf49430b578305191421c547c","modified":1643456585797},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"311d883dede2a6838bf24ba9e4b3f69e62d5b3f1","modified":1643456585799},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1643456585799},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"009bdbef23381f10664622fafdc602f2ff5bf1ec","modified":1643456585799},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1643456585800},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"935dde9cf4c1fef0214dbb9935ecb71805735be0","modified":1643456585800},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1643456585800},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1643456585800},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"c02b1779bd0ebca6749f195be096b6ca574bfa29","modified":1643456585800},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1643456585801},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"471b20e71a19db1f5115727082e5188200c49383","modified":1643456585801},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"9755cac8424dc578e9ec07dbcaa429fddbedd392","modified":1643456585801},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1643456585801},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"62adef7998fb9bebc5891a49472cfea944a1bf7a","modified":1643456585801},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"5e0e9e9b2cd3c256d52423e2278e790aa387a53a","modified":1643456585801},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"d9367019f2c111a74368a3012c7b2b04d3ef5cd4","modified":1643456585807},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"b9d7d23dc8810542b8c8ffcbfbd3694318debcc6","modified":1643456585808},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"8b63ecdbcbfbae51108493ac7879988797833ce8","modified":1643456585808},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1643456585809},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"143541a548fb0e8c73493cfc7bbcd3f0a1e5b5e1","modified":1643456585810},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1643456585810},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1643456585810},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"e931ef81754a7b9d999fa23d134c620e68e75491","modified":1643456585810},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"844858ae87c7278996ce484c6b456db354c48764","modified":1643456585811},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"f3aac52defb3497079a313e8c63ac2f7ee24dfbe","modified":1643456585810},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"f9bc66963f256bde0ecc76f1c3b7aa2345873cbf","modified":1643456585811},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"2545df256b6d6e09056c3d3469bc9ccc0691014f","modified":1643456585811},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1643456585811},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1643456585812},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"1c1c585ba99cb4004956b5e98fc044260b456f99","modified":1643456585812},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"4258fa2e590aeea704660008aed7f0362fac72d4","modified":1643456585812},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"e53b0b4a3657ea42f29b24fa8a3054c161d75fd1","modified":1643456585812},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"2af2086767b56443edee638b5ca4fc5b786aa604","modified":1643456585813},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"1fed25162d7204480e9bcf476b3246e1717107ca","modified":1643456585813},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"f84268708a9ea3c417426bf194bdfea9f7374628","modified":1643456585815},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"f9bee6cac49de1171076560acf6a6eec96647c56","modified":1643456585815},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"107b9e586b12d1fe7bb5b6e53fcc8e31516ab3ba","modified":1643456585815},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1643456585813},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"d72218cb5a6bfe048ae1c92009bd815a08a53d3a","modified":1643456585813},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1643456585813},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a714776e3d585369f2285b6bb4e1564539c58d8b","modified":1643456585814},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"c3972c22f12bff65e2c8e835d84f07e260f35fdc","modified":1643456585814},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"c42b872df237726483d93d6124b8751d4f64cf86","modified":1643456585814},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1643456585814},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1643456585815},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"84c42716e833d2d1dd47195ea996803ffa0e58ec","modified":1643456585815},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1643456585816},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"cfcafc0c30a5555cd993cd9bd4707793c919a030","modified":1643456585816},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1643456585816},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1643456585816},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1643456585817},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"076cd87805207c9b5612ec9771f6994287f4c169","modified":1643456585816},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1643456585817},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1643456585817},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"d684f2a60fe821d61761a01cf36fd2fb57c31c9c","modified":1643456585820},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"54b6266400de1a17ff40315e8307e086870c8c2c","modified":1643456585820},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1643456585789},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4eebb2d94ca75809ef0cf32d70f13e9bf1e87091","modified":1643456585789},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"a18415004d03c0a1783eccac522fbcb6ce0ea1f1","modified":1643456585789},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"eb2d840fa42de3ec7a7fda0eaa30246d52f543e2","modified":1643456585790},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"896dc0b7480151562c5717771e3000c5a7fc1b16","modified":1643456585790},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"f3db5c5e738e097a191dc0de59c61d3e1444f7c3","modified":1643456585790},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"d5f81fd5443a1b09efb165b5f4447a35949d14ad","modified":1643456585791},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"9ddfac9ae7071ecd982ca3808dcfd4d2d6098f33","modified":1643456585791},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"611b2c67604926d51a74a48a78636971cdc926d5","modified":1643456585792},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a780962b3a04cac4b296ce809ee7101e42cf3a37","modified":1643456585792},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"b22ed23c78fb372cbdc4cfd3f733beb2ebea5d74","modified":1643456585792},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"414f876d28f8497d6d551363a89c5c69bf1533eb","modified":1643456585792},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"810e8ca2669433f649329859922aabbb30d76178","modified":1643456585793},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1643456585793},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"3f10e67c7618615cc85d50e4a3694f3d8b262952","modified":1643456585793},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"21098eba47237ec003228e7fa70a5fbb14d6c804","modified":1643456585793},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"d1ac48307e4999be08c63c673e98fe3fcee5bfce","modified":1643456585794},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0f287b10408b4455d946a69677549fcfd302e8c0","modified":1643456585794},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1643456585790},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1643456585790},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1643456585790},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1643456585791},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1643456585791},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1643456585791},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"cd1ce86441dc508e4c3dbf8b829046455ba8a6b4","modified":1643456585796},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"b2ede1f6b41026ebd233ac076a405889a6eec76b","modified":1643456585796},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"16cf05cf9649322da57e9b8d316573bb65f8d8d8","modified":1643456585796},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"444820bc7e4a9a033062bcd8cd71b10b49d1968a","modified":1643456585796},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"3b42d3b8468431655112705bff7530ce647f8c05","modified":1643456585797},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"c9e6e14770317a3516e2e2f320654cd52b1bd73a","modified":1643456585797},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1643456585794},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"266caf985dc0703ff81b871b8f8d206f57db6e79","modified":1643456585794},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"87e40f0c315407ab88571a2b3450d640f15c96bc","modified":1643456585795},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"6dd420ea858f3237d8a7353e8541df665dd6fdf1","modified":1643456585795},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"a5aa867697578660fe78a0d9b0f245d09b571110","modified":1643456585798},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1643456585798},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"7ce18e4b22c41dcfd84835e89b47030fc5f4a394","modified":1643456585798},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1643456585798},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1643456585799},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1643456585799},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1643456585799},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1643456585808},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1643456585808},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1643456585809},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1643456585809},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1643456585809},{"_id":"public/search.xml","hash":"8bfb0b718cfec958548ff09b74668bee07d11118","modified":1643465890323},{"_id":"public/categories/index.html","hash":"695fb30cf9725ba4c4aad412022fa082bad36238","modified":1643465890323},{"_id":"public/tags/index.html","hash":"35498d4229a140d65da780d169fef8b4a11c2e99","modified":1643465890323},{"_id":"public/2022/01/29/webpack/index.html","hash":"39950e24b411386f6d122619e1576c37b4d82cde","modified":1643465890323},{"_id":"public/2022/01/25/yarn和npm命令对比/index.html","hash":"6c6808ae0fc95caefaed6becac82340d90a28e8d","modified":1643465890323},{"_id":"public/2022/01/20/lodash源码 内部 baseFindIndex/index.html","hash":"9a4dbd7d1c5bed1eb30ee144a9e694ac61083111","modified":1643465890323},{"_id":"public/2022/01/04/lodash源码 内部 assocIndexOf/index.html","hash":"8997b1ed19730eafc74edfd29e28b59a99bc98f5","modified":1643465890323},{"_id":"public/2021/12/29/lodash源码 内部 Hash缓存/index.html","hash":"321ae29afb50ca123409e84bf920dbd3c4fa636c","modified":1643465890323},{"_id":"public/2021/12/27/lodash源码 eq/index.html","hash":"095922d6ace97498e430953f270c7e329e117ee4","modified":1643465890323},{"_id":"public/2021/12/20/lodash源码 chunk/index.html","hash":"a69f4d536b414f701e3ff601dc2c4724876679ec","modified":1643465890323},{"_id":"public/2021/12/20/lodash源码 compact/index.html","hash":"1031ed12e7a9737ce6c94a6ece66a26a77b5748c","modified":1643465890323},{"_id":"public/2021/12/15/lodash源码 slice/index.html","hash":"af25e7e019aa8ee1accbe4b6e5529cc0d79e6f93","modified":1643465890323},{"_id":"public/2021/12/15/移位运算符/index.html","hash":"bdd4d4385ae1bfc763f538e441800867e1b0338f","modified":1643465890323},{"_id":"public/2021/12/10/Git Flow & 常用Git命名和操作/index.html","hash":"621640dc5aa24f89e4179ff2ef9ad31de93c0839","modified":1643465890323},{"_id":"public/2021/12/06/Js防抖与节流/index.html","hash":"a011c9cc95ea7e1d2fc5f82b06c6662b4179327a","modified":1643465890323},{"_id":"public/2021/12/03/promise/index.html","hash":"7a02f91d85a0f02da4b0aeadd48db06769cc6fb4","modified":1643465890323},{"_id":"public/2021/12/03/地址/index.html","hash":"a150f244eaa36ea05ba1dee46a9492e84dd2942a","modified":1643465890323},{"_id":"public/2021/09/07/事件循环EventLoop/index.html","hash":"efe7543c2273020ae0379988f214a945c79e04f2","modified":1643465890323},{"_id":"public/2021/06/23/箭头函数的部分简写方式/index.html","hash":"0873ea0f0e95722ff34abfb00141979261184a46","modified":1643465890323},{"_id":"public/archives/index.html","hash":"cbb9db0400dfdd1bc283bf3addf8a4d69c490649","modified":1643465890323},{"_id":"public/archives/page/2/index.html","hash":"d120f067dba4249c358aaf6eeaf3ad81e5452d9a","modified":1643465890323},{"_id":"public/archives/2021/index.html","hash":"29a4eca931ddab89f74253556511963fd70c9cab","modified":1643465890323},{"_id":"public/archives/2021/page/2/index.html","hash":"ca80841895b09fea73a92c1e73d37591bc2fd79b","modified":1643465890323},{"_id":"public/archives/2021/06/index.html","hash":"338d27335a862a77d83ffcdf222c742a72393ecf","modified":1643465890323},{"_id":"public/archives/2021/09/index.html","hash":"45f96dda58424c46614cc428502f3a3ec2acf68b","modified":1643465890323},{"_id":"public/archives/2021/12/index.html","hash":"acbdc64bdaeb258a078cddfbac3bf2969e497743","modified":1643465890323},{"_id":"public/archives/2022/index.html","hash":"d5b97cd71071a29492f12201a353f9f3600cb451","modified":1643465890323},{"_id":"public/archives/2022/01/index.html","hash":"54d51a0a52bd3a720576955b4dc8d80cbf01e7ff","modified":1643465890323},{"_id":"public/categories/git/index.html","hash":"ba9abf932cd1f3e7caa46e303b9f1f794b39f52b","modified":1643465890323},{"_id":"public/categories/前端/index.html","hash":"d8f0f0cd0a8998cf6e7967fc4f18daf1779e2b37","modified":1643465890323},{"_id":"public/categories/前端/page/2/index.html","hash":"c40f54d90d6e2a356aedead673dbf2c4b4446062","modified":1643465890323},{"_id":"public/categories/杂/index.html","hash":"c7a2098f803484ad34134abf91a94990577e1a38","modified":1643465890323},{"_id":"public/index.html","hash":"23190da5c6df2f6bde62c0d959792f22b593b119","modified":1643465890323},{"_id":"public/page/2/index.html","hash":"21228356db84040b645572dc368e9e16a58887c3","modified":1643465890323},{"_id":"public/tags/git-flow/index.html","hash":"3319514039e554686bdc4abf3cad6b12feb5557b","modified":1643465890323},{"_id":"public/tags/git命令/index.html","hash":"5859475ac3ea9aed190d7e9018fa44a112a63a6f","modified":1643465890323},{"_id":"public/tags/javascript/index.html","hash":"98efab43b861805afcd5ae312692309528b6a2b0","modified":1643465890323},{"_id":"public/tags/javascript/page/2/index.html","hash":"a99e181b83c2204106235d6d7ca2479f7792afa6","modified":1643465890323},{"_id":"public/tags/防抖节流/index.html","hash":"9fca485cf1a3252aa681e018f8163dbf22ee9932","modified":1643465890323},{"_id":"public/tags/lodash/index.html","hash":"722d26a3e78c24e70bf8bf0ceb9dd5be6a03b312","modified":1643465890323},{"_id":"public/tags/promise/index.html","hash":"6ea96d1c0dc90ee4b80b3817014a743caea6b323","modified":1643465890323},{"_id":"public/tags/webpack/index.html","hash":"a140aed11162674aff4404adbdefc5d5bc88c890","modified":1643465890323},{"_id":"public/tags/网站/index.html","hash":"c61d49149b90803e837416d34622b82f7bb9f45c","modified":1643465890323},{"_id":"public/tags/箭头函数/index.html","hash":"ebe4f442b56ff368be7245cc5fbcff22e468344f","modified":1643465890323},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1643465890323},{"_id":"public/images/webpack_01.jpg","hash":"81f577db9cda0f05744f416d47966af598724520","modified":1643465890323},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1643465890323},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1643465890323},{"_id":"public/images/hash.png","hash":"58d742868a6a65b3e0e84d71732b76ea9ccbc3f5","modified":1643465890323},{"_id":"public/images/avatar.jpeg","hash":"7fa0903c91c0edf0b9b04b8498f15a07a21c5d9c","modified":1643465890323},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1643465890323},{"_id":"public/js/utils.js","hash":"3ee4bd9071dc6e854ffa33964f3a8da2ee2a8409","modified":1643465890323},{"_id":"public/js/search/algolia.js","hash":"aaa5e44125dcf321866bc2355a73773b11db8c9c","modified":1643465890323},{"_id":"public/js/search/local-search.js","hash":"72911c7b42e0174a979c09ead3f42ee24136feae","modified":1643465890323},{"_id":"public/css/index.css","hash":"72effe1f61b468bc864bb7c5eaebdcae8bd92bd7","modified":1643465890323},{"_id":"public/js/main.js","hash":"1254dca2c02b3389ec0434cdd2728fdea4ae0216","modified":1643465890323},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1643465890323},{"_id":"public/images/home.JPG","hash":"e66d7d5e32fe41135d8c1e14b0609392b23c1e12","modified":1643465890323}],"Category":[{"name":"git","_id":"ckyzx5p6h0004rwh96nrp54j4"},{"name":"前端","_id":"ckyzx5p6s0009rwh970nv3hw5"},{"name":"杂","_id":"ckyzx5p740015rwh93ehl6cac"}],"Data":[],"Page":[{"title":"分 类","date":"2022-01-28T16:00:00.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分 类\ndate: 2022-01-29 00:00:00\ntype: \"categories\"\n---\n","updated":"2022-01-29T12:33:21.255Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckyzx5p650000rwh9cqj5fu4r","content":"","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":""},{"title":"标 签","date":"2022-01-29T12:11:54.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标 签\ndate: 2022-01-29 20:11:54\ntype: \"tags\"\n---","updated":"2022-01-29T12:33:14.618Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckyzx5p6a0002rwh9ed9h7bor","content":"","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":""}],"Post":[{"title":"Git Flow & 常用Git命名和操作","date":"2021-12-09T16:00:00.000Z","_content":"## # 简述 Git Flow\n简单来说，`Git Flow` 就是一套规范的代码管理流程\n## # 分支应用情景\n- 在`Git Flow`中，主要的分支有`master`、`develop`、`hotfix`、`release`、`feature` 这五种分支  \n- `develop` 和 `master`会被保留，其他的随任务结束而删除  \n### # master 分支\n- 存放稳定上线版本\n- 这个分支的来源只能从别的分支合并过来，开发者不会直接commit到这个分支上。\n- 通常我们也会在这个分支上的提交打上版本号标签。\n### # develop 分支\n- 这个分支主要是所有开发的基础分支。\n- 当要添加功能时，所有功能都是从这个分支切出去的，而功能分支实现后，也都会合并回来这个分支中。\n### # hotfix 分支\n- 用途：处理紧急线上问题\n- 基于master分支创建\n- 修复完成，合并到master分支和develop分支中\n### # release 分支 (预上线分支)\n- 当`develop`分支完成需求后，就可以从`develop`分支中开一个`release`分支，进行上线前最后的测试。\n- 测试完成后，释放`release`分支将会同时合并到`master`以及`develop`分支中。\n### # feature分支\n- 当我们需要补充功能的时候，就会从develop分支中开一个feature分支进行功能开发。\n- 当功能实现后，在将feature分支合并到develop分支中，等待最后的测试发布。\n  \n### # 具体场景\n#### 1. 新功能开发\n> 基于`develop`，新建功能分支 `f1-feature`，切换到该分支下进行开发\n需要多人开发时，可以推到远端分支\n完成功能开发，将该分支合并到`develop`分支，**并删除`f1-feature`**分支\n\n**2021/12/24 -- 更新：使用 `rebase` 整理提交**  \n关于新分支（命名`f1-feature` 或者 `feat/xxx` ）  \n**1. develop有更新内容需要同步**  \n```shell\n# 提交代码\ngit add .\ngit commit -m 'message'\n\n# 切换 develop 拉取代码\ngit checkout develop\ngit pull\n\n# 切换 本地分支（例：feature），合并代码\ngit checkout feature\ngit rebase -i develop\n```\n-i 意为合并多次提交，运行后显示前几次的提交内容如下：  \n```\npick 281812b message1  \npick e60c7f4 message2  \n```\n当需要合并所有提交的时候，保留一个`pick`，其余修改为 `s`，如下： \n```\npick 281812b message1  \ns e60c7f4 message2  \n```\n`:wq` 提交修改\n\n**代码冲突时，修改冲突后，重新`add`提交，执行`git commit`，展示`message`，根据需求自行修改，再 `git rebase --continue`**  \n\n**2. 本地分支开发完毕需要合并到develop** \n\n```shell\n# 先提交本地分支代码 add --> commit\ngit rebase -i develop\n# 后面的操作如1所示\n# 需要新增的步骤：切换到develop分支，merge 本地分支\ngit merge feature\n\n# 最后 git push\n```\n需要注意的点：在 `git rebase -i develop` 的时候，根据自身情况选择对commit是否进行合并\n#### 2. 发布上线\n基于`develop`分支创建`release-0.1`分支作为预上线分支,有问题，在该分支上修改，最后切换到`develop`和`master`分支下合并该分支，删除`release-0.1`分支\n#### 3.紧急bug修复\n基于`master`分支新建`hotfix-bug1`分支进行修改，修改完切换到`develop`和`master`分支下合并该分支，删除`hotfix-bug1`分支\n### # 常用git操作\n**分支相关**\n```\n// 查看本地分支\ngit branch\n返回🌰\n*master\n\n// 查看远程分支\ngit branch -r\n返回🌰\norigin/master\n\n// 查看本地和远程分支\ngit branch -a\n返回🌰\n*master\n remotes/origin/master\n \n// 切换分支\ngit checkout <branch-name>\n\n// 创建并切换到该分支\ngit checkout -b <branch-name>\n\n// 删除分支\ngit branch -d <branch-name>\n\n// 删除远端分支\ngit push origin -d <branch-name>\n\n// 重命名分支\ngit branch -m <oldbranch-name> <newbranch-name>\n\n// 合并指定分支到当前分支\ngit merge <branch-name>\n```\n\n\n\n","source":"_posts/Git Flow & 常用Git命名和操作.md","raw":"---\ntitle: Git Flow & 常用Git命名和操作\ndate: 2021-12-10\ncategories:\n- git\ntags:\n- git flow\n- git命令\n---\n## # 简述 Git Flow\n简单来说，`Git Flow` 就是一套规范的代码管理流程\n## # 分支应用情景\n- 在`Git Flow`中，主要的分支有`master`、`develop`、`hotfix`、`release`、`feature` 这五种分支  \n- `develop` 和 `master`会被保留，其他的随任务结束而删除  \n### # master 分支\n- 存放稳定上线版本\n- 这个分支的来源只能从别的分支合并过来，开发者不会直接commit到这个分支上。\n- 通常我们也会在这个分支上的提交打上版本号标签。\n### # develop 分支\n- 这个分支主要是所有开发的基础分支。\n- 当要添加功能时，所有功能都是从这个分支切出去的，而功能分支实现后，也都会合并回来这个分支中。\n### # hotfix 分支\n- 用途：处理紧急线上问题\n- 基于master分支创建\n- 修复完成，合并到master分支和develop分支中\n### # release 分支 (预上线分支)\n- 当`develop`分支完成需求后，就可以从`develop`分支中开一个`release`分支，进行上线前最后的测试。\n- 测试完成后，释放`release`分支将会同时合并到`master`以及`develop`分支中。\n### # feature分支\n- 当我们需要补充功能的时候，就会从develop分支中开一个feature分支进行功能开发。\n- 当功能实现后，在将feature分支合并到develop分支中，等待最后的测试发布。\n  \n### # 具体场景\n#### 1. 新功能开发\n> 基于`develop`，新建功能分支 `f1-feature`，切换到该分支下进行开发\n需要多人开发时，可以推到远端分支\n完成功能开发，将该分支合并到`develop`分支，**并删除`f1-feature`**分支\n\n**2021/12/24 -- 更新：使用 `rebase` 整理提交**  \n关于新分支（命名`f1-feature` 或者 `feat/xxx` ）  \n**1. develop有更新内容需要同步**  \n```shell\n# 提交代码\ngit add .\ngit commit -m 'message'\n\n# 切换 develop 拉取代码\ngit checkout develop\ngit pull\n\n# 切换 本地分支（例：feature），合并代码\ngit checkout feature\ngit rebase -i develop\n```\n-i 意为合并多次提交，运行后显示前几次的提交内容如下：  \n```\npick 281812b message1  \npick e60c7f4 message2  \n```\n当需要合并所有提交的时候，保留一个`pick`，其余修改为 `s`，如下： \n```\npick 281812b message1  \ns e60c7f4 message2  \n```\n`:wq` 提交修改\n\n**代码冲突时，修改冲突后，重新`add`提交，执行`git commit`，展示`message`，根据需求自行修改，再 `git rebase --continue`**  \n\n**2. 本地分支开发完毕需要合并到develop** \n\n```shell\n# 先提交本地分支代码 add --> commit\ngit rebase -i develop\n# 后面的操作如1所示\n# 需要新增的步骤：切换到develop分支，merge 本地分支\ngit merge feature\n\n# 最后 git push\n```\n需要注意的点：在 `git rebase -i develop` 的时候，根据自身情况选择对commit是否进行合并\n#### 2. 发布上线\n基于`develop`分支创建`release-0.1`分支作为预上线分支,有问题，在该分支上修改，最后切换到`develop`和`master`分支下合并该分支，删除`release-0.1`分支\n#### 3.紧急bug修复\n基于`master`分支新建`hotfix-bug1`分支进行修改，修改完切换到`develop`和`master`分支下合并该分支，删除`hotfix-bug1`分支\n### # 常用git操作\n**分支相关**\n```\n// 查看本地分支\ngit branch\n返回🌰\n*master\n\n// 查看远程分支\ngit branch -r\n返回🌰\norigin/master\n\n// 查看本地和远程分支\ngit branch -a\n返回🌰\n*master\n remotes/origin/master\n \n// 切换分支\ngit checkout <branch-name>\n\n// 创建并切换到该分支\ngit checkout -b <branch-name>\n\n// 删除分支\ngit branch -d <branch-name>\n\n// 删除远端分支\ngit push origin -d <branch-name>\n\n// 重命名分支\ngit branch -m <oldbranch-name> <newbranch-name>\n\n// 合并指定分支到当前分支\ngit merge <branch-name>\n```\n\n\n\n","slug":"Git Flow & 常用Git命名和操作","published":1,"updated":"2022-01-29T13:57:10.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p670001rwh9g1kr9yxv","content":"<h2 id=\"简述-Git-Flow\"><a href=\"#简述-Git-Flow\" class=\"headerlink\" title=\"# 简述 Git Flow\"></a># 简述 Git Flow</h2><p>简单来说，<code>Git Flow</code> 就是一套规范的代码管理流程</p>\n<h2 id=\"分支应用情景\"><a href=\"#分支应用情景\" class=\"headerlink\" title=\"# 分支应用情景\"></a># 分支应用情景</h2><ul>\n<li>在<code>Git Flow</code>中，主要的分支有<code>master</code>、<code>develop</code>、<code>hotfix</code>、<code>release</code>、<code>feature</code> 这五种分支  </li>\n<li><code>develop</code> 和 <code>master</code>会被保留，其他的随任务结束而删除  <h3 id=\"master-分支\"><a href=\"#master-分支\" class=\"headerlink\" title=\"# master 分支\"></a># master 分支</h3></li>\n<li>存放稳定上线版本</li>\n<li>这个分支的来源只能从别的分支合并过来，开发者不会直接commit到这个分支上。</li>\n<li>通常我们也会在这个分支上的提交打上版本号标签。<h3 id=\"develop-分支\"><a href=\"#develop-分支\" class=\"headerlink\" title=\"# develop 分支\"></a># develop 分支</h3></li>\n<li>这个分支主要是所有开发的基础分支。</li>\n<li>当要添加功能时，所有功能都是从这个分支切出去的，而功能分支实现后，也都会合并回来这个分支中。<h3 id=\"hotfix-分支\"><a href=\"#hotfix-分支\" class=\"headerlink\" title=\"# hotfix 分支\"></a># hotfix 分支</h3></li>\n<li>用途：处理紧急线上问题</li>\n<li>基于master分支创建</li>\n<li>修复完成，合并到master分支和develop分支中<h3 id=\"release-分支-预上线分支\"><a href=\"#release-分支-预上线分支\" class=\"headerlink\" title=\"# release 分支 (预上线分支)\"></a># release 分支 (预上线分支)</h3></li>\n<li>当<code>develop</code>分支完成需求后，就可以从<code>develop</code>分支中开一个<code>release</code>分支，进行上线前最后的测试。</li>\n<li>测试完成后，释放<code>release</code>分支将会同时合并到<code>master</code>以及<code>develop</code>分支中。<h3 id=\"feature分支\"><a href=\"#feature分支\" class=\"headerlink\" title=\"# feature分支\"></a># feature分支</h3></li>\n<li>当我们需要补充功能的时候，就会从develop分支中开一个feature分支进行功能开发。</li>\n<li>当功能实现后，在将feature分支合并到develop分支中，等待最后的测试发布。</li>\n</ul>\n<h3 id=\"具体场景\"><a href=\"#具体场景\" class=\"headerlink\" title=\"# 具体场景\"></a># 具体场景</h3><h4 id=\"1-新功能开发\"><a href=\"#1-新功能开发\" class=\"headerlink\" title=\"1. 新功能开发\"></a>1. 新功能开发</h4><blockquote>\n<p>基于<code>develop</code>，新建功能分支 <code>f1-feature</code>，切换到该分支下进行开发<br>需要多人开发时，可以推到远端分支<br>完成功能开发，将该分支合并到<code>develop</code>分支，**并删除<code>f1-feature</code>**分支</p>\n</blockquote>\n<p><strong>2021/12/24 – 更新：使用 <code>rebase</code> 整理提交</strong><br>关于新分支（命名<code>f1-feature</code> 或者 <code>feat/xxx</code> ）<br><strong>1. develop有更新内容需要同步</strong>  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 提交代码</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &#x27;message&#x27;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 切换 develop 拉取代码</span></span><br><span class=\"line\">git checkout develop</span><br><span class=\"line\">git pull</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 切换 本地分支（例：feature），合并代码</span></span><br><span class=\"line\">git checkout feature</span><br><span class=\"line\">git rebase -i develop</span><br></pre></td></tr></table></figure>\n<p>-i 意为合并多次提交，运行后显示前几次的提交内容如下：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 281812b message1  </span><br><span class=\"line\">pick e60c7f4 message2  </span><br></pre></td></tr></table></figure>\n<p>当需要合并所有提交的时候，保留一个<code>pick</code>，其余修改为 <code>s</code>，如下： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 281812b message1  </span><br><span class=\"line\">s e60c7f4 message2  </span><br></pre></td></tr></table></figure>\n<p><code>:wq</code> 提交修改</p>\n<p><strong>代码冲突时，修改冲突后，重新<code>add</code>提交，执行<code>git commit</code>，展示<code>message</code>，根据需求自行修改，再 <code>git rebase --continue</code></strong>  </p>\n<p><strong>2. 本地分支开发完毕需要合并到develop</strong> </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先提交本地分支代码 add --&gt; commit</span></span><br><span class=\"line\">git rebase -i develop</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 后面的操作如1所示</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 需要新增的步骤：切换到develop分支，merge 本地分支</span></span><br><span class=\"line\">git merge feature</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 最后 git push</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的点：在 <code>git rebase -i develop</code> 的时候，根据自身情况选择对commit是否进行合并</p>\n<h4 id=\"2-发布上线\"><a href=\"#2-发布上线\" class=\"headerlink\" title=\"2. 发布上线\"></a>2. 发布上线</h4><p>基于<code>develop</code>分支创建<code>release-0.1</code>分支作为预上线分支,有问题，在该分支上修改，最后切换到<code>develop</code>和<code>master</code>分支下合并该分支，删除<code>release-0.1</code>分支</p>\n<h4 id=\"3-紧急bug修复\"><a href=\"#3-紧急bug修复\" class=\"headerlink\" title=\"3.紧急bug修复\"></a>3.紧急bug修复</h4><p>基于<code>master</code>分支新建<code>hotfix-bug1</code>分支进行修改，修改完切换到<code>develop</code>和<code>master</code>分支下合并该分支，删除<code>hotfix-bug1</code>分支</p>\n<h3 id=\"常用git操作\"><a href=\"#常用git操作\" class=\"headerlink\" title=\"# 常用git操作\"></a># 常用git操作</h3><p><strong>分支相关</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看本地分支</span><br><span class=\"line\">git branch</span><br><span class=\"line\">返回🌰</span><br><span class=\"line\">*master</span><br><span class=\"line\"></span><br><span class=\"line\">// 查看远程分支</span><br><span class=\"line\">git branch -r</span><br><span class=\"line\">返回🌰</span><br><span class=\"line\">origin/master</span><br><span class=\"line\"></span><br><span class=\"line\">// 查看本地和远程分支</span><br><span class=\"line\">git branch -a</span><br><span class=\"line\">返回🌰</span><br><span class=\"line\">*master</span><br><span class=\"line\"> remotes/origin/master</span><br><span class=\"line\"> </span><br><span class=\"line\">// 切换分支</span><br><span class=\"line\">git checkout &lt;branch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建并切换到该分支</span><br><span class=\"line\">git checkout -b &lt;branch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除分支</span><br><span class=\"line\">git branch -d &lt;branch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除远端分支</span><br><span class=\"line\">git push origin -d &lt;branch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 重命名分支</span><br><span class=\"line\">git branch -m &lt;oldbranch-name&gt; &lt;newbranch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 合并指定分支到当前分支</span><br><span class=\"line\">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h2 id=\"简述-Git-Flow\"><a href=\"#简述-Git-Flow\" class=\"headerlink\" title=\"# 简述 Git Flow\"></a># 简述 Git Flow</h2><p>简单来说，<code>Git Flow</code> 就是一套规范的代码管理流程</p>\n<h2 id=\"分支应用情景\"><a href=\"#分支应用情景\" class=\"headerlink\" title=\"# 分支应用情景\"></a># 分支应用情景</h2><ul>\n<li>在<code>Git Flow</code>中，主要的分支有<code>master</code>、<code>develop</code>、<code>hotfix</code>、<code>release</code>、<code>feature</code> 这五种分支  </li>\n<li><code>develop</code> 和 <code>master</code>会被保留，其他的随任务结束而删除  <h3 id=\"master-分支\"><a href=\"#master-分支\" class=\"headerlink\" title=\"# master 分支\"></a># master 分支</h3></li>\n<li>存放稳定上线版本</li>\n<li>这个分支的来源只能从别的分支合并过来，开发者不会直接commit到这个分支上。</li>\n<li>通常我们也会在这个分支上的提交打上版本号标签。<h3 id=\"develop-分支\"><a href=\"#develop-分支\" class=\"headerlink\" title=\"# develop 分支\"></a># develop 分支</h3></li>\n<li>这个分支主要是所有开发的基础分支。</li>\n<li>当要添加功能时，所有功能都是从这个分支切出去的，而功能分支实现后，也都会合并回来这个分支中。<h3 id=\"hotfix-分支\"><a href=\"#hotfix-分支\" class=\"headerlink\" title=\"# hotfix 分支\"></a># hotfix 分支</h3></li>\n<li>用途：处理紧急线上问题</li>\n<li>基于master分支创建</li>\n<li>修复完成，合并到master分支和develop分支中<h3 id=\"release-分支-预上线分支\"><a href=\"#release-分支-预上线分支\" class=\"headerlink\" title=\"# release 分支 (预上线分支)\"></a># release 分支 (预上线分支)</h3></li>\n<li>当<code>develop</code>分支完成需求后，就可以从<code>develop</code>分支中开一个<code>release</code>分支，进行上线前最后的测试。</li>\n<li>测试完成后，释放<code>release</code>分支将会同时合并到<code>master</code>以及<code>develop</code>分支中。<h3 id=\"feature分支\"><a href=\"#feature分支\" class=\"headerlink\" title=\"# feature分支\"></a># feature分支</h3></li>\n<li>当我们需要补充功能的时候，就会从develop分支中开一个feature分支进行功能开发。</li>\n<li>当功能实现后，在将feature分支合并到develop分支中，等待最后的测试发布。</li>\n</ul>\n<h3 id=\"具体场景\"><a href=\"#具体场景\" class=\"headerlink\" title=\"# 具体场景\"></a># 具体场景</h3><h4 id=\"1-新功能开发\"><a href=\"#1-新功能开发\" class=\"headerlink\" title=\"1. 新功能开发\"></a>1. 新功能开发</h4><blockquote>\n<p>基于<code>develop</code>，新建功能分支 <code>f1-feature</code>，切换到该分支下进行开发<br>需要多人开发时，可以推到远端分支<br>完成功能开发，将该分支合并到<code>develop</code>分支，**并删除<code>f1-feature</code>**分支</p>\n</blockquote>\n<p><strong>2021/12/24 – 更新：使用 <code>rebase</code> 整理提交</strong><br>关于新分支（命名<code>f1-feature</code> 或者 <code>feat/xxx</code> ）<br><strong>1. develop有更新内容需要同步</strong>  </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 提交代码</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &#x27;message&#x27;</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 切换 develop 拉取代码</span></span><br><span class=\"line\">git checkout develop</span><br><span class=\"line\">git pull</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 切换 本地分支（例：feature），合并代码</span></span><br><span class=\"line\">git checkout feature</span><br><span class=\"line\">git rebase -i develop</span><br></pre></td></tr></table></figure>\n<p>-i 意为合并多次提交，运行后显示前几次的提交内容如下：  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 281812b message1  </span><br><span class=\"line\">pick e60c7f4 message2  </span><br></pre></td></tr></table></figure>\n<p>当需要合并所有提交的时候，保留一个<code>pick</code>，其余修改为 <code>s</code>，如下： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pick 281812b message1  </span><br><span class=\"line\">s e60c7f4 message2  </span><br></pre></td></tr></table></figure>\n<p><code>:wq</code> 提交修改</p>\n<p><strong>代码冲突时，修改冲突后，重新<code>add</code>提交，执行<code>git commit</code>，展示<code>message</code>，根据需求自行修改，再 <code>git rebase --continue</code></strong>  </p>\n<p><strong>2. 本地分支开发完毕需要合并到develop</strong> </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 先提交本地分支代码 add --&gt; commit</span></span><br><span class=\"line\">git rebase -i develop</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 后面的操作如1所示</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 需要新增的步骤：切换到develop分支，merge 本地分支</span></span><br><span class=\"line\">git merge feature</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 最后 git push</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的点：在 <code>git rebase -i develop</code> 的时候，根据自身情况选择对commit是否进行合并</p>\n<h4 id=\"2-发布上线\"><a href=\"#2-发布上线\" class=\"headerlink\" title=\"2. 发布上线\"></a>2. 发布上线</h4><p>基于<code>develop</code>分支创建<code>release-0.1</code>分支作为预上线分支,有问题，在该分支上修改，最后切换到<code>develop</code>和<code>master</code>分支下合并该分支，删除<code>release-0.1</code>分支</p>\n<h4 id=\"3-紧急bug修复\"><a href=\"#3-紧急bug修复\" class=\"headerlink\" title=\"3.紧急bug修复\"></a>3.紧急bug修复</h4><p>基于<code>master</code>分支新建<code>hotfix-bug1</code>分支进行修改，修改完切换到<code>develop</code>和<code>master</code>分支下合并该分支，删除<code>hotfix-bug1</code>分支</p>\n<h3 id=\"常用git操作\"><a href=\"#常用git操作\" class=\"headerlink\" title=\"# 常用git操作\"></a># 常用git操作</h3><p><strong>分支相关</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 查看本地分支</span><br><span class=\"line\">git branch</span><br><span class=\"line\">返回🌰</span><br><span class=\"line\">*master</span><br><span class=\"line\"></span><br><span class=\"line\">// 查看远程分支</span><br><span class=\"line\">git branch -r</span><br><span class=\"line\">返回🌰</span><br><span class=\"line\">origin/master</span><br><span class=\"line\"></span><br><span class=\"line\">// 查看本地和远程分支</span><br><span class=\"line\">git branch -a</span><br><span class=\"line\">返回🌰</span><br><span class=\"line\">*master</span><br><span class=\"line\"> remotes/origin/master</span><br><span class=\"line\"> </span><br><span class=\"line\">// 切换分支</span><br><span class=\"line\">git checkout &lt;branch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建并切换到该分支</span><br><span class=\"line\">git checkout -b &lt;branch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除分支</span><br><span class=\"line\">git branch -d &lt;branch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除远端分支</span><br><span class=\"line\">git push origin -d &lt;branch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 重命名分支</span><br><span class=\"line\">git branch -m &lt;oldbranch-name&gt; &lt;newbranch-name&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">// 合并指定分支到当前分支</span><br><span class=\"line\">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"Js防抖与节流","date":"2021-12-05T16:00:00.000Z","_content":"## 概念\n### 函数防抖（debounce）\n```\n在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\n```\n实际🌰：监听input输入来请求接口，未进行防抖时，键入内容就会请求\n```javascript\n//模拟一段ajax请求\nfunction ajax(content) {\n  console.log('ajax request ' + content)\n}\n\nlet inputa = document.getElementById('unDebounce')\n\ninputa.addEventListener('keyup', function (e) {\n    ajax(e.target.value)\n})\n```\n优化：\n```javascript\n//模拟一段ajax请求\nfunction ajax(content) {\n  console.log('ajax request ' + content)\n}\n\nfunction debounce(fun, delay) {\n    return function (args) {\n        clearTimeout(fun.id)\n        fun.id = setTimeout( () => {\n            fun.call(this, args)\n        }, delay) \n        // setTimeout 返回一个唯一id，在delay时间内clearTimeout 该id可阻止事件\n        // 该处的作用是：事件触发时间内再次触发事件则停止原事件，重新计时\n    }\n}\n    \nlet inputb = document.getElementById('debounce')\n\nlet debounceAjax = debounce(ajax, 500)\n\ninputb.addEventListener('keyup', function (e) {\n        debounceAjax(e.target.value)\n    })\n```\n**函数防抖就像法师发技能的时候要读条，技能读条没完再按技能就会重新读条。**\n\n### 函数节流（throttle）\n```\n规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\n```\n\n实际🌰：需求：无论多快输入，但每1s执行一次请求。\n```javascirpt\nfunction throttle(fun, delay) {\n    let last, deferTimer\n    return function (args) {\n        let that = this\n        let _args = arguments\n        let now = +new Date()\n        clearTimeout(deferTimer) // 重复调用清空上一次的setTime\n        // 当第一次调用 或者 键入操作持续一秒后（此时由于clear的作用，last一直没更新，last + delay 会小于now） 会走 else分支\n        if (last && now < last + delay) {\n            deferTimer = setTimeout(function () {\n                last = now\n                fun.apply(that, _args)\n            }, delay)\n        }else {\n            last = now\n            fun.apply(that,_args)\n        }\n    }\n}\n\nlet throttleAjax = throttle(ajax, 1000)\n\nlet inputc = document.getElementById('throttle')\ninputc.addEventListener('keyup', function(e) {\n    throttleAjax(e.target.value)\n})\n```\n\n**函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。**\n\n## 总结\n- 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。\n- 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。\n\n## 实际应用\n- debounce\n  - search搜索联想，用户在不断输入值时，用防抖来节约请求资源。\n  - window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次\n- throttle\n  - 鼠标不断点击触发，mousedown(单位时间内只触发一次)\n  - 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断\n\n## lodash 中的防抖节流方法\n\n```\n// 安装 `lodash`\nnpm i --save lodash\n// 引用\nimport _ from 'lodash'\n\n// 使用防抖\nconst debounced = _.debounced(func, wait, options)\n```\n**各参数**\n`func` (Function): 要防抖动的函数。    \n`[wait=0]` (number): 需要延迟的毫秒数。  \n`[options=]` (Object): 选项对象。  \n`[options.leading=false]` (boolean): 指定在延迟开始前调用。  \n`[options.maxWait]` (number): 设置 func 允许被延迟的最大值。  \n`[options.trailing=true]` (boolean): 指定在延迟结束后调用。\n\n**需要注意的点**  \n`_.debounced()`的返回值为`func`的返回值，默认参数情况（例如：`_.debounced(func, 500)`）在防抖阶段，因为还未执行`func`的`return`，返回为`undefined`  \n\n**节流`_.throttle()`**\n  \n## 参考\n作者：薄荷前端  \n链接：https://juejin.cn/post/6844903669389885453  \n来源：稀土掘金\n","source":"_posts/Js防抖与节流.md","raw":"---\ntitle: Js防抖与节流\ndate: 2021-12-06\ncategories:\n- 前端\ntags:\n- javascript\n- 防抖节流\n---\n## 概念\n### 函数防抖（debounce）\n```\n在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\n```\n实际🌰：监听input输入来请求接口，未进行防抖时，键入内容就会请求\n```javascript\n//模拟一段ajax请求\nfunction ajax(content) {\n  console.log('ajax request ' + content)\n}\n\nlet inputa = document.getElementById('unDebounce')\n\ninputa.addEventListener('keyup', function (e) {\n    ajax(e.target.value)\n})\n```\n优化：\n```javascript\n//模拟一段ajax请求\nfunction ajax(content) {\n  console.log('ajax request ' + content)\n}\n\nfunction debounce(fun, delay) {\n    return function (args) {\n        clearTimeout(fun.id)\n        fun.id = setTimeout( () => {\n            fun.call(this, args)\n        }, delay) \n        // setTimeout 返回一个唯一id，在delay时间内clearTimeout 该id可阻止事件\n        // 该处的作用是：事件触发时间内再次触发事件则停止原事件，重新计时\n    }\n}\n    \nlet inputb = document.getElementById('debounce')\n\nlet debounceAjax = debounce(ajax, 500)\n\ninputb.addEventListener('keyup', function (e) {\n        debounceAjax(e.target.value)\n    })\n```\n**函数防抖就像法师发技能的时候要读条，技能读条没完再按技能就会重新读条。**\n\n### 函数节流（throttle）\n```\n规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\n```\n\n实际🌰：需求：无论多快输入，但每1s执行一次请求。\n```javascirpt\nfunction throttle(fun, delay) {\n    let last, deferTimer\n    return function (args) {\n        let that = this\n        let _args = arguments\n        let now = +new Date()\n        clearTimeout(deferTimer) // 重复调用清空上一次的setTime\n        // 当第一次调用 或者 键入操作持续一秒后（此时由于clear的作用，last一直没更新，last + delay 会小于now） 会走 else分支\n        if (last && now < last + delay) {\n            deferTimer = setTimeout(function () {\n                last = now\n                fun.apply(that, _args)\n            }, delay)\n        }else {\n            last = now\n            fun.apply(that,_args)\n        }\n    }\n}\n\nlet throttleAjax = throttle(ajax, 1000)\n\nlet inputc = document.getElementById('throttle')\ninputc.addEventListener('keyup', function(e) {\n    throttleAjax(e.target.value)\n})\n```\n\n**函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。**\n\n## 总结\n- 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。\n- 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。\n\n## 实际应用\n- debounce\n  - search搜索联想，用户在不断输入值时，用防抖来节约请求资源。\n  - window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次\n- throttle\n  - 鼠标不断点击触发，mousedown(单位时间内只触发一次)\n  - 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断\n\n## lodash 中的防抖节流方法\n\n```\n// 安装 `lodash`\nnpm i --save lodash\n// 引用\nimport _ from 'lodash'\n\n// 使用防抖\nconst debounced = _.debounced(func, wait, options)\n```\n**各参数**\n`func` (Function): 要防抖动的函数。    \n`[wait=0]` (number): 需要延迟的毫秒数。  \n`[options=]` (Object): 选项对象。  \n`[options.leading=false]` (boolean): 指定在延迟开始前调用。  \n`[options.maxWait]` (number): 设置 func 允许被延迟的最大值。  \n`[options.trailing=true]` (boolean): 指定在延迟结束后调用。\n\n**需要注意的点**  \n`_.debounced()`的返回值为`func`的返回值，默认参数情况（例如：`_.debounced(func, 500)`）在防抖阶段，因为还未执行`func`的`return`，返回为`undefined`  \n\n**节流`_.throttle()`**\n  \n## 参考\n作者：薄荷前端  \n链接：https://juejin.cn/post/6844903669389885453  \n来源：稀土掘金\n","slug":"Js防抖与节流","published":1,"updated":"2022-01-29T13:57:33.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p6b0003rwh99knv34in","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"函数防抖（debounce）\"><a href=\"#函数防抖（debounce）\" class=\"headerlink\" title=\"函数防抖（debounce）\"></a>函数防抖（debounce）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</span><br></pre></td></tr></table></figure>\n<p>实际🌰：监听input输入来请求接口，未进行防抖时，键入内容就会请求</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟一段ajax请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ajax request &#x27;</span> + content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> inputa = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;unDebounce&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">inputa.addEventListener(<span class=\"string\">&#x27;keyup&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    ajax(e.target.value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>优化：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟一段ajax请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ajax request &#x27;</span> + content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fun, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(fun.id)</span><br><span class=\"line\">        fun.id = <span class=\"built_in\">setTimeout</span>( <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            fun.call(<span class=\"built_in\">this</span>, args)</span><br><span class=\"line\">        &#125;, delay) </span><br><span class=\"line\">        <span class=\"comment\">// setTimeout 返回一个唯一id，在delay时间内clearTimeout 该id可阻止事件</span></span><br><span class=\"line\">        <span class=\"comment\">// 该处的作用是：事件触发时间内再次触发事件则停止原事件，重新计时</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">let</span> inputb = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;debounce&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> debounceAjax = debounce(ajax, <span class=\"number\">500</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">inputb.addEventListener(<span class=\"string\">&#x27;keyup&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        debounceAjax(e.target.value)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>函数防抖就像法师发技能的时候要读条，技能读条没完再按技能就会重新读条。</strong></p>\n<h3 id=\"函数节流（throttle）\"><a href=\"#函数节流（throttle）\" class=\"headerlink\" title=\"函数节流（throttle）\"></a>函数节流（throttle）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</span><br></pre></td></tr></table></figure>\n\n<p>实际🌰：需求：无论多快输入，但每1s执行一次请求。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fun, delay) &#123;</span><br><span class=\"line\">    let last, deferTimer</span><br><span class=\"line\">    return function (args) &#123;</span><br><span class=\"line\">        let that = this</span><br><span class=\"line\">        let _args = arguments</span><br><span class=\"line\">        let now = +new Date()</span><br><span class=\"line\">        clearTimeout(deferTimer) // 重复调用清空上一次的setTime</span><br><span class=\"line\">        // 当第一次调用 或者 键入操作持续一秒后（此时由于clear的作用，last一直没更新，last + delay 会小于now） 会走 else分支</span><br><span class=\"line\">        if (last &amp;&amp; now &lt; last + delay) &#123;</span><br><span class=\"line\">            deferTimer = setTimeout(function () &#123;</span><br><span class=\"line\">                last = now</span><br><span class=\"line\">                fun.apply(that, _args)</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            last = now</span><br><span class=\"line\">            fun.apply(that,_args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let throttleAjax = throttle(ajax, 1000)</span><br><span class=\"line\"></span><br><span class=\"line\">let inputc = document.getElementById(&#x27;throttle&#x27;)</span><br><span class=\"line\">inputc.addEventListener(&#x27;keyup&#x27;, function(e) &#123;</span><br><span class=\"line\">    throttleAjax(e.target.value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li>\n<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>\n</ul>\n<h2 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h2><ul>\n<li>debounce<ul>\n<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li>\n<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>\n</ul>\n</li>\n<li>throttle<ul>\n<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>\n<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"lodash-中的防抖节流方法\"><a href=\"#lodash-中的防抖节流方法\" class=\"headerlink\" title=\"lodash 中的防抖节流方法\"></a>lodash 中的防抖节流方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安装 `lodash`</span><br><span class=\"line\">npm i --save lodash</span><br><span class=\"line\">// 引用</span><br><span class=\"line\">import _ from &#x27;lodash&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用防抖</span><br><span class=\"line\">const debounced = _.debounced(func, wait, options)</span><br></pre></td></tr></table></figure>\n<p><strong>各参数</strong><br><code>func</code> (Function): 要防抖动的函数。<br><code>[wait=0]</code> (number): 需要延迟的毫秒数。<br><code>[options=]</code> (Object): 选项对象。<br><code>[options.leading=false]</code> (boolean): 指定在延迟开始前调用。<br><code>[options.maxWait]</code> (number): 设置 func 允许被延迟的最大值。<br><code>[options.trailing=true]</code> (boolean): 指定在延迟结束后调用。</p>\n<p><strong>需要注意的点</strong><br><code>_.debounced()</code>的返回值为<code>func</code>的返回值，默认参数情况（例如：<code>_.debounced(func, 500)</code>）在防抖阶段，因为还未执行<code>func</code>的<code>return</code>，返回为<code>undefined</code>  </p>\n<p><strong>节流<code>_.throttle()</code></strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>作者：薄荷前端<br>链接：<a href=\"https://juejin.cn/post/6844903669389885453\">https://juejin.cn/post/6844903669389885453</a><br>来源：稀土掘金</p>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><h3 id=\"函数防抖（debounce）\"><a href=\"#函数防抖（debounce）\" class=\"headerlink\" title=\"函数防抖（debounce）\"></a>函数防抖（debounce）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</span><br></pre></td></tr></table></figure>\n<p>实际🌰：监听input输入来请求接口，未进行防抖时，键入内容就会请求</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟一段ajax请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ajax request &#x27;</span> + content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> inputa = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;unDebounce&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">inputa.addEventListener(<span class=\"string\">&#x27;keyup&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    ajax(e.target.value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>优化：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模拟一段ajax请求</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ajax</span>(<span class=\"params\">content</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;ajax request &#x27;</span> + content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fun, delay</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(fun.id)</span><br><span class=\"line\">        fun.id = <span class=\"built_in\">setTimeout</span>( <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            fun.call(<span class=\"built_in\">this</span>, args)</span><br><span class=\"line\">        &#125;, delay) </span><br><span class=\"line\">        <span class=\"comment\">// setTimeout 返回一个唯一id，在delay时间内clearTimeout 该id可阻止事件</span></span><br><span class=\"line\">        <span class=\"comment\">// 该处的作用是：事件触发时间内再次触发事件则停止原事件，重新计时</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">let</span> inputb = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;debounce&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> debounceAjax = debounce(ajax, <span class=\"number\">500</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">inputb.addEventListener(<span class=\"string\">&#x27;keyup&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        debounceAjax(e.target.value)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>函数防抖就像法师发技能的时候要读条，技能读条没完再按技能就会重新读条。</strong></p>\n<h3 id=\"函数节流（throttle）\"><a href=\"#函数节流（throttle）\" class=\"headerlink\" title=\"函数节流（throttle）\"></a>函数节流（throttle）</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</span><br></pre></td></tr></table></figure>\n\n<p>实际🌰：需求：无论多快输入，但每1s执行一次请求。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fun, delay) &#123;</span><br><span class=\"line\">    let last, deferTimer</span><br><span class=\"line\">    return function (args) &#123;</span><br><span class=\"line\">        let that = this</span><br><span class=\"line\">        let _args = arguments</span><br><span class=\"line\">        let now = +new Date()</span><br><span class=\"line\">        clearTimeout(deferTimer) // 重复调用清空上一次的setTime</span><br><span class=\"line\">        // 当第一次调用 或者 键入操作持续一秒后（此时由于clear的作用，last一直没更新，last + delay 会小于now） 会走 else分支</span><br><span class=\"line\">        if (last &amp;&amp; now &lt; last + delay) &#123;</span><br><span class=\"line\">            deferTimer = setTimeout(function () &#123;</span><br><span class=\"line\">                last = now</span><br><span class=\"line\">                fun.apply(that, _args)</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            last = now</span><br><span class=\"line\">            fun.apply(that,_args)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let throttleAjax = throttle(ajax, 1000)</span><br><span class=\"line\"></span><br><span class=\"line\">let inputc = document.getElementById(&#x27;throttle&#x27;)</span><br><span class=\"line\">inputc.addEventListener(&#x27;keyup&#x27;, function(e) &#123;</span><br><span class=\"line\">    throttleAjax(e.target.value)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。</strong></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li>\n<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>\n</ul>\n<h2 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h2><ul>\n<li>debounce<ul>\n<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li>\n<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>\n</ul>\n</li>\n<li>throttle<ul>\n<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>\n<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"lodash-中的防抖节流方法\"><a href=\"#lodash-中的防抖节流方法\" class=\"headerlink\" title=\"lodash 中的防抖节流方法\"></a>lodash 中的防抖节流方法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 安装 `lodash`</span><br><span class=\"line\">npm i --save lodash</span><br><span class=\"line\">// 引用</span><br><span class=\"line\">import _ from &#x27;lodash&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用防抖</span><br><span class=\"line\">const debounced = _.debounced(func, wait, options)</span><br></pre></td></tr></table></figure>\n<p><strong>各参数</strong><br><code>func</code> (Function): 要防抖动的函数。<br><code>[wait=0]</code> (number): 需要延迟的毫秒数。<br><code>[options=]</code> (Object): 选项对象。<br><code>[options.leading=false]</code> (boolean): 指定在延迟开始前调用。<br><code>[options.maxWait]</code> (number): 设置 func 允许被延迟的最大值。<br><code>[options.trailing=true]</code> (boolean): 指定在延迟结束后调用。</p>\n<p><strong>需要注意的点</strong><br><code>_.debounced()</code>的返回值为<code>func</code>的返回值，默认参数情况（例如：<code>_.debounced(func, 500)</code>）在防抖阶段，因为还未执行<code>func</code>的<code>return</code>，返回为<code>undefined</code>  </p>\n<p><strong>节流<code>_.throttle()</code></strong></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>作者：薄荷前端<br>链接：<a href=\"https://juejin.cn/post/6844903669389885453\">https://juejin.cn/post/6844903669389885453</a><br>来源：稀土掘金</p>\n"},{"title":"(转载) lodash源码 chunk","date":"2021-12-19T16:00:00.000Z","_content":"## _.chunk(array, [size=1])\n> 介绍：将数组（`array`）拆分成多个 `size` 长度的区块，并将这些区块组成一个新数组。 如果array 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。  \n参数：  \n`array` (Array): 需要处理的数组  \n`[size=1]` (number): 每个数组区块的长度\n\n#### 用途\n`chunk` 函数在前端可以用来缓解一些性能问题。例如大量的 `DOM` 操作，可以分块让浏览器在空闲的时候处理，避免页面卡死。如下面的代码，向页面中插入大量的 `DOM` 。\n```javascript\nconst arr = [] // 1万条数据\nconst chunks = _.chunk(arr, 100)\n\nconst append = function () {\n  if (chunks.length > 0) {\n    const current = chunks.pop()\n    current.forEach(item => {\n      const node = document.createElement('div')\n      node.innerText = item\n      document.body.appendChild(node)\n    })\n    setTimeout(append, 0)\n  }\n}\n\nappend()\n```\n#### 依赖\n```javascript\nimport slice from './slice.js'\n```\n#### 原理\n`chunk` 的原理归结起来就是切割和放置。  \n\n`chunk` 最后返回的结果如`[[1],[1],[1]]`的形式，放置就是将切割下来的块放置到数组容器中。  \n\n那要怎样切割呢？\n\n因为指定了大小，因此切割跟切蛋糕很像，参数 `size` 是尺子，测好每块的长度，`slice` 函数是刀， 将数组一块一块切出来。  例如有 `[1,2,3,4,5]` 这个数组，`size` 指定为 `2`，则第一次切割会得到 `[1,2]` 的块，第二次切割得到 `[4,5]`，剩下的是 `[5]` 。这个数组最终会被切为三块。\n#### 源码总览\n```javascript\nfunction chunk(array, size) {\n  // 确保 length 存在 且 size 比 1 大\n  size = Math.max(size, 0)\n  const length = array == null ? 0 : array.length\n  // 否则 返回空数组\n  if (!length || size < 1) {\n    return []\n  }\n  let index = 0\n  let resIndex = 0\n  // 新建数组result，长度为分割后块的数量\n  const result = new Array(Math.ceil(length / size))\n  // 切割 array 放于 result 中，注意 index，每次切割，index增加size长度\n  while (index < length) {\n    result[resIndex++] = slice(array, index, (index += size))\n  }\n  return result\n}\n```\n\n#### 备注\n`Math.round()`  “四舍五入”， 该函数返回的是一个四舍五入后的的整数  \n`Math.ceil()`  “向上取整”， 即小数部分直接舍去，并向正数部分进1  \n`Math.floor()`  “向下取整” ，即小数部分直接舍去","source":"_posts/lodash源码 chunk.md","raw":"---\ntitle: (转载) lodash源码 chunk\ndate: 2021-12-20\ncategories:\n- 前端\ntags:\n- javascript\n- lodash\n---\n## _.chunk(array, [size=1])\n> 介绍：将数组（`array`）拆分成多个 `size` 长度的区块，并将这些区块组成一个新数组。 如果array 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。  \n参数：  \n`array` (Array): 需要处理的数组  \n`[size=1]` (number): 每个数组区块的长度\n\n#### 用途\n`chunk` 函数在前端可以用来缓解一些性能问题。例如大量的 `DOM` 操作，可以分块让浏览器在空闲的时候处理，避免页面卡死。如下面的代码，向页面中插入大量的 `DOM` 。\n```javascript\nconst arr = [] // 1万条数据\nconst chunks = _.chunk(arr, 100)\n\nconst append = function () {\n  if (chunks.length > 0) {\n    const current = chunks.pop()\n    current.forEach(item => {\n      const node = document.createElement('div')\n      node.innerText = item\n      document.body.appendChild(node)\n    })\n    setTimeout(append, 0)\n  }\n}\n\nappend()\n```\n#### 依赖\n```javascript\nimport slice from './slice.js'\n```\n#### 原理\n`chunk` 的原理归结起来就是切割和放置。  \n\n`chunk` 最后返回的结果如`[[1],[1],[1]]`的形式，放置就是将切割下来的块放置到数组容器中。  \n\n那要怎样切割呢？\n\n因为指定了大小，因此切割跟切蛋糕很像，参数 `size` 是尺子，测好每块的长度，`slice` 函数是刀， 将数组一块一块切出来。  例如有 `[1,2,3,4,5]` 这个数组，`size` 指定为 `2`，则第一次切割会得到 `[1,2]` 的块，第二次切割得到 `[4,5]`，剩下的是 `[5]` 。这个数组最终会被切为三块。\n#### 源码总览\n```javascript\nfunction chunk(array, size) {\n  // 确保 length 存在 且 size 比 1 大\n  size = Math.max(size, 0)\n  const length = array == null ? 0 : array.length\n  // 否则 返回空数组\n  if (!length || size < 1) {\n    return []\n  }\n  let index = 0\n  let resIndex = 0\n  // 新建数组result，长度为分割后块的数量\n  const result = new Array(Math.ceil(length / size))\n  // 切割 array 放于 result 中，注意 index，每次切割，index增加size长度\n  while (index < length) {\n    result[resIndex++] = slice(array, index, (index += size))\n  }\n  return result\n}\n```\n\n#### 备注\n`Math.round()`  “四舍五入”， 该函数返回的是一个四舍五入后的的整数  \n`Math.ceil()`  “向上取整”， 即小数部分直接舍去，并向正数部分进1  \n`Math.floor()`  “向下取整” ，即小数部分直接舍去","slug":"lodash源码 chunk","published":1,"updated":"2022-01-29T13:58:11.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p6k0006rwh9grjx65lo","content":"<h2 id=\"chunk-array-size-1\"><a href=\"#chunk-array-size-1\" class=\"headerlink\" title=\"_.chunk(array, [size=1])\"></a>_.chunk(array, [size=1])</h2><blockquote>\n<p>介绍：将数组（<code>array</code>）拆分成多个 <code>size</code> 长度的区块，并将这些区块组成一个新数组。 如果array 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。<br>参数：<br><code>array</code> (Array): 需要处理的数组<br><code>[size=1]</code> (number): 每个数组区块的长度</p>\n</blockquote>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><p><code>chunk</code> 函数在前端可以用来缓解一些性能问题。例如大量的 <code>DOM</code> 操作，可以分块让浏览器在空闲的时候处理，避免页面卡死。如下面的代码，向页面中插入大量的 <code>DOM</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [] <span class=\"comment\">// 1万条数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chunks = _.chunk(arr, <span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> append = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (chunks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> current = chunks.pop()</span><br><span class=\"line\">    current.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;div&#x27;</span>)</span><br><span class=\"line\">      node.innerText = item</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.appendChild(node)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(append, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">append()</span><br></pre></td></tr></table></figure>\n<h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> slice <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./slice.js&#x27;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><code>chunk</code> 的原理归结起来就是切割和放置。  </p>\n<p><code>chunk</code> 最后返回的结果如<code>[[1],[1],[1]]</code>的形式，放置就是将切割下来的块放置到数组容器中。  </p>\n<p>那要怎样切割呢？</p>\n<p>因为指定了大小，因此切割跟切蛋糕很像，参数 <code>size</code> 是尺子，测好每块的长度，<code>slice</code> 函数是刀， 将数组一块一块切出来。  例如有 <code>[1,2,3,4,5]</code> 这个数组，<code>size</code> 指定为 <code>2</code>，则第一次切割会得到 <code>[1,2]</code> 的块，第二次切割得到 <code>[4,5]</code>，剩下的是 <code>[5]</code> 。这个数组最终会被切为三块。</p>\n<h4 id=\"源码总览\"><a href=\"#源码总览\" class=\"headerlink\" title=\"源码总览\"></a>源码总览</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chunk</span>(<span class=\"params\">array, size</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确保 length 存在 且 size 比 1 大</span></span><br><span class=\"line\">  size = <span class=\"built_in\">Math</span>.max(size, <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length</span><br><span class=\"line\">  <span class=\"comment\">// 否则 返回空数组</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!length || size &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> resIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"comment\">// 新建数组result，长度为分割后块的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"built_in\">Math</span>.ceil(length / size))</span><br><span class=\"line\">  <span class=\"comment\">// 切割 array 放于 result 中，注意 index，每次切割，index增加size长度</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; length) &#123;</span><br><span class=\"line\">    result[resIndex++] = slice(array, index, (index += size))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h4><p><code>Math.round()</code>  “四舍五入”， 该函数返回的是一个四舍五入后的的整数<br><code>Math.ceil()</code>  “向上取整”， 即小数部分直接舍去，并向正数部分进1<br><code>Math.floor()</code>  “向下取整” ，即小数部分直接舍去</p>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h2 id=\"chunk-array-size-1\"><a href=\"#chunk-array-size-1\" class=\"headerlink\" title=\"_.chunk(array, [size=1])\"></a>_.chunk(array, [size=1])</h2><blockquote>\n<p>介绍：将数组（<code>array</code>）拆分成多个 <code>size</code> 长度的区块，并将这些区块组成一个新数组。 如果array 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。<br>参数：<br><code>array</code> (Array): 需要处理的数组<br><code>[size=1]</code> (number): 每个数组区块的长度</p>\n</blockquote>\n<h4 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h4><p><code>chunk</code> 函数在前端可以用来缓解一些性能问题。例如大量的 <code>DOM</code> 操作，可以分块让浏览器在空闲的时候处理，避免页面卡死。如下面的代码，向页面中插入大量的 <code>DOM</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [] <span class=\"comment\">// 1万条数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chunks = _.chunk(arr, <span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> append = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (chunks.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> current = chunks.pop()</span><br><span class=\"line\">    current.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;div&#x27;</span>)</span><br><span class=\"line\">      node.innerText = item</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.body.appendChild(node)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(append, <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">append()</span><br></pre></td></tr></table></figure>\n<h4 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> slice <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./slice.js&#x27;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p><code>chunk</code> 的原理归结起来就是切割和放置。  </p>\n<p><code>chunk</code> 最后返回的结果如<code>[[1],[1],[1]]</code>的形式，放置就是将切割下来的块放置到数组容器中。  </p>\n<p>那要怎样切割呢？</p>\n<p>因为指定了大小，因此切割跟切蛋糕很像，参数 <code>size</code> 是尺子，测好每块的长度，<code>slice</code> 函数是刀， 将数组一块一块切出来。  例如有 <code>[1,2,3,4,5]</code> 这个数组，<code>size</code> 指定为 <code>2</code>，则第一次切割会得到 <code>[1,2]</code> 的块，第二次切割得到 <code>[4,5]</code>，剩下的是 <code>[5]</code> 。这个数组最终会被切为三块。</p>\n<h4 id=\"源码总览\"><a href=\"#源码总览\" class=\"headerlink\" title=\"源码总览\"></a>源码总览</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chunk</span>(<span class=\"params\">array, size</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 确保 length 存在 且 size 比 1 大</span></span><br><span class=\"line\">  size = <span class=\"built_in\">Math</span>.max(size, <span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length</span><br><span class=\"line\">  <span class=\"comment\">// 否则 返回空数组</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!length || size &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> resIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"comment\">// 新建数组result，长度为分割后块的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"built_in\">Math</span>.ceil(length / size))</span><br><span class=\"line\">  <span class=\"comment\">// 切割 array 放于 result 中，注意 index，每次切割，index增加size长度</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (index &lt; length) &#123;</span><br><span class=\"line\">    result[resIndex++] = slice(array, index, (index += size))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h4><p><code>Math.round()</code>  “四舍五入”， 该函数返回的是一个四舍五入后的的整数<br><code>Math.ceil()</code>  “向上取整”， 即小数部分直接舍去，并向正数部分进1<br><code>Math.floor()</code>  “向下取整” ，即小数部分直接舍去</p>\n"},{"title":"(转载) lodash源码 compact","date":"2021-12-19T16:00:00.000Z","_content":"## _.compact(array)\n> 介绍：创建一个新数组，包含原数组中所有的非假值元素。例如`false` , `null` , `0` , `\"\"` , `undefined` , 和 `NaN` 都是被认为是“假值”。  \n🌰\n```javascript\nvar arr = [1,false,2,null,3,0,4,NaN,5,undefined]\n_.compact(arr) // 返回 [1，2，3，4，5]\n```\n#### 源码\n```javascript\nfunction compact(array) {\n  let resIndex = 0\n  const result = []\n\n  if (array == null) {\n    return result\n  }\n\n  for (const value of array) {\n    if (value) {\n      result[resIndex++] = value\n    }\n  }\n  return result\n}\n```\n#### 为什么使用 `for  of`\n> 遍历除了 `for  of` 还有 `for`、`for in`，使用 `for`的话，不够间接，下面讨论为什么不使用`for in`\n\n##### for in\n\nfor in是以**任意顺序**遍历一个对象的[可枚举属性](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)。  \n\n在数组中，数组的索引是可枚举属性，可以用 for...in 来遍历数组的索引，数组中的稀疏部分不存在索引，可以避免用 for 循环造成无效遍历的弊端。\n\n但是，for...in 的遍历顺序依赖于执行环境，不同执行环境的实现方式可能会不一样。单凭这一点，就断然不能在数组遍历中使用 for...in，大多数情况下，顺序对于数组的遍历都相当重要。\n\n另外，先看个🌰\n```javascript\nvar arr = [1,2,3]\narr.foo = 'foo'\nfor (let index in arr) {\n  console.log(index)\n}\n```\n在这个例子中，你期望输出的是 0,1,2，但是最后输出的可能是 0,1,2,foo （for...in 不能保证顺序）。因为 foo 也是可枚举属性，在 for..in 会被遍历出来。\n\n##### for of\n`for...of` 循环内部调用的就是数组原型链上的 `Symbol.iterator` 方法。\n\n`Symbol.iterator` 在调用的时候会返回一个遍历器对象，这个遍历器对象中包含 `next` 方法，`for...of` 在每次循环的时候都会调用 `next` 方法来获取值，直到 `next` 返回的对象中的 `done`属性值为 `true` 时停止。\n\n手动调用来模拟遍历的过程：\n```javascript\nconst arr = [1,2,3]\nconst iterator = a[Symbol.iterator]()\niterator.next() // {value: 1, done: false}\niterator.next() // {value: 2, done: false}\niterator.next() // {value: 3, done: false}\niterator.next() // {value: undefined, done: true}\n```\n\n因此在不改写 `Symbol.iterator` 的情况下, 使用 `for...of` 来遍历数组是安全的，因为这个方法(`Symbol.iterator`)是数组的原生方法。","source":"_posts/lodash源码 compact.md","raw":"---\ntitle: (转载) lodash源码 compact\ndate: 2021-12-20\ncategories:\n- 前端\ntags:\n- javascript\n- lodash\n---\n## _.compact(array)\n> 介绍：创建一个新数组，包含原数组中所有的非假值元素。例如`false` , `null` , `0` , `\"\"` , `undefined` , 和 `NaN` 都是被认为是“假值”。  \n🌰\n```javascript\nvar arr = [1,false,2,null,3,0,4,NaN,5,undefined]\n_.compact(arr) // 返回 [1，2，3，4，5]\n```\n#### 源码\n```javascript\nfunction compact(array) {\n  let resIndex = 0\n  const result = []\n\n  if (array == null) {\n    return result\n  }\n\n  for (const value of array) {\n    if (value) {\n      result[resIndex++] = value\n    }\n  }\n  return result\n}\n```\n#### 为什么使用 `for  of`\n> 遍历除了 `for  of` 还有 `for`、`for in`，使用 `for`的话，不够间接，下面讨论为什么不使用`for in`\n\n##### for in\n\nfor in是以**任意顺序**遍历一个对象的[可枚举属性](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)。  \n\n在数组中，数组的索引是可枚举属性，可以用 for...in 来遍历数组的索引，数组中的稀疏部分不存在索引，可以避免用 for 循环造成无效遍历的弊端。\n\n但是，for...in 的遍历顺序依赖于执行环境，不同执行环境的实现方式可能会不一样。单凭这一点，就断然不能在数组遍历中使用 for...in，大多数情况下，顺序对于数组的遍历都相当重要。\n\n另外，先看个🌰\n```javascript\nvar arr = [1,2,3]\narr.foo = 'foo'\nfor (let index in arr) {\n  console.log(index)\n}\n```\n在这个例子中，你期望输出的是 0,1,2，但是最后输出的可能是 0,1,2,foo （for...in 不能保证顺序）。因为 foo 也是可枚举属性，在 for..in 会被遍历出来。\n\n##### for of\n`for...of` 循环内部调用的就是数组原型链上的 `Symbol.iterator` 方法。\n\n`Symbol.iterator` 在调用的时候会返回一个遍历器对象，这个遍历器对象中包含 `next` 方法，`for...of` 在每次循环的时候都会调用 `next` 方法来获取值，直到 `next` 返回的对象中的 `done`属性值为 `true` 时停止。\n\n手动调用来模拟遍历的过程：\n```javascript\nconst arr = [1,2,3]\nconst iterator = a[Symbol.iterator]()\niterator.next() // {value: 1, done: false}\niterator.next() // {value: 2, done: false}\niterator.next() // {value: 3, done: false}\niterator.next() // {value: undefined, done: true}\n```\n\n因此在不改写 `Symbol.iterator` 的情况下, 使用 `for...of` 来遍历数组是安全的，因为这个方法(`Symbol.iterator`)是数组的原生方法。","slug":"lodash源码 compact","published":1,"updated":"2022-01-29T13:58:14.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p6q0007rwh9dcvs6vng","content":"<h2 id=\"compact-array\"><a href=\"#compact-array\" class=\"headerlink\" title=\"_.compact(array)\"></a>_.compact(array)</h2><blockquote>\n<p>介绍：创建一个新数组，包含原数组中所有的非假值元素。例如<code>false</code> , <code>null</code> , <code>0</code> , <code>&quot;&quot;</code> , <code>undefined</code> , 和 <code>NaN</code> 都是被认为是“假值”。<br>🌰</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"literal\">false</span>,<span class=\"number\">2</span>,<span class=\"literal\">null</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"literal\">NaN</span>,<span class=\"number\">5</span>,<span class=\"literal\">undefined</span>]</span><br><span class=\"line\">_.compact(arr) <span class=\"comment\">// 返回 [1，2，3，4，5]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compact</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> resIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value) &#123;</span><br><span class=\"line\">      result[resIndex++] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"为什么使用-for-of\"><a href=\"#为什么使用-for-of\" class=\"headerlink\" title=\"为什么使用 for  of\"></a>为什么使用 <code>for  of</code></h4><blockquote>\n<p>遍历除了 <code>for  of</code> 还有 <code>for</code>、<code>for in</code>，使用 <code>for</code>的话，不够间接，下面讨论为什么不使用<code>for in</code></p>\n</blockquote>\n<h5 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for in\"></a>for in</h5><p>for in是以<strong>任意顺序</strong>遍历一个对象的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\">可枚举属性</a>。  </p>\n<p>在数组中，数组的索引是可枚举属性，可以用 for…in 来遍历数组的索引，数组中的稀疏部分不存在索引，可以避免用 for 循环造成无效遍历的弊端。</p>\n<p>但是，for…in 的遍历顺序依赖于执行环境，不同执行环境的实现方式可能会不一样。单凭这一点，就断然不能在数组遍历中使用 for…in，大多数情况下，顺序对于数组的遍历都相当重要。</p>\n<p>另外，先看个🌰</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">arr.foo = <span class=\"string\">&#x27;foo&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，你期望输出的是 0,1,2，但是最后输出的可能是 0,1,2,foo （for…in 不能保证顺序）。因为 foo 也是可枚举属性，在 for..in 会被遍历出来。</p>\n<h5 id=\"for-of\"><a href=\"#for-of\" class=\"headerlink\" title=\"for of\"></a>for of</h5><p><code>for...of</code> 循环内部调用的就是数组原型链上的 <code>Symbol.iterator</code> 方法。</p>\n<p><code>Symbol.iterator</code> 在调用的时候会返回一个遍历器对象，这个遍历器对象中包含 <code>next</code> 方法，<code>for...of</code> 在每次循环的时候都会调用 <code>next</code> 方法来获取值，直到 <code>next</code> 返回的对象中的 <code>done</code>属性值为 <code>true</code> 时停止。</p>\n<p>手动调用来模拟遍历的过程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> iterator = a[<span class=\"built_in\">Symbol</span>.iterator]()</span><br><span class=\"line\">iterator.next() <span class=\"comment\">// &#123;value: 1, done: false&#125;</span></span><br><span class=\"line\">iterator.next() <span class=\"comment\">// &#123;value: 2, done: false&#125;</span></span><br><span class=\"line\">iterator.next() <span class=\"comment\">// &#123;value: 3, done: false&#125;</span></span><br><span class=\"line\">iterator.next() <span class=\"comment\">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>因此在不改写 <code>Symbol.iterator</code> 的情况下, 使用 <code>for...of</code> 来遍历数组是安全的，因为这个方法(<code>Symbol.iterator</code>)是数组的原生方法。</p>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h2 id=\"compact-array\"><a href=\"#compact-array\" class=\"headerlink\" title=\"_.compact(array)\"></a>_.compact(array)</h2><blockquote>\n<p>介绍：创建一个新数组，包含原数组中所有的非假值元素。例如<code>false</code> , <code>null</code> , <code>0</code> , <code>&quot;&quot;</code> , <code>undefined</code> , 和 <code>NaN</code> 都是被认为是“假值”。<br>🌰</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"literal\">false</span>,<span class=\"number\">2</span>,<span class=\"literal\">null</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"literal\">NaN</span>,<span class=\"number\">5</span>,<span class=\"literal\">undefined</span>]</span><br><span class=\"line\">_.compact(arr) <span class=\"comment\">// 返回 [1，2，3，4，5]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compact</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> resIndex = <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> array) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value) &#123;</span><br><span class=\"line\">      result[resIndex++] = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"为什么使用-for-of\"><a href=\"#为什么使用-for-of\" class=\"headerlink\" title=\"为什么使用 for  of\"></a>为什么使用 <code>for  of</code></h4><blockquote>\n<p>遍历除了 <code>for  of</code> 还有 <code>for</code>、<code>for in</code>，使用 <code>for</code>的话，不够间接，下面讨论为什么不使用<code>for in</code></p>\n</blockquote>\n<h5 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for in\"></a>for in</h5><p>for in是以<strong>任意顺序</strong>遍历一个对象的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\">可枚举属性</a>。  </p>\n<p>在数组中，数组的索引是可枚举属性，可以用 for…in 来遍历数组的索引，数组中的稀疏部分不存在索引，可以避免用 for 循环造成无效遍历的弊端。</p>\n<p>但是，for…in 的遍历顺序依赖于执行环境，不同执行环境的实现方式可能会不一样。单凭这一点，就断然不能在数组遍历中使用 for…in，大多数情况下，顺序对于数组的遍历都相当重要。</p>\n<p>另外，先看个🌰</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">arr.foo = <span class=\"string\">&#x27;foo&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">in</span> arr) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(index)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，你期望输出的是 0,1,2，但是最后输出的可能是 0,1,2,foo （for…in 不能保证顺序）。因为 foo 也是可枚举属性，在 for..in 会被遍历出来。</p>\n<h5 id=\"for-of\"><a href=\"#for-of\" class=\"headerlink\" title=\"for of\"></a>for of</h5><p><code>for...of</code> 循环内部调用的就是数组原型链上的 <code>Symbol.iterator</code> 方法。</p>\n<p><code>Symbol.iterator</code> 在调用的时候会返回一个遍历器对象，这个遍历器对象中包含 <code>next</code> 方法，<code>for...of</code> 在每次循环的时候都会调用 <code>next</code> 方法来获取值，直到 <code>next</code> 返回的对象中的 <code>done</code>属性值为 <code>true</code> 时停止。</p>\n<p>手动调用来模拟遍历的过程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> iterator = a[<span class=\"built_in\">Symbol</span>.iterator]()</span><br><span class=\"line\">iterator.next() <span class=\"comment\">// &#123;value: 1, done: false&#125;</span></span><br><span class=\"line\">iterator.next() <span class=\"comment\">// &#123;value: 2, done: false&#125;</span></span><br><span class=\"line\">iterator.next() <span class=\"comment\">// &#123;value: 3, done: false&#125;</span></span><br><span class=\"line\">iterator.next() <span class=\"comment\">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>因此在不改写 <code>Symbol.iterator</code> 的情况下, 使用 <code>for...of</code> 来遍历数组是安全的，因为这个方法(<code>Symbol.iterator</code>)是数组的原生方法。</p>\n"},{"title":"(转载) lodash源码 eq","date":"2021-12-26T16:00:00.000Z","_content":"### _.eq(value, other)\n> 介绍：执行 `SameValueZero` 比较两者的值，来确定它们是否相等。\n#### 🌰\n```javascript\nvar object = { 'a': 1 };\nvar other = { 'a': 1 };\n \n_.eq(object, object);\n// => true\n \n_.eq(object, other);\n// => false\n \n_.eq('a', 'a');\n// => true\n \n_.eq('a', Object('a'));\n// => false\n \n_.eq(NaN, NaN);\n// => true\n```\n#### 规则比较\n> 前排提示：以下提到的规则，`SameValueNonNumber` 是基本，`Strict Equality Comparison` 、`SameValue` 和 `SameValueZero` 只是在对待 `+0`、`-0` 和 `NaN` 上有区别。\n##### 基础规则：SameValueNonNumber\n\n这个规范规定比较的值 x 和 y 都不为 Number 类型，照抄规范如下：\n1. `x` 的类型不为 `Number` 类型\n1. `y` 的类型与 `x` 的类型一致\n1. 如果 `x` 的类型为 `Undefined` ，返回 `true`\n1. 如果 `x` 的类型为 `Null` ，返回 `true`\n1. 如果 `x` 的类型为 `String`，并且 `x` 和 `y` 的长度及编码相同，返回 `true`，否则返回 `false`\n1. 如果 `x` 的类型为 `Boolean` ，并且 `x` 和 `y` 同为 `true` 或同为 `false` ，返回 `true`，否则返回 `false`\n1. 如果 `x`的类型为 `Symbol` ，并且 `x` 和 `y` 具有相同的 `Symbol` 值，返回 `true`，否则返回 `false`\n1. 如果 `x` 和 `y` 指向同一个对象，返回 `true`， 否则返回 `false`\n##### Strict Equality Comparison\njs 中的全等（`===`）便是遵循这个规范，照搬规范如下：\n1. 如果 `x` 和 `y` 的类型不同，返回 `false`\n1. 如果 `x` 的为 `Number` 类型：\n    - a. 如果 `x` 为 `NaN` ，返回 `false`\n    - b. 如果 `y` 为 `NaN` ，返回 `false`\n    - c. 如果 `x` 和 `y` 的数值一致，返回 `true`\n    - d. 如果 `x` 为 `+0` 并且 `y` 为 `-0` ，返回 `true`\n    - e. 如果 `x` 为 `-0` 并且 `y` 为 `+0` ，返回 `true`\n    - f. 返回 `false`\n1. 按照 `SameValueNonNumber` 的结果返回\n##### SameValue\n1. 如果 `x` 和 `y` 的类型不同，返回 `false`\n1. 如果 `x` 的为 `Number` 类型：\n    - a. 如果 `x` 为 `NaN` 并且 `y` 为 `NaN` ，返回 `true`\n    - b. 如果 `x` 为 `+0` 并且 `y` 为 `-0` ，返回 `false`\n    - c. 如果 `x` 为 `-0` 并且 `y` 为 `+0` ，返回 `false`\n    - d. 如果 `x` 和 `y` 的数值一致，返回 `true`\n    - e. 返回 `false`\n1. 按照 `SameValueNonNumber` 的结果返回\n##### SameValueZero\n这个是 `_.eq` 遵循的规范，如下：\n1. 如果 `x` 和 `y` 的类型不同，返回 `false`\n1. 如果 `x` 的为 `Number` 类型：\n    - a. 如果 `x` 为 `NaN` 并且 `y` 为 `NaN` ，返回 `true`\n    - b. 如果 `x` 为 `+0` 并且 `y` 为 `-0` ，返回 `true`\n    - c. 如果 `x` 为 `-0` 并且 `y` 为 `+0` ，返回 `true`\n    - d. 如果 `x` 和 `y` 的数值一致，返回 `true`\n    - e. 返回 `false`\n1. 按照 `SameValueNonNumber` 的结果返回\n\n#### 源码\n```javascript\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other)\n}\n```\n`Strict Equality Comparison` 和 `SameValueZero` 只在对待 `NaN` 上有区别。\n所以在此基础上使用`value !== value && other !== other` 修改 `NaN` 的处理即可\n\n#### 可以用 Object.is() 替代吗？\n**不能**，`Object.is` 同样是比较两个值是否一样，遵循是的 `SameValue` 规范，`Object.is(+0, -0)` 返回的是 `false`， 所以不能\n\n可以用来判断 `NaN`, `Object.is(NaN, NaN)` 返回的是 `true` ，所以 `eq` 同样可以改成：\n```javascript\nfunction eq(value, other) {\n  return value === other || Object.is(value, other)\n}\n```\n\n#### 可以用 isNaN() 吗？\n**不能**，如果传入的参数不为 Number 类型，会尝试转换成 Number 类型之后再做是否为 NaN 的判断。所以类似 isNaN('notNaN') 返回的也是 true ，因为字符串 notNaN 会先被转换成 NaN 再做判断，这不是我们想要的结果。\n\n#### 可以用 Number.isNaN() 吗？\n为了修复 `isNaN` 的缺陷，`es6` 在 `Number` 对象上扩展了 `isNaN` 方法，只有是 `NaN` 时才会返回 `true`，因此用 Number.isNaN 来判断是安全的。所以 `eq` 同样可以改成以下形式：\n```javascript\nfunction eq(value, other) {\n  return value === other || (Number.isNaN(value) && Number.isNaN(other))\n}\n```","source":"_posts/lodash源码 eq.md","raw":"---\ntitle: (转载) lodash源码 eq\ndate: 2021-12-27\ncategories:\n- 前端\ntags:\n- javascript\n- lodash\n---\n### _.eq(value, other)\n> 介绍：执行 `SameValueZero` 比较两者的值，来确定它们是否相等。\n#### 🌰\n```javascript\nvar object = { 'a': 1 };\nvar other = { 'a': 1 };\n \n_.eq(object, object);\n// => true\n \n_.eq(object, other);\n// => false\n \n_.eq('a', 'a');\n// => true\n \n_.eq('a', Object('a'));\n// => false\n \n_.eq(NaN, NaN);\n// => true\n```\n#### 规则比较\n> 前排提示：以下提到的规则，`SameValueNonNumber` 是基本，`Strict Equality Comparison` 、`SameValue` 和 `SameValueZero` 只是在对待 `+0`、`-0` 和 `NaN` 上有区别。\n##### 基础规则：SameValueNonNumber\n\n这个规范规定比较的值 x 和 y 都不为 Number 类型，照抄规范如下：\n1. `x` 的类型不为 `Number` 类型\n1. `y` 的类型与 `x` 的类型一致\n1. 如果 `x` 的类型为 `Undefined` ，返回 `true`\n1. 如果 `x` 的类型为 `Null` ，返回 `true`\n1. 如果 `x` 的类型为 `String`，并且 `x` 和 `y` 的长度及编码相同，返回 `true`，否则返回 `false`\n1. 如果 `x` 的类型为 `Boolean` ，并且 `x` 和 `y` 同为 `true` 或同为 `false` ，返回 `true`，否则返回 `false`\n1. 如果 `x`的类型为 `Symbol` ，并且 `x` 和 `y` 具有相同的 `Symbol` 值，返回 `true`，否则返回 `false`\n1. 如果 `x` 和 `y` 指向同一个对象，返回 `true`， 否则返回 `false`\n##### Strict Equality Comparison\njs 中的全等（`===`）便是遵循这个规范，照搬规范如下：\n1. 如果 `x` 和 `y` 的类型不同，返回 `false`\n1. 如果 `x` 的为 `Number` 类型：\n    - a. 如果 `x` 为 `NaN` ，返回 `false`\n    - b. 如果 `y` 为 `NaN` ，返回 `false`\n    - c. 如果 `x` 和 `y` 的数值一致，返回 `true`\n    - d. 如果 `x` 为 `+0` 并且 `y` 为 `-0` ，返回 `true`\n    - e. 如果 `x` 为 `-0` 并且 `y` 为 `+0` ，返回 `true`\n    - f. 返回 `false`\n1. 按照 `SameValueNonNumber` 的结果返回\n##### SameValue\n1. 如果 `x` 和 `y` 的类型不同，返回 `false`\n1. 如果 `x` 的为 `Number` 类型：\n    - a. 如果 `x` 为 `NaN` 并且 `y` 为 `NaN` ，返回 `true`\n    - b. 如果 `x` 为 `+0` 并且 `y` 为 `-0` ，返回 `false`\n    - c. 如果 `x` 为 `-0` 并且 `y` 为 `+0` ，返回 `false`\n    - d. 如果 `x` 和 `y` 的数值一致，返回 `true`\n    - e. 返回 `false`\n1. 按照 `SameValueNonNumber` 的结果返回\n##### SameValueZero\n这个是 `_.eq` 遵循的规范，如下：\n1. 如果 `x` 和 `y` 的类型不同，返回 `false`\n1. 如果 `x` 的为 `Number` 类型：\n    - a. 如果 `x` 为 `NaN` 并且 `y` 为 `NaN` ，返回 `true`\n    - b. 如果 `x` 为 `+0` 并且 `y` 为 `-0` ，返回 `true`\n    - c. 如果 `x` 为 `-0` 并且 `y` 为 `+0` ，返回 `true`\n    - d. 如果 `x` 和 `y` 的数值一致，返回 `true`\n    - e. 返回 `false`\n1. 按照 `SameValueNonNumber` 的结果返回\n\n#### 源码\n```javascript\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other)\n}\n```\n`Strict Equality Comparison` 和 `SameValueZero` 只在对待 `NaN` 上有区别。\n所以在此基础上使用`value !== value && other !== other` 修改 `NaN` 的处理即可\n\n#### 可以用 Object.is() 替代吗？\n**不能**，`Object.is` 同样是比较两个值是否一样，遵循是的 `SameValue` 规范，`Object.is(+0, -0)` 返回的是 `false`， 所以不能\n\n可以用来判断 `NaN`, `Object.is(NaN, NaN)` 返回的是 `true` ，所以 `eq` 同样可以改成：\n```javascript\nfunction eq(value, other) {\n  return value === other || Object.is(value, other)\n}\n```\n\n#### 可以用 isNaN() 吗？\n**不能**，如果传入的参数不为 Number 类型，会尝试转换成 Number 类型之后再做是否为 NaN 的判断。所以类似 isNaN('notNaN') 返回的也是 true ，因为字符串 notNaN 会先被转换成 NaN 再做判断，这不是我们想要的结果。\n\n#### 可以用 Number.isNaN() 吗？\n为了修复 `isNaN` 的缺陷，`es6` 在 `Number` 对象上扩展了 `isNaN` 方法，只有是 `NaN` 时才会返回 `true`，因此用 Number.isNaN 来判断是安全的。所以 `eq` 同样可以改成以下形式：\n```javascript\nfunction eq(value, other) {\n  return value === other || (Number.isNaN(value) && Number.isNaN(other))\n}\n```","slug":"lodash源码 eq","published":1,"updated":"2022-01-29T13:58:16.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p6r0008rwh9enekgb3l","content":"<h3 id=\"eq-value-other\"><a href=\"#eq-value-other\" class=\"headerlink\" title=\"_.eq(value, other)\"></a>_.eq(value, other)</h3><blockquote>\n<p>介绍：执行 <code>SameValueZero</code> 比较两者的值，来确定它们是否相等。</p>\n</blockquote>\n<h4 id=\"🌰\"><a href=\"#🌰\" class=\"headerlink\" title=\"🌰\"></a>🌰</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> object = &#123; <span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> other = &#123; <span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">_.eq(object, object);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.eq(object, other);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; false</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.eq(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.eq(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"built_in\">Object</span>(<span class=\"string\">&#x27;a&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// =&gt; false</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.eq(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"规则比较\"><a href=\"#规则比较\" class=\"headerlink\" title=\"规则比较\"></a>规则比较</h4><blockquote>\n<p>前排提示：以下提到的规则，<code>SameValueNonNumber</code> 是基本，<code>Strict Equality Comparison</code> 、<code>SameValue</code> 和 <code>SameValueZero</code> 只是在对待 <code>+0</code>、<code>-0</code> 和 <code>NaN</code> 上有区别。</p>\n</blockquote>\n<h5 id=\"基础规则：SameValueNonNumber\"><a href=\"#基础规则：SameValueNonNumber\" class=\"headerlink\" title=\"基础规则：SameValueNonNumber\"></a>基础规则：SameValueNonNumber</h5><p>这个规范规定比较的值 x 和 y 都不为 Number 类型，照抄规范如下：</p>\n<ol>\n<li><code>x</code> 的类型不为 <code>Number</code> 类型</li>\n<li><code>y</code> 的类型与 <code>x</code> 的类型一致</li>\n<li>如果 <code>x</code> 的类型为 <code>Undefined</code> ，返回 <code>true</code></li>\n<li>如果 <code>x</code> 的类型为 <code>Null</code> ，返回 <code>true</code></li>\n<li>如果 <code>x</code> 的类型为 <code>String</code>，并且 <code>x</code> 和 <code>y</code> 的长度及编码相同，返回 <code>true</code>，否则返回 <code>false</code></li>\n<li>如果 <code>x</code> 的类型为 <code>Boolean</code> ，并且 <code>x</code> 和 <code>y</code> 同为 <code>true</code> 或同为 <code>false</code> ，返回 <code>true</code>，否则返回 <code>false</code></li>\n<li>如果 <code>x</code>的类型为 <code>Symbol</code> ，并且 <code>x</code> 和 <code>y</code> 具有相同的 <code>Symbol</code> 值，返回 <code>true</code>，否则返回 <code>false</code></li>\n<li>如果 <code>x</code> 和 <code>y</code> 指向同一个对象，返回 <code>true</code>， 否则返回 <code>false</code><h5 id=\"Strict-Equality-Comparison\"><a href=\"#Strict-Equality-Comparison\" class=\"headerlink\" title=\"Strict Equality Comparison\"></a>Strict Equality Comparison</h5>js 中的全等（<code>===</code>）便是遵循这个规范，照搬规范如下：</li>\n<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>\n<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>\n<li>a. 如果 <code>x</code> 为 <code>NaN</code> ，返回 <code>false</code></li>\n<li>b. 如果 <code>y</code> 为 <code>NaN</code> ，返回 <code>false</code></li>\n<li>c. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>\n<li>d. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>true</code></li>\n<li>e. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>true</code></li>\n<li>f. 返回 <code>false</code></li>\n</ul>\n</li>\n<li>按照 <code>SameValueNonNumber</code> 的结果返回<h5 id=\"SameValue\"><a href=\"#SameValue\" class=\"headerlink\" title=\"SameValue\"></a>SameValue</h5></li>\n<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>\n<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>\n<li>a. 如果 <code>x</code> 为 <code>NaN</code> 并且 <code>y</code> 为 <code>NaN</code> ，返回 <code>true</code></li>\n<li>b. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>false</code></li>\n<li>c. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>false</code></li>\n<li>d. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>\n<li>e. 返回 <code>false</code></li>\n</ul>\n</li>\n<li>按照 <code>SameValueNonNumber</code> 的结果返回<h5 id=\"SameValueZero\"><a href=\"#SameValueZero\" class=\"headerlink\" title=\"SameValueZero\"></a>SameValueZero</h5>这个是 <code>_.eq</code> 遵循的规范，如下：</li>\n<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>\n<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>\n<li>a. 如果 <code>x</code> 为 <code>NaN</code> 并且 <code>y</code> 为 <code>NaN</code> ，返回 <code>true</code></li>\n<li>b. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>true</code></li>\n<li>c. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>true</code></li>\n<li>d. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>\n<li>e. 返回 <code>false</code></li>\n</ul>\n</li>\n<li>按照 <code>SameValueNonNumber</code> 的结果返回</li>\n</ol>\n<h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eq</span>(<span class=\"params\">value, other</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value === other || (value !== value &amp;&amp; other !== other)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Strict Equality Comparison</code> 和 <code>SameValueZero</code> 只在对待 <code>NaN</code> 上有区别。<br>所以在此基础上使用<code>value !== value &amp;&amp; other !== other</code> 修改 <code>NaN</code> 的处理即可</p>\n<h4 id=\"可以用-Object-is-替代吗？\"><a href=\"#可以用-Object-is-替代吗？\" class=\"headerlink\" title=\"可以用 Object.is() 替代吗？\"></a>可以用 Object.is() 替代吗？</h4><p><strong>不能</strong>，<code>Object.is</code> 同样是比较两个值是否一样，遵循是的 <code>SameValue</code> 规范，<code>Object.is(+0, -0)</code> 返回的是 <code>false</code>， 所以不能</p>\n<p>可以用来判断 <code>NaN</code>, <code>Object.is(NaN, NaN)</code> 返回的是 <code>true</code> ，所以 <code>eq</code> 同样可以改成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eq</span>(<span class=\"params\">value, other</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value === other || <span class=\"built_in\">Object</span>.is(value, other)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可以用-isNaN-吗？\"><a href=\"#可以用-isNaN-吗？\" class=\"headerlink\" title=\"可以用 isNaN() 吗？\"></a>可以用 isNaN() 吗？</h4><p><strong>不能</strong>，如果传入的参数不为 Number 类型，会尝试转换成 Number 类型之后再做是否为 NaN 的判断。所以类似 isNaN(‘notNaN’) 返回的也是 true ，因为字符串 notNaN 会先被转换成 NaN 再做判断，这不是我们想要的结果。</p>\n<h4 id=\"可以用-Number-isNaN-吗？\"><a href=\"#可以用-Number-isNaN-吗？\" class=\"headerlink\" title=\"可以用 Number.isNaN() 吗？\"></a>可以用 Number.isNaN() 吗？</h4><p>为了修复 <code>isNaN</code> 的缺陷，<code>es6</code> 在 <code>Number</code> 对象上扩展了 <code>isNaN</code> 方法，只有是 <code>NaN</code> 时才会返回 <code>true</code>，因此用 Number.isNaN 来判断是安全的。所以 <code>eq</code> 同样可以改成以下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eq</span>(<span class=\"params\">value, other</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value === other || (<span class=\"built_in\">Number</span>.isNaN(value) &amp;&amp; <span class=\"built_in\">Number</span>.isNaN(other))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h3 id=\"eq-value-other\"><a href=\"#eq-value-other\" class=\"headerlink\" title=\"_.eq(value, other)\"></a>_.eq(value, other)</h3><blockquote>\n<p>介绍：执行 <code>SameValueZero</code> 比较两者的值，来确定它们是否相等。</p>\n</blockquote>\n<h4 id=\"🌰\"><a href=\"#🌰\" class=\"headerlink\" title=\"🌰\"></a>🌰</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> object = &#123; <span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> other = &#123; <span class=\"string\">&#x27;a&#x27;</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">_.eq(object, object);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.eq(object, other);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; false</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.eq(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;a&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.eq(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"built_in\">Object</span>(<span class=\"string\">&#x27;a&#x27;</span>));</span><br><span class=\"line\"><span class=\"comment\">// =&gt; false</span></span><br><span class=\"line\"> </span><br><span class=\"line\">_.eq(<span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>);</span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"规则比较\"><a href=\"#规则比较\" class=\"headerlink\" title=\"规则比较\"></a>规则比较</h4><blockquote>\n<p>前排提示：以下提到的规则，<code>SameValueNonNumber</code> 是基本，<code>Strict Equality Comparison</code> 、<code>SameValue</code> 和 <code>SameValueZero</code> 只是在对待 <code>+0</code>、<code>-0</code> 和 <code>NaN</code> 上有区别。</p>\n</blockquote>\n<h5 id=\"基础规则：SameValueNonNumber\"><a href=\"#基础规则：SameValueNonNumber\" class=\"headerlink\" title=\"基础规则：SameValueNonNumber\"></a>基础规则：SameValueNonNumber</h5><p>这个规范规定比较的值 x 和 y 都不为 Number 类型，照抄规范如下：</p>\n<ol>\n<li><code>x</code> 的类型不为 <code>Number</code> 类型</li>\n<li><code>y</code> 的类型与 <code>x</code> 的类型一致</li>\n<li>如果 <code>x</code> 的类型为 <code>Undefined</code> ，返回 <code>true</code></li>\n<li>如果 <code>x</code> 的类型为 <code>Null</code> ，返回 <code>true</code></li>\n<li>如果 <code>x</code> 的类型为 <code>String</code>，并且 <code>x</code> 和 <code>y</code> 的长度及编码相同，返回 <code>true</code>，否则返回 <code>false</code></li>\n<li>如果 <code>x</code> 的类型为 <code>Boolean</code> ，并且 <code>x</code> 和 <code>y</code> 同为 <code>true</code> 或同为 <code>false</code> ，返回 <code>true</code>，否则返回 <code>false</code></li>\n<li>如果 <code>x</code>的类型为 <code>Symbol</code> ，并且 <code>x</code> 和 <code>y</code> 具有相同的 <code>Symbol</code> 值，返回 <code>true</code>，否则返回 <code>false</code></li>\n<li>如果 <code>x</code> 和 <code>y</code> 指向同一个对象，返回 <code>true</code>， 否则返回 <code>false</code><h5 id=\"Strict-Equality-Comparison\"><a href=\"#Strict-Equality-Comparison\" class=\"headerlink\" title=\"Strict Equality Comparison\"></a>Strict Equality Comparison</h5>js 中的全等（<code>===</code>）便是遵循这个规范，照搬规范如下：</li>\n<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>\n<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>\n<li>a. 如果 <code>x</code> 为 <code>NaN</code> ，返回 <code>false</code></li>\n<li>b. 如果 <code>y</code> 为 <code>NaN</code> ，返回 <code>false</code></li>\n<li>c. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>\n<li>d. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>true</code></li>\n<li>e. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>true</code></li>\n<li>f. 返回 <code>false</code></li>\n</ul>\n</li>\n<li>按照 <code>SameValueNonNumber</code> 的结果返回<h5 id=\"SameValue\"><a href=\"#SameValue\" class=\"headerlink\" title=\"SameValue\"></a>SameValue</h5></li>\n<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>\n<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>\n<li>a. 如果 <code>x</code> 为 <code>NaN</code> 并且 <code>y</code> 为 <code>NaN</code> ，返回 <code>true</code></li>\n<li>b. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>false</code></li>\n<li>c. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>false</code></li>\n<li>d. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>\n<li>e. 返回 <code>false</code></li>\n</ul>\n</li>\n<li>按照 <code>SameValueNonNumber</code> 的结果返回<h5 id=\"SameValueZero\"><a href=\"#SameValueZero\" class=\"headerlink\" title=\"SameValueZero\"></a>SameValueZero</h5>这个是 <code>_.eq</code> 遵循的规范，如下：</li>\n<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>\n<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>\n<li>a. 如果 <code>x</code> 为 <code>NaN</code> 并且 <code>y</code> 为 <code>NaN</code> ，返回 <code>true</code></li>\n<li>b. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>true</code></li>\n<li>c. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>true</code></li>\n<li>d. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>\n<li>e. 返回 <code>false</code></li>\n</ul>\n</li>\n<li>按照 <code>SameValueNonNumber</code> 的结果返回</li>\n</ol>\n<h4 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eq</span>(<span class=\"params\">value, other</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value === other || (value !== value &amp;&amp; other !== other)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Strict Equality Comparison</code> 和 <code>SameValueZero</code> 只在对待 <code>NaN</code> 上有区别。<br>所以在此基础上使用<code>value !== value &amp;&amp; other !== other</code> 修改 <code>NaN</code> 的处理即可</p>\n<h4 id=\"可以用-Object-is-替代吗？\"><a href=\"#可以用-Object-is-替代吗？\" class=\"headerlink\" title=\"可以用 Object.is() 替代吗？\"></a>可以用 Object.is() 替代吗？</h4><p><strong>不能</strong>，<code>Object.is</code> 同样是比较两个值是否一样，遵循是的 <code>SameValue</code> 规范，<code>Object.is(+0, -0)</code> 返回的是 <code>false</code>， 所以不能</p>\n<p>可以用来判断 <code>NaN</code>, <code>Object.is(NaN, NaN)</code> 返回的是 <code>true</code> ，所以 <code>eq</code> 同样可以改成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eq</span>(<span class=\"params\">value, other</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value === other || <span class=\"built_in\">Object</span>.is(value, other)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可以用-isNaN-吗？\"><a href=\"#可以用-isNaN-吗？\" class=\"headerlink\" title=\"可以用 isNaN() 吗？\"></a>可以用 isNaN() 吗？</h4><p><strong>不能</strong>，如果传入的参数不为 Number 类型，会尝试转换成 Number 类型之后再做是否为 NaN 的判断。所以类似 isNaN(‘notNaN’) 返回的也是 true ，因为字符串 notNaN 会先被转换成 NaN 再做判断，这不是我们想要的结果。</p>\n<h4 id=\"可以用-Number-isNaN-吗？\"><a href=\"#可以用-Number-isNaN-吗？\" class=\"headerlink\" title=\"可以用 Number.isNaN() 吗？\"></a>可以用 Number.isNaN() 吗？</h4><p>为了修复 <code>isNaN</code> 的缺陷，<code>es6</code> 在 <code>Number</code> 对象上扩展了 <code>isNaN</code> 方法，只有是 <code>NaN</code> 时才会返回 <code>true</code>，因此用 Number.isNaN 来判断是安全的。所以 <code>eq</code> 同样可以改成以下形式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eq</span>(<span class=\"params\">value, other</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value === other || (<span class=\"built_in\">Number</span>.isNaN(value) &amp;&amp; <span class=\"built_in\">Number</span>.isNaN(other))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"(转载) lodash源码 slice","date":"2021-12-14T16:00:00.000Z","_content":"##  _.slice(array, [start=0], [end=array.length])\n> **介绍:**   裁剪数组`array`，从`start` 位置开始到`end`结束，但不包括`end` 本身的位置。**这个方法用于代替Array#slice 来确保数组正确返回**  \n\n**为什么需要替代:**  \nlodash 的 slice 会将数组当成密集数组对待，原生的 slice 会将数组当成稀疏数组对待。\n\n#### 密集数组VS稀疏数组\n\n> 稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。\n\n如果数组是稀疏的，那么这个数组中至少有一个以上的位置不存在元素（undefined算元素）。  \n🌰\n```javascript\n// sparse 的 length 为10，但是 sparse 数组中没有元素，是稀疏数组\nvar sparse = new Array(10) \n// dense 每个位置都是有元素的，虽然每个元素都为undefined，为密集数组\nvar dense = new Array(10).fill(undefined)\n```\n#### 源码总览\n```javascript\nfunction slice(array, start, end) {\n  // array == null, 非 === ,包含undefined的判断 undefined == null true\n  let length = array == null ? 0 : array.length\n  // 不传参的情况\n  if (!length) {\n    return []\n  }\n  // 此部分判断是否带start或end的参\n  // 不带的时候赋予初始值\n  start = start == null ? 0 : start\n  end = end === undefined ? length : end\n  // start 为负数的情况\n  if (start < 0) {\n    // 如果负数取反后比数组的长度还要大，即超出了数组的范围，则取值为0\n    start = -start > length ? 0 : (length + start)\n  }\n  // end最大取数组长度\n  end = end > length ? length : end\n  // end 小于0\n  if (end < 0) {\n    end += length\n  }\n  // 新数组的长度\n  length = start > end ? 0 : ((end - start) >>> 0)\n  start >>>= 0\n\n  let index = -1\n  const result = new Array(length)\n  // 截取并返回新数组\n  while (++index < length) {\n    result[index] = array[index + start]\n  }\n  return result\n}\n```\n**start**  \n> - 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取。\n> - 如果省略，则从索引0开始\n\n**end**\n> - 如果该参数为负数，则它表示在原数组中的倒数第几个元素结束制取。\n> - 如果end被省略，则slice会一直提取到原数组的末尾。\n> - 如果end大于数组长度，slice也会一直提取到原数组末尾。\n\n**关于 `start >>>= 0`**  \n- 使用 `>>>` 来确保 `start` 参数为整数或0。  \n- 因为 `lodash` 的 `slice` 除了可以处理数组外，也可以处理类数组( `arguments` 对象和 `DOM` 方法的返回结果)，因此第一个参数 `array` 可能为一个对象， `length` 属性不一定为数字。\n- 更多知识请参考“移位运算符”","source":"_posts/lodash源码 slice.md","raw":"---\ntitle: (转载) lodash源码 slice\ndate: 2021-12-15\ncategories:\n- 前端\ntags:\n- javascript\n- lodash\n---\n##  _.slice(array, [start=0], [end=array.length])\n> **介绍:**   裁剪数组`array`，从`start` 位置开始到`end`结束，但不包括`end` 本身的位置。**这个方法用于代替Array#slice 来确保数组正确返回**  \n\n**为什么需要替代:**  \nlodash 的 slice 会将数组当成密集数组对待，原生的 slice 会将数组当成稀疏数组对待。\n\n#### 密集数组VS稀疏数组\n\n> 稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。\n\n如果数组是稀疏的，那么这个数组中至少有一个以上的位置不存在元素（undefined算元素）。  \n🌰\n```javascript\n// sparse 的 length 为10，但是 sparse 数组中没有元素，是稀疏数组\nvar sparse = new Array(10) \n// dense 每个位置都是有元素的，虽然每个元素都为undefined，为密集数组\nvar dense = new Array(10).fill(undefined)\n```\n#### 源码总览\n```javascript\nfunction slice(array, start, end) {\n  // array == null, 非 === ,包含undefined的判断 undefined == null true\n  let length = array == null ? 0 : array.length\n  // 不传参的情况\n  if (!length) {\n    return []\n  }\n  // 此部分判断是否带start或end的参\n  // 不带的时候赋予初始值\n  start = start == null ? 0 : start\n  end = end === undefined ? length : end\n  // start 为负数的情况\n  if (start < 0) {\n    // 如果负数取反后比数组的长度还要大，即超出了数组的范围，则取值为0\n    start = -start > length ? 0 : (length + start)\n  }\n  // end最大取数组长度\n  end = end > length ? length : end\n  // end 小于0\n  if (end < 0) {\n    end += length\n  }\n  // 新数组的长度\n  length = start > end ? 0 : ((end - start) >>> 0)\n  start >>>= 0\n\n  let index = -1\n  const result = new Array(length)\n  // 截取并返回新数组\n  while (++index < length) {\n    result[index] = array[index + start]\n  }\n  return result\n}\n```\n**start**  \n> - 如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取。\n> - 如果省略，则从索引0开始\n\n**end**\n> - 如果该参数为负数，则它表示在原数组中的倒数第几个元素结束制取。\n> - 如果end被省略，则slice会一直提取到原数组的末尾。\n> - 如果end大于数组长度，slice也会一直提取到原数组末尾。\n\n**关于 `start >>>= 0`**  \n- 使用 `>>>` 来确保 `start` 参数为整数或0。  \n- 因为 `lodash` 的 `slice` 除了可以处理数组外，也可以处理类数组( `arguments` 对象和 `DOM` 方法的返回结果)，因此第一个参数 `array` 可能为一个对象， `length` 属性不一定为数字。\n- 更多知识请参考“移位运算符”","slug":"lodash源码 slice","published":1,"updated":"2022-01-29T13:58:19.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p6t000brwh9ft3cd163","content":"<h2 id=\"slice-array-start-0-end-array-length\"><a href=\"#slice-array-start-0-end-array-length\" class=\"headerlink\" title=\"_.slice(array, [start=0], [end=array.length])\"></a>_.slice(array, [start=0], [end=array.length])</h2><blockquote>\n<p><strong>介绍:</strong>   裁剪数组<code>array</code>，从<code>start</code> 位置开始到<code>end</code>结束，但不包括<code>end</code> 本身的位置。<strong>这个方法用于代替Array#slice 来确保数组正确返回</strong>  </p>\n</blockquote>\n<p><strong>为什么需要替代:</strong><br>lodash 的 slice 会将数组当成密集数组对待，原生的 slice 会将数组当成稀疏数组对待。</p>\n<h4 id=\"密集数组VS稀疏数组\"><a href=\"#密集数组VS稀疏数组\" class=\"headerlink\" title=\"密集数组VS稀疏数组\"></a>密集数组VS稀疏数组</h4><blockquote>\n<p>稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。</p>\n</blockquote>\n<p>如果数组是稀疏的，那么这个数组中至少有一个以上的位置不存在元素（undefined算元素）。<br>🌰</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sparse 的 length 为10，但是 sparse 数组中没有元素，是稀疏数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sparse = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10</span>) </span><br><span class=\"line\"><span class=\"comment\">// dense 每个位置都是有元素的，虽然每个元素都为undefined，为密集数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dense = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10</span>).fill(<span class=\"literal\">undefined</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"源码总览\"><a href=\"#源码总览\" class=\"headerlink\" title=\"源码总览\"></a>源码总览</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">slice</span>(<span class=\"params\">array, start, end</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// array == null, 非 === ,包含undefined的判断 undefined == null true</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length</span><br><span class=\"line\">  <span class=\"comment\">// 不传参的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 此部分判断是否带start或end的参</span></span><br><span class=\"line\">  <span class=\"comment\">// 不带的时候赋予初始值</span></span><br><span class=\"line\">  start = start == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : start</span><br><span class=\"line\">  end = end === <span class=\"literal\">undefined</span> ? length : end</span><br><span class=\"line\">  <span class=\"comment\">// start 为负数的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (start &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果负数取反后比数组的长度还要大，即超出了数组的范围，则取值为0</span></span><br><span class=\"line\">    start = -start &gt; length ? <span class=\"number\">0</span> : (length + start)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// end最大取数组长度</span></span><br><span class=\"line\">  end = end &gt; length ? length : end</span><br><span class=\"line\">  <span class=\"comment\">// end 小于0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (end &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    end += length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 新数组的长度</span></span><br><span class=\"line\">  length = start &gt; end ? <span class=\"number\">0</span> : ((end - start) &gt;&gt;&gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">  start &gt;&gt;&gt;= <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = -<span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(length)</span><br><span class=\"line\">  <span class=\"comment\">// 截取并返回新数组</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (++index &lt; length) &#123;</span><br><span class=\"line\">    result[index] = array[index + start]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>start</strong>  </p>\n<blockquote>\n<ul>\n<li>如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取。</li>\n<li>如果省略，则从索引0开始</li>\n</ul>\n</blockquote>\n<p><strong>end</strong></p>\n<blockquote>\n<ul>\n<li>如果该参数为负数，则它表示在原数组中的倒数第几个元素结束制取。</li>\n<li>如果end被省略，则slice会一直提取到原数组的末尾。</li>\n<li>如果end大于数组长度，slice也会一直提取到原数组末尾。</li>\n</ul>\n</blockquote>\n<p><strong>关于 <code>start &gt;&gt;&gt;= 0</code></strong>  </p>\n<ul>\n<li>使用 <code>&gt;&gt;&gt;</code> 来确保 <code>start</code> 参数为整数或0。  </li>\n<li>因为 <code>lodash</code> 的 <code>slice</code> 除了可以处理数组外，也可以处理类数组( <code>arguments</code> 对象和 <code>DOM</code> 方法的返回结果)，因此第一个参数 <code>array</code> 可能为一个对象， <code>length</code> 属性不一定为数字。</li>\n<li>更多知识请参考“移位运算符”</li>\n</ul>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h2 id=\"slice-array-start-0-end-array-length\"><a href=\"#slice-array-start-0-end-array-length\" class=\"headerlink\" title=\"_.slice(array, [start=0], [end=array.length])\"></a>_.slice(array, [start=0], [end=array.length])</h2><blockquote>\n<p><strong>介绍:</strong>   裁剪数组<code>array</code>，从<code>start</code> 位置开始到<code>end</code>结束，但不包括<code>end</code> 本身的位置。<strong>这个方法用于代替Array#slice 来确保数组正确返回</strong>  </p>\n</blockquote>\n<p><strong>为什么需要替代:</strong><br>lodash 的 slice 会将数组当成密集数组对待，原生的 slice 会将数组当成稀疏数组对待。</p>\n<h4 id=\"密集数组VS稀疏数组\"><a href=\"#密集数组VS稀疏数组\" class=\"headerlink\" title=\"密集数组VS稀疏数组\"></a>密集数组VS稀疏数组</h4><blockquote>\n<p>稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。</p>\n</blockquote>\n<p>如果数组是稀疏的，那么这个数组中至少有一个以上的位置不存在元素（undefined算元素）。<br>🌰</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sparse 的 length 为10，但是 sparse 数组中没有元素，是稀疏数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sparse = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10</span>) </span><br><span class=\"line\"><span class=\"comment\">// dense 每个位置都是有元素的，虽然每个元素都为undefined，为密集数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> dense = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10</span>).fill(<span class=\"literal\">undefined</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"源码总览\"><a href=\"#源码总览\" class=\"headerlink\" title=\"源码总览\"></a>源码总览</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">slice</span>(<span class=\"params\">array, start, end</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// array == null, 非 === ,包含undefined的判断 undefined == null true</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> length = array == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : array.length</span><br><span class=\"line\">  <span class=\"comment\">// 不传参的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 此部分判断是否带start或end的参</span></span><br><span class=\"line\">  <span class=\"comment\">// 不带的时候赋予初始值</span></span><br><span class=\"line\">  start = start == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : start</span><br><span class=\"line\">  end = end === <span class=\"literal\">undefined</span> ? length : end</span><br><span class=\"line\">  <span class=\"comment\">// start 为负数的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (start &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果负数取反后比数组的长度还要大，即超出了数组的范围，则取值为0</span></span><br><span class=\"line\">    start = -start &gt; length ? <span class=\"number\">0</span> : (length + start)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// end最大取数组长度</span></span><br><span class=\"line\">  end = end &gt; length ? length : end</span><br><span class=\"line\">  <span class=\"comment\">// end 小于0</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (end &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    end += length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 新数组的长度</span></span><br><span class=\"line\">  length = start &gt; end ? <span class=\"number\">0</span> : ((end - start) &gt;&gt;&gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">  start &gt;&gt;&gt;= <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = -<span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(length)</span><br><span class=\"line\">  <span class=\"comment\">// 截取并返回新数组</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (++index &lt; length) &#123;</span><br><span class=\"line\">    result[index] = array[index + start]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>start</strong>  </p>\n<blockquote>\n<ul>\n<li>如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取。</li>\n<li>如果省略，则从索引0开始</li>\n</ul>\n</blockquote>\n<p><strong>end</strong></p>\n<blockquote>\n<ul>\n<li>如果该参数为负数，则它表示在原数组中的倒数第几个元素结束制取。</li>\n<li>如果end被省略，则slice会一直提取到原数组的末尾。</li>\n<li>如果end大于数组长度，slice也会一直提取到原数组末尾。</li>\n</ul>\n</blockquote>\n<p><strong>关于 <code>start &gt;&gt;&gt;= 0</code></strong>  </p>\n<ul>\n<li>使用 <code>&gt;&gt;&gt;</code> 来确保 <code>start</code> 参数为整数或0。  </li>\n<li>因为 <code>lodash</code> 的 <code>slice</code> 除了可以处理数组外，也可以处理类数组( <code>arguments</code> 对象和 <code>DOM</code> 方法的返回结果)，因此第一个参数 <code>array</code> 可能为一个对象， <code>length</code> 属性不一定为数字。</li>\n<li>更多知识请参考“移位运算符”</li>\n</ul>\n"},{"title":"(转载) lodash源码 内部 Hash缓存","date":"2021-12-28T16:00:00.000Z","_content":"## 作用与用法\n\n`Hash` 顾名思义，就是要有一个离散的序列，根据 `key` 来储取数据。而在 javascript 中，最适合的无疑是对象了。\n\n`Hash` 在 lodash 的 `.internal` 文件夹中，作为内部文件来使用。lodash 会根据不同的数据类型选择不同的缓存方式，`Hash` 便是其中的一种方式，这种方式只能缓存 `key` 的类型符合对象键要求的数据。\n\n `Hash` 只接收一个二维数组作为参数，调用方式如下：\n\n```javascript\nnew Hash([['test1', 1],['test2',2],['test3',3]])\n```\n\n其中子项中的第一项会作为 `key` ，第二项是需要缓存的值。\n\n`Hash` 实例化的结果如下：\n\n```javascript\n{\n  size: 3,\n  __data__: {\n    test1: 1,\n    test2: 2,\n    test3: 3\n  }\n}\n```\n\n缓存的数量储存在 `__data__` 的对象中。\n\n## Hash与Map\n\n后面将会讲到，除了使用 `Hash` 方式缓存数据外，还会用到 `Map`，lodash 在设计 `Hash` 的数据管理接口时，也与 `Map` 的接口一致，但是不会包含 `Map` 的遍历方法。\n\n先来看看这些接口都有那些：\n\n![](/images/hash.png)\n\n## 源码\n\n```javascript\nconst HASH_UNDEFINED = '__lodash_hash_undefined__'\n\nclass Hash {\n  constructor(entries) {\n    let index = -1\n    const length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      const entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n  clear() {\n    this.__data__ = Object.create(null)\n    this.size = 0\n  }\n  delete(key) {\n    const result = this.has(key) && delete this.__data__[key]\n    this.size -= result ? 1 : 0\n    return result\n  }\n  get(key) {\n    const data = this.__data__\n    const result = data[key]\n    return result === HASH_UNDEFINED ? undefined : result\n  }\n  has(key) {\n    const data = this.__data__\n    return data[key] !== undefined\n  }\n  set(key, value) {\n    const data = this.__data__\n    this.size += this.has(key) ? 0 : 1\n    data[key] = value === undefined ? HASH_UNDEFINED : value\n    return this\n  }\n}\n\nexport default Hash\n```\n\n### constructor\n\n```javascript\nconstructor(entries) {\n    let index = -1\n    const length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      const entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n```\n\n在 `constructor` 中并没有看到初始化 `__data__` 属性和 `size` 属性，这个其实在 `clear` 方法中初始化了，后面会解释。\n\n接着遍历传入的二维数组，调用 `set` 方法，初始化缓存的值。将子项的第一项作为 `key` ，第二项为缓存的值。\n\n### clear\n\n```javascript\nclear() {\n  this.__data__ = Object.create(null)\n  this.size = 0\n}\n```\n\n`clear` 的作用是清空缓存，因此需要将 `size` 重置为 `0`。\n\n将缓存的数据 `__data__` 设置为空对象。\n\n这里并没有用 `this.__data__ = {}` 置空，而是调用了 `Object.create` 方法，并且将 `null` 作为参数。我们都知道， `Object.create` 的第一个参数为创建对象的原型对象，传入 `null` 的时候，返回的就是一个真空对象，即没有原型的对象，因此不会有原型属性的干扰，用来做缓存对象十分适合。\n\n### has\n\n```javascript\nhas(key) {\n  const data = this.__data__\n  return data[key] !== undefined\n}\n```\n\n`has` 用来判断是否已经有缓存数据，如果缓存数据已经存在，则返回 `true` 。\n\n判断也十分简单，只需要判断取出来的值是否为 `undefined` 即可。\n\n这个判断有一个坑，后面会讲到。\n\n### set\n\n```javascript\nset(key, value) {\n  const data = this.__data__\n  this.size += this.has(key) ? 0 : 1\n  data[key] = value === undefined ? HASH_UNDEFINED : value\n  return this\n}\n```\n\n`set` 用来增加或者更新需要缓存的值。`set` 的时候需要同时维护 `size` 和在缓存的值。\n\n首先调用 `has` 方法，判断对应的 `key` 是否已经被缓存过，如果已经缓存过，则 `size` 保持不变，否则 `size` 加 `1` 。\n\n缓存值其实就是设置缓存对象 `this.__data__` 对应 `key` 属性的值。\n\n在 `has` 中说到用 `data[key] !== undefined` 有一个坑，因为要缓存的值也可以是 `undefined` ，如果不做处理，肯定会导致判断错误。\n\nlodash 的处理方式是将 `undefined` 的值转换成 `HASH_UNDEFINED` ，也即一开始便定义的 `__lodash_hash_undefined__` 字符串来储存。\n\n所以在缓存中，是用字符串 `__lodash_hash_undefined__` 来替代 `undefined` 的。\n\n`set` 在最后还将实例 `this` 返回，以支持链式操作。\n\n### get\n\n```javascript\nget(key) {\n  const data = this.__data__\n  const result = data[key]\n  return result === HASH_UNDEFINED ? undefined : result\n}\n```\n\n`get` 方法是从缓存中取值。\n\n取值其实就是返回缓存对象中对应 `key` 的值即可。因为 `undefined` 在缓存中是以 `__lodash_hash_undefined__` 来表示的，因此遇到值为 `__lodash_hash_undefined__` 时，返回 `undefined` 。\n\n其实这样还是有小小的问题的，如果需要缓存的值刚好是 `__lodash_hash_undefined__`，那取出来的值跟预设的就不一致了。但是这样情况应该很少出现吧。\n\n如果是自己写的函数，可以用数组、对象或者 `Symbol` 来替代字符串，就不会出现字符串冲突的情况了。lodash 为什么不用呢，因为 lodash 是分模块发布的，不同的模块可能依赖不同版本的 `Hash` 类，这样 `HASH_UNDEFINED` 指向的内存或者 `Symbol` 值就不一致了，也就无法区分出 `undefined` 了。具体见作者的回复：[HASH_UNDEFINED why not use Object or Array](https://github.com/lodash/lodash/issues/3573)\n\n### delete\n\n```javascript\ndelete(key) {\n  const result = this.has(key) && delete this.__data__[key]\n  this.size -= result ? 1 : 0\n  return result\n}\n```\n\n`delete` 方法用来删除指定 `key` 的缓存。成功删除返回 `true`， 否则返回 `false`。 删除操作同样需要维护 `size` 属性和缓存值。\n\n首先调用 `has` 方法来判断缓存是否存在，如果存在，用 `delete` 操作符将 `__data__` 中对应的属性删除。\n\n`delete` 操作符在成功删除属性时会返回 `true`，如果成功删除，则需要将 `size` 减少 `1` 。\n\n## 参考\n\n1. [Set 和 Map 数据结构](http://es6.ruanyifeng.com/#docs/set-map#Map)\n2. [Object.create()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n## License\n\n[署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](http://creativecommons.org/licenses/by-nc-nd/4.0/)\n\n作者：对角另一面\n\n","source":"_posts/lodash源码 内部 Hash缓存.md","raw":"---\ntitle: (转载) lodash源码 内部 Hash缓存\ndate: 2021-12-29\ncategories:\n- 前端\ntags:\n- javascript\n- lodash\n---\n## 作用与用法\n\n`Hash` 顾名思义，就是要有一个离散的序列，根据 `key` 来储取数据。而在 javascript 中，最适合的无疑是对象了。\n\n`Hash` 在 lodash 的 `.internal` 文件夹中，作为内部文件来使用。lodash 会根据不同的数据类型选择不同的缓存方式，`Hash` 便是其中的一种方式，这种方式只能缓存 `key` 的类型符合对象键要求的数据。\n\n `Hash` 只接收一个二维数组作为参数，调用方式如下：\n\n```javascript\nnew Hash([['test1', 1],['test2',2],['test3',3]])\n```\n\n其中子项中的第一项会作为 `key` ，第二项是需要缓存的值。\n\n`Hash` 实例化的结果如下：\n\n```javascript\n{\n  size: 3,\n  __data__: {\n    test1: 1,\n    test2: 2,\n    test3: 3\n  }\n}\n```\n\n缓存的数量储存在 `__data__` 的对象中。\n\n## Hash与Map\n\n后面将会讲到，除了使用 `Hash` 方式缓存数据外，还会用到 `Map`，lodash 在设计 `Hash` 的数据管理接口时，也与 `Map` 的接口一致，但是不会包含 `Map` 的遍历方法。\n\n先来看看这些接口都有那些：\n\n![](/images/hash.png)\n\n## 源码\n\n```javascript\nconst HASH_UNDEFINED = '__lodash_hash_undefined__'\n\nclass Hash {\n  constructor(entries) {\n    let index = -1\n    const length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      const entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n  clear() {\n    this.__data__ = Object.create(null)\n    this.size = 0\n  }\n  delete(key) {\n    const result = this.has(key) && delete this.__data__[key]\n    this.size -= result ? 1 : 0\n    return result\n  }\n  get(key) {\n    const data = this.__data__\n    const result = data[key]\n    return result === HASH_UNDEFINED ? undefined : result\n  }\n  has(key) {\n    const data = this.__data__\n    return data[key] !== undefined\n  }\n  set(key, value) {\n    const data = this.__data__\n    this.size += this.has(key) ? 0 : 1\n    data[key] = value === undefined ? HASH_UNDEFINED : value\n    return this\n  }\n}\n\nexport default Hash\n```\n\n### constructor\n\n```javascript\nconstructor(entries) {\n    let index = -1\n    const length = entries == null ? 0 : entries.length\n\n    this.clear()\n    while (++index < length) {\n      const entry = entries[index]\n      this.set(entry[0], entry[1])\n    }\n  }\n```\n\n在 `constructor` 中并没有看到初始化 `__data__` 属性和 `size` 属性，这个其实在 `clear` 方法中初始化了，后面会解释。\n\n接着遍历传入的二维数组，调用 `set` 方法，初始化缓存的值。将子项的第一项作为 `key` ，第二项为缓存的值。\n\n### clear\n\n```javascript\nclear() {\n  this.__data__ = Object.create(null)\n  this.size = 0\n}\n```\n\n`clear` 的作用是清空缓存，因此需要将 `size` 重置为 `0`。\n\n将缓存的数据 `__data__` 设置为空对象。\n\n这里并没有用 `this.__data__ = {}` 置空，而是调用了 `Object.create` 方法，并且将 `null` 作为参数。我们都知道， `Object.create` 的第一个参数为创建对象的原型对象，传入 `null` 的时候，返回的就是一个真空对象，即没有原型的对象，因此不会有原型属性的干扰，用来做缓存对象十分适合。\n\n### has\n\n```javascript\nhas(key) {\n  const data = this.__data__\n  return data[key] !== undefined\n}\n```\n\n`has` 用来判断是否已经有缓存数据，如果缓存数据已经存在，则返回 `true` 。\n\n判断也十分简单，只需要判断取出来的值是否为 `undefined` 即可。\n\n这个判断有一个坑，后面会讲到。\n\n### set\n\n```javascript\nset(key, value) {\n  const data = this.__data__\n  this.size += this.has(key) ? 0 : 1\n  data[key] = value === undefined ? HASH_UNDEFINED : value\n  return this\n}\n```\n\n`set` 用来增加或者更新需要缓存的值。`set` 的时候需要同时维护 `size` 和在缓存的值。\n\n首先调用 `has` 方法，判断对应的 `key` 是否已经被缓存过，如果已经缓存过，则 `size` 保持不变，否则 `size` 加 `1` 。\n\n缓存值其实就是设置缓存对象 `this.__data__` 对应 `key` 属性的值。\n\n在 `has` 中说到用 `data[key] !== undefined` 有一个坑，因为要缓存的值也可以是 `undefined` ，如果不做处理，肯定会导致判断错误。\n\nlodash 的处理方式是将 `undefined` 的值转换成 `HASH_UNDEFINED` ，也即一开始便定义的 `__lodash_hash_undefined__` 字符串来储存。\n\n所以在缓存中，是用字符串 `__lodash_hash_undefined__` 来替代 `undefined` 的。\n\n`set` 在最后还将实例 `this` 返回，以支持链式操作。\n\n### get\n\n```javascript\nget(key) {\n  const data = this.__data__\n  const result = data[key]\n  return result === HASH_UNDEFINED ? undefined : result\n}\n```\n\n`get` 方法是从缓存中取值。\n\n取值其实就是返回缓存对象中对应 `key` 的值即可。因为 `undefined` 在缓存中是以 `__lodash_hash_undefined__` 来表示的，因此遇到值为 `__lodash_hash_undefined__` 时，返回 `undefined` 。\n\n其实这样还是有小小的问题的，如果需要缓存的值刚好是 `__lodash_hash_undefined__`，那取出来的值跟预设的就不一致了。但是这样情况应该很少出现吧。\n\n如果是自己写的函数，可以用数组、对象或者 `Symbol` 来替代字符串，就不会出现字符串冲突的情况了。lodash 为什么不用呢，因为 lodash 是分模块发布的，不同的模块可能依赖不同版本的 `Hash` 类，这样 `HASH_UNDEFINED` 指向的内存或者 `Symbol` 值就不一致了，也就无法区分出 `undefined` 了。具体见作者的回复：[HASH_UNDEFINED why not use Object or Array](https://github.com/lodash/lodash/issues/3573)\n\n### delete\n\n```javascript\ndelete(key) {\n  const result = this.has(key) && delete this.__data__[key]\n  this.size -= result ? 1 : 0\n  return result\n}\n```\n\n`delete` 方法用来删除指定 `key` 的缓存。成功删除返回 `true`， 否则返回 `false`。 删除操作同样需要维护 `size` 属性和缓存值。\n\n首先调用 `has` 方法来判断缓存是否存在，如果存在，用 `delete` 操作符将 `__data__` 中对应的属性删除。\n\n`delete` 操作符在成功删除属性时会返回 `true`，如果成功删除，则需要将 `size` 减少 `1` 。\n\n## 参考\n\n1. [Set 和 Map 数据结构](http://es6.ruanyifeng.com/#docs/set-map#Map)\n2. [Object.create()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)\n\n## License\n\n[署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](http://creativecommons.org/licenses/by-nc-nd/4.0/)\n\n作者：对角另一面\n\n","slug":"lodash源码 内部 Hash缓存","published":1,"updated":"2022-01-29T14:17:42.893Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p6u000crwh9gh1vbd7e","content":"<h2 id=\"作用与用法\"><a href=\"#作用与用法\" class=\"headerlink\" title=\"作用与用法\"></a>作用与用法</h2><p><code>Hash</code> 顾名思义，就是要有一个离散的序列，根据 <code>key</code> 来储取数据。而在 javascript 中，最适合的无疑是对象了。</p>\n<p><code>Hash</code> 在 lodash 的 <code>.internal</code> 文件夹中，作为内部文件来使用。lodash 会根据不同的数据类型选择不同的缓存方式，<code>Hash</code> 便是其中的一种方式，这种方式只能缓存 <code>key</code> 的类型符合对象键要求的数据。</p>\n<p> <code>Hash</code> 只接收一个二维数组作为参数，调用方式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Hash([[<span class=\"string\">&#x27;test1&#x27;</span>, <span class=\"number\">1</span>],[<span class=\"string\">&#x27;test2&#x27;</span>,<span class=\"number\">2</span>],[<span class=\"string\">&#x27;test3&#x27;</span>,<span class=\"number\">3</span>]])</span><br></pre></td></tr></table></figure>\n\n<p>其中子项中的第一项会作为 <code>key</code> ，第二项是需要缓存的值。</p>\n<p><code>Hash</code> 实例化的结果如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">size</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"attr\">__data__</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">test1</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">test2</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">test3</span>: <span class=\"number\">3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>缓存的数量储存在 <code>__data__</code> 的对象中。</p>\n<h2 id=\"Hash与Map\"><a href=\"#Hash与Map\" class=\"headerlink\" title=\"Hash与Map\"></a>Hash与Map</h2><p>后面将会讲到，除了使用 <code>Hash</code> 方式缓存数据外，还会用到 <code>Map</code>，lodash 在设计 <code>Hash</code> 的数据管理接口时，也与 <code>Map</code> 的接口一致，但是不会包含 <code>Map</code> 的遍历方法。</p>\n<p>先来看看这些接口都有那些：</p>\n<p><img src=\"/images/hash.png\"></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HASH_UNDEFINED = <span class=\"string\">&#x27;__lodash_hash_undefined__&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hash</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">entries</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = -<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> length = entries == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : entries.length</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.clear()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (++index &lt; length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> entry = entries[index]</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.set(entry[<span class=\"number\">0</span>], entry[<span class=\"number\">1</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.__data__ = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.size = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">delete</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.has(key) &amp;&amp; <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.__data__[key]</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.size -= result ? <span class=\"number\">1</span> : <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = data[key]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result === HASH_UNDEFINED ? <span class=\"literal\">undefined</span> : result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">has</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data[key] !== <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.size += <span class=\"built_in\">this</span>.has(key) ? <span class=\"number\">0</span> : <span class=\"number\">1</span></span><br><span class=\"line\">    data[key] = value === <span class=\"literal\">undefined</span> ? HASH_UNDEFINED : value</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Hash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">entries</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = -<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> length = entries == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : entries.length</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.clear()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (++index &lt; length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> entry = entries[index]</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.set(entry[<span class=\"number\">0</span>], entry[<span class=\"number\">1</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>constructor</code> 中并没有看到初始化 <code>__data__</code> 属性和 <code>size</code> 属性，这个其实在 <code>clear</code> 方法中初始化了，后面会解释。</p>\n<p>接着遍历传入的二维数组，调用 <code>set</code> 方法，初始化缓存的值。将子项的第一项作为 <code>key</code> ，第二项为缓存的值。</p>\n<h3 id=\"clear\"><a href=\"#clear\" class=\"headerlink\" title=\"clear\"></a>clear</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.__data__ = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.size = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>clear</code> 的作用是清空缓存，因此需要将 <code>size</code> 重置为 <code>0</code>。</p>\n<p>将缓存的数据 <code>__data__</code> 设置为空对象。</p>\n<p>这里并没有用 <code>this.__data__ = &#123;&#125;</code> 置空，而是调用了 <code>Object.create</code> 方法，并且将 <code>null</code> 作为参数。我们都知道， <code>Object.create</code> 的第一个参数为创建对象的原型对象，传入 <code>null</code> 的时候，返回的就是一个真空对象，即没有原型的对象，因此不会有原型属性的干扰，用来做缓存对象十分适合。</p>\n<h3 id=\"has\"><a href=\"#has\" class=\"headerlink\" title=\"has\"></a>has</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">has</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data[key] !== <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>has</code> 用来判断是否已经有缓存数据，如果缓存数据已经存在，则返回 <code>true</code> 。</p>\n<p>判断也十分简单，只需要判断取出来的值是否为 <code>undefined</code> 即可。</p>\n<p>这个判断有一个坑，后面会讲到。</p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.size += <span class=\"built_in\">this</span>.has(key) ? <span class=\"number\">0</span> : <span class=\"number\">1</span></span><br><span class=\"line\">  data[key] = value === <span class=\"literal\">undefined</span> ? HASH_UNDEFINED : value</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>set</code> 用来增加或者更新需要缓存的值。<code>set</code> 的时候需要同时维护 <code>size</code> 和在缓存的值。</p>\n<p>首先调用 <code>has</code> 方法，判断对应的 <code>key</code> 是否已经被缓存过，如果已经缓存过，则 <code>size</code> 保持不变，否则 <code>size</code> 加 <code>1</code> 。</p>\n<p>缓存值其实就是设置缓存对象 <code>this.__data__</code> 对应 <code>key</code> 属性的值。</p>\n<p>在 <code>has</code> 中说到用 <code>data[key] !== undefined</code> 有一个坑，因为要缓存的值也可以是 <code>undefined</code> ，如果不做处理，肯定会导致判断错误。</p>\n<p>lodash 的处理方式是将 <code>undefined</code> 的值转换成 <code>HASH_UNDEFINED</code> ，也即一开始便定义的 <code>__lodash_hash_undefined__</code> 字符串来储存。</p>\n<p>所以在缓存中，是用字符串 <code>__lodash_hash_undefined__</code> 来替代 <code>undefined</code> 的。</p>\n<p><code>set</code> 在最后还将实例 <code>this</code> 返回，以支持链式操作。</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = data[key]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result === HASH_UNDEFINED ? <span class=\"literal\">undefined</span> : result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>get</code> 方法是从缓存中取值。</p>\n<p>取值其实就是返回缓存对象中对应 <code>key</code> 的值即可。因为 <code>undefined</code> 在缓存中是以 <code>__lodash_hash_undefined__</code> 来表示的，因此遇到值为 <code>__lodash_hash_undefined__</code> 时，返回 <code>undefined</code> 。</p>\n<p>其实这样还是有小小的问题的，如果需要缓存的值刚好是 <code>__lodash_hash_undefined__</code>，那取出来的值跟预设的就不一致了。但是这样情况应该很少出现吧。</p>\n<p>如果是自己写的函数，可以用数组、对象或者 <code>Symbol</code> 来替代字符串，就不会出现字符串冲突的情况了。lodash 为什么不用呢，因为 lodash 是分模块发布的，不同的模块可能依赖不同版本的 <code>Hash</code> 类，这样 <code>HASH_UNDEFINED</code> 指向的内存或者 <code>Symbol</code> 值就不一致了，也就无法区分出 <code>undefined</code> 了。具体见作者的回复：<a href=\"https://github.com/lodash/lodash/issues/3573\">HASH_UNDEFINED why not use Object or Array</a></p>\n<h3 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">delete</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.has(key) &amp;&amp; <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.__data__[key]</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.size -= result ? <span class=\"number\">1</span> : <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>delete</code> 方法用来删除指定 <code>key</code> 的缓存。成功删除返回 <code>true</code>， 否则返回 <code>false</code>。 删除操作同样需要维护 <code>size</code> 属性和缓存值。</p>\n<p>首先调用 <code>has</code> 方法来判断缓存是否存在，如果存在，用 <code>delete</code> 操作符将 <code>__data__</code> 中对应的属性删除。</p>\n<p><code>delete</code> 操作符在成功删除属性时会返回 <code>true</code>，如果成功删除，则需要将 <code>size</code> 减少 <code>1</code> 。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/set-map#Map\">Set 和 Map 数据结构</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\">Object.create()</a></li>\n</ol>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p><a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>\n<p>作者：对角另一面</p>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h2 id=\"作用与用法\"><a href=\"#作用与用法\" class=\"headerlink\" title=\"作用与用法\"></a>作用与用法</h2><p><code>Hash</code> 顾名思义，就是要有一个离散的序列，根据 <code>key</code> 来储取数据。而在 javascript 中，最适合的无疑是对象了。</p>\n<p><code>Hash</code> 在 lodash 的 <code>.internal</code> 文件夹中，作为内部文件来使用。lodash 会根据不同的数据类型选择不同的缓存方式，<code>Hash</code> 便是其中的一种方式，这种方式只能缓存 <code>key</code> 的类型符合对象键要求的数据。</p>\n<p> <code>Hash</code> 只接收一个二维数组作为参数，调用方式如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Hash([[<span class=\"string\">&#x27;test1&#x27;</span>, <span class=\"number\">1</span>],[<span class=\"string\">&#x27;test2&#x27;</span>,<span class=\"number\">2</span>],[<span class=\"string\">&#x27;test3&#x27;</span>,<span class=\"number\">3</span>]])</span><br></pre></td></tr></table></figure>\n\n<p>其中子项中的第一项会作为 <code>key</code> ，第二项是需要缓存的值。</p>\n<p><code>Hash</code> 实例化的结果如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">size</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"attr\">__data__</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">test1</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">test2</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">test3</span>: <span class=\"number\">3</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>缓存的数量储存在 <code>__data__</code> 的对象中。</p>\n<h2 id=\"Hash与Map\"><a href=\"#Hash与Map\" class=\"headerlink\" title=\"Hash与Map\"></a>Hash与Map</h2><p>后面将会讲到，除了使用 <code>Hash</code> 方式缓存数据外，还会用到 <code>Map</code>，lodash 在设计 <code>Hash</code> 的数据管理接口时，也与 <code>Map</code> 的接口一致，但是不会包含 <code>Map</code> 的遍历方法。</p>\n<p>先来看看这些接口都有那些：</p>\n<p><img src=\"/images/hash.png\"></p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HASH_UNDEFINED = <span class=\"string\">&#x27;__lodash_hash_undefined__&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hash</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">entries</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = -<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> length = entries == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : entries.length</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.clear()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (++index &lt; length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> entry = entries[index]</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.set(entry[<span class=\"number\">0</span>], entry[<span class=\"number\">1</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.__data__ = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.size = <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">delete</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.has(key) &amp;&amp; <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.__data__[key]</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.size -= result ? <span class=\"number\">1</span> : <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = data[key]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result === HASH_UNDEFINED ? <span class=\"literal\">undefined</span> : result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">has</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data[key] !== <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.size += <span class=\"built_in\">this</span>.has(key) ? <span class=\"number\">0</span> : <span class=\"number\">1</span></span><br><span class=\"line\">    data[key] = value === <span class=\"literal\">undefined</span> ? HASH_UNDEFINED : value</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Hash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">entries</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = -<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> length = entries == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : entries.length</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.clear()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (++index &lt; length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> entry = entries[index]</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.set(entry[<span class=\"number\">0</span>], entry[<span class=\"number\">1</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 <code>constructor</code> 中并没有看到初始化 <code>__data__</code> 属性和 <code>size</code> 属性，这个其实在 <code>clear</code> 方法中初始化了，后面会解释。</p>\n<p>接着遍历传入的二维数组，调用 <code>set</code> 方法，初始化缓存的值。将子项的第一项作为 <code>key</code> ，第二项为缓存的值。</p>\n<h3 id=\"clear\"><a href=\"#clear\" class=\"headerlink\" title=\"clear\"></a>clear</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">clear</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.__data__ = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.size = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>clear</code> 的作用是清空缓存，因此需要将 <code>size</code> 重置为 <code>0</code>。</p>\n<p>将缓存的数据 <code>__data__</code> 设置为空对象。</p>\n<p>这里并没有用 <code>this.__data__ = &#123;&#125;</code> 置空，而是调用了 <code>Object.create</code> 方法，并且将 <code>null</code> 作为参数。我们都知道， <code>Object.create</code> 的第一个参数为创建对象的原型对象，传入 <code>null</code> 的时候，返回的就是一个真空对象，即没有原型的对象，因此不会有原型属性的干扰，用来做缓存对象十分适合。</p>\n<h3 id=\"has\"><a href=\"#has\" class=\"headerlink\" title=\"has\"></a>has</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">has</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data[key] !== <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>has</code> 用来判断是否已经有缓存数据，如果缓存数据已经存在，则返回 <code>true</code> 。</p>\n<p>判断也十分简单，只需要判断取出来的值是否为 <code>undefined</code> 即可。</p>\n<p>这个判断有一个坑，后面会讲到。</p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">key, value</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.size += <span class=\"built_in\">this</span>.has(key) ? <span class=\"number\">0</span> : <span class=\"number\">1</span></span><br><span class=\"line\">  data[key] = value === <span class=\"literal\">undefined</span> ? HASH_UNDEFINED : value</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>set</code> 用来增加或者更新需要缓存的值。<code>set</code> 的时候需要同时维护 <code>size</code> 和在缓存的值。</p>\n<p>首先调用 <code>has</code> 方法，判断对应的 <code>key</code> 是否已经被缓存过，如果已经缓存过，则 <code>size</code> 保持不变，否则 <code>size</code> 加 <code>1</code> 。</p>\n<p>缓存值其实就是设置缓存对象 <code>this.__data__</code> 对应 <code>key</code> 属性的值。</p>\n<p>在 <code>has</code> 中说到用 <code>data[key] !== undefined</code> 有一个坑，因为要缓存的值也可以是 <code>undefined</code> ，如果不做处理，肯定会导致判断错误。</p>\n<p>lodash 的处理方式是将 <code>undefined</code> 的值转换成 <code>HASH_UNDEFINED</code> ，也即一开始便定义的 <code>__lodash_hash_undefined__</code> 字符串来储存。</p>\n<p>所以在缓存中，是用字符串 <code>__lodash_hash_undefined__</code> 来替代 <code>undefined</code> 的。</p>\n<p><code>set</code> 在最后还将实例 <code>this</code> 返回，以支持链式操作。</p>\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.__data__</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = data[key]</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result === HASH_UNDEFINED ? <span class=\"literal\">undefined</span> : result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>get</code> 方法是从缓存中取值。</p>\n<p>取值其实就是返回缓存对象中对应 <code>key</code> 的值即可。因为 <code>undefined</code> 在缓存中是以 <code>__lodash_hash_undefined__</code> 来表示的，因此遇到值为 <code>__lodash_hash_undefined__</code> 时，返回 <code>undefined</code> 。</p>\n<p>其实这样还是有小小的问题的，如果需要缓存的值刚好是 <code>__lodash_hash_undefined__</code>，那取出来的值跟预设的就不一致了。但是这样情况应该很少出现吧。</p>\n<p>如果是自己写的函数，可以用数组、对象或者 <code>Symbol</code> 来替代字符串，就不会出现字符串冲突的情况了。lodash 为什么不用呢，因为 lodash 是分模块发布的，不同的模块可能依赖不同版本的 <code>Hash</code> 类，这样 <code>HASH_UNDEFINED</code> 指向的内存或者 <code>Symbol</code> 值就不一致了，也就无法区分出 <code>undefined</code> 了。具体见作者的回复：<a href=\"https://github.com/lodash/lodash/issues/3573\">HASH_UNDEFINED why not use Object or Array</a></p>\n<h3 id=\"delete\"><a href=\"#delete\" class=\"headerlink\" title=\"delete\"></a>delete</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">delete</span>(<span class=\"params\">key</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = <span class=\"built_in\">this</span>.has(key) &amp;&amp; <span class=\"keyword\">delete</span> <span class=\"built_in\">this</span>.__data__[key]</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.size -= result ? <span class=\"number\">1</span> : <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>delete</code> 方法用来删除指定 <code>key</code> 的缓存。成功删除返回 <code>true</code>， 否则返回 <code>false</code>。 删除操作同样需要维护 <code>size</code> 属性和缓存值。</p>\n<p>首先调用 <code>has</code> 方法来判断缓存是否存在，如果存在，用 <code>delete</code> 操作符将 <code>__data__</code> 中对应的属性删除。</p>\n<p><code>delete</code> 操作符在成功删除属性时会返回 <code>true</code>，如果成功删除，则需要将 <code>size</code> 减少 <code>1</code> 。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://es6.ruanyifeng.com/#docs/set-map#Map\">Set 和 Map 数据结构</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\">Object.create()</a></li>\n</ol>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p><a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>\n<p>作者：对角另一面</p>\n"},{"title":"(转载) lodash源码 内部 assocIndexOf","date":"2022-01-03T16:00:00.000Z","_content":"# lodash源码分析之自减的两种形式\n\n> 这个世界需要一个特定的恶人，可以供人们指名道姓，千夫所指：“全都怪你”。\n>\n> ——村上春树《当我谈跑步时我谈些什么》\n\n本文为读 lodash 源码的第六篇，后续文章会更新到这个仓库中，欢迎 star：[pocket-lodash](https://github.com/yeyuqiudeng/pocket-lodash)\n\ngitbook也会同步仓库的更新，gitbook地址：[pocket-lodash](https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details)\n\n本篇分析的是 `assocIndexOf` 函数。\n\n## 作用与用法\n\n`assocIndexOf` 是 lodash 的内部函数，之前在《[lodash源码分析之Hash缓存](hash.md)》介绍过一种这样的数据结构：\n\n```javascript\nvar caches = [['test1', 1],['test2',2],['test3',3]]\n```\n\n这是一个二维数组，每项中的第一项作为缓存对象的 `key`，第二项为缓存的值。\n\n`assocIndexOf` 的作用是找出指定的 `key` 在数组中的索引值。\n\n例如要找 `key` 为 `tes1` 的索引 ：\n\n```javascript\nassocIndexOf(caches, 'test1') // 0\n```\n\n## 依赖\n\n```javascript\nimport eq from '../eq.js'\n```\n\n[lodash源码分析之NaN不是NaN](../eq.md)\n\n## 源码分析\n\n```javascript\nfunction assocIndexOf(array, key) {\n  let { length } = array\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length\n    }\n  }\n  return -1\n}\n```\n\n这段代码很精简，让 `length` 自减，调用 `eq` 函数，从二维数组的最后一项开始，逐项获取 `key` 值，与传入的 `key` 比较，遇到匹配的，马上将该项的索引返回。如果都没找到，返回 `-1` 。返回结果的规则与 `indexOf` 一致。\n\n## length--和--length\n\n我们都知道自减还有另外一种前置的形式，即 `--length`，那将上面的代码改成 `while(--length)` 可不可以呢？试一下就知道了。\n\n改了之后，用 `caches` 来测试下：\n\n```javascript\nassocIndexOf(caches, 'test3') // 2\nassocIndexOf(caches, 'test2') // 1\nassocIndexOf(caches, 'test1') // -1\n```\n\n可以看到，改了之后，只影响到了第一项的结果，也就是终止条件有问题，根本没有遍历到第一项，但是后面的结果是正确的，也就说循环体里的 `length` 没有受到影响。\n\n你可能会有点疑惑，`while` 的终止条件比较的不是 `length` 吗？为什么 `length--` 正确，而 `--length` 不正确呢？\n\n其实 `while` 的终止条件并不是 `length` ，而是 `length--` 表达式所返回的结果。现在来看一下 `length--` 和 `--length` 所返回的结果有什么差别。\n\n```javascript\nvar length = 3\nlength-- // 3\nlength // 2\n```\n\n可以看到， `length--` 返回的结果和自减前的一致，但是 `length` 已经减少 `1` 了。因此使用 `length--` ，最后一次进入循环体应该在 `length` 等于 `1` 的时候。\n\n再来看 `--length`\n\n```javascript\nvar length = 3\n--length // 2\nlength // 2\n```\n\n`--length` 返回的结果跟自减后的结果一致，因此最后一次进入循环体应该是 `length` 为 `2` 的时候，因此如果换成这种形式，会漏掉一次循环。\n\n##  参考\n\n1. [代码之谜（二）- 语句与表达式](http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-expression-and-statement.html)\n\n## License\n\n[署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](http://creativecommons.org/licenses/by-nc-nd/4.0/)\n\n最后，所有文章都会同步发送到微信公众号上，欢迎关注，欢迎提意见：  ![](https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg) \n\n作者：对角另一面","source":"_posts/lodash源码 内部 assocIndexOf.md","raw":"---\ntitle: (转载) lodash源码 内部 assocIndexOf\ndate: 2022-01-04\ncategories:\n- 前端\ntags:\n- javascript\n- lodash\n---\n# lodash源码分析之自减的两种形式\n\n> 这个世界需要一个特定的恶人，可以供人们指名道姓，千夫所指：“全都怪你”。\n>\n> ——村上春树《当我谈跑步时我谈些什么》\n\n本文为读 lodash 源码的第六篇，后续文章会更新到这个仓库中，欢迎 star：[pocket-lodash](https://github.com/yeyuqiudeng/pocket-lodash)\n\ngitbook也会同步仓库的更新，gitbook地址：[pocket-lodash](https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details)\n\n本篇分析的是 `assocIndexOf` 函数。\n\n## 作用与用法\n\n`assocIndexOf` 是 lodash 的内部函数，之前在《[lodash源码分析之Hash缓存](hash.md)》介绍过一种这样的数据结构：\n\n```javascript\nvar caches = [['test1', 1],['test2',2],['test3',3]]\n```\n\n这是一个二维数组，每项中的第一项作为缓存对象的 `key`，第二项为缓存的值。\n\n`assocIndexOf` 的作用是找出指定的 `key` 在数组中的索引值。\n\n例如要找 `key` 为 `tes1` 的索引 ：\n\n```javascript\nassocIndexOf(caches, 'test1') // 0\n```\n\n## 依赖\n\n```javascript\nimport eq from '../eq.js'\n```\n\n[lodash源码分析之NaN不是NaN](../eq.md)\n\n## 源码分析\n\n```javascript\nfunction assocIndexOf(array, key) {\n  let { length } = array\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length\n    }\n  }\n  return -1\n}\n```\n\n这段代码很精简，让 `length` 自减，调用 `eq` 函数，从二维数组的最后一项开始，逐项获取 `key` 值，与传入的 `key` 比较，遇到匹配的，马上将该项的索引返回。如果都没找到，返回 `-1` 。返回结果的规则与 `indexOf` 一致。\n\n## length--和--length\n\n我们都知道自减还有另外一种前置的形式，即 `--length`，那将上面的代码改成 `while(--length)` 可不可以呢？试一下就知道了。\n\n改了之后，用 `caches` 来测试下：\n\n```javascript\nassocIndexOf(caches, 'test3') // 2\nassocIndexOf(caches, 'test2') // 1\nassocIndexOf(caches, 'test1') // -1\n```\n\n可以看到，改了之后，只影响到了第一项的结果，也就是终止条件有问题，根本没有遍历到第一项，但是后面的结果是正确的，也就说循环体里的 `length` 没有受到影响。\n\n你可能会有点疑惑，`while` 的终止条件比较的不是 `length` 吗？为什么 `length--` 正确，而 `--length` 不正确呢？\n\n其实 `while` 的终止条件并不是 `length` ，而是 `length--` 表达式所返回的结果。现在来看一下 `length--` 和 `--length` 所返回的结果有什么差别。\n\n```javascript\nvar length = 3\nlength-- // 3\nlength // 2\n```\n\n可以看到， `length--` 返回的结果和自减前的一致，但是 `length` 已经减少 `1` 了。因此使用 `length--` ，最后一次进入循环体应该在 `length` 等于 `1` 的时候。\n\n再来看 `--length`\n\n```javascript\nvar length = 3\n--length // 2\nlength // 2\n```\n\n`--length` 返回的结果跟自减后的结果一致，因此最后一次进入循环体应该是 `length` 为 `2` 的时候，因此如果换成这种形式，会漏掉一次循环。\n\n##  参考\n\n1. [代码之谜（二）- 语句与表达式](http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-expression-and-statement.html)\n\n## License\n\n[署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](http://creativecommons.org/licenses/by-nc-nd/4.0/)\n\n最后，所有文章都会同步发送到微信公众号上，欢迎关注，欢迎提意见：  ![](https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg) \n\n作者：对角另一面","slug":"lodash源码 内部 assocIndexOf","published":1,"updated":"2022-01-29T13:58:01.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p6w000grwh9b4z7azmp","content":"<h1 id=\"lodash源码分析之自减的两种形式\"><a href=\"#lodash源码分析之自减的两种形式\" class=\"headerlink\" title=\"lodash源码分析之自减的两种形式\"></a>lodash源码分析之自减的两种形式</h1><blockquote>\n<p>这个世界需要一个特定的恶人，可以供人们指名道姓，千夫所指：“全都怪你”。</p>\n<p>——村上春树《当我谈跑步时我谈些什么》</p>\n</blockquote>\n<p>本文为读 lodash 源码的第六篇，后续文章会更新到这个仓库中，欢迎 star：<a href=\"https://github.com/yeyuqiudeng/pocket-lodash\">pocket-lodash</a></p>\n<p>gitbook也会同步仓库的更新，gitbook地址：<a href=\"https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details\">pocket-lodash</a></p>\n<p>本篇分析的是 <code>assocIndexOf</code> 函数。</p>\n<h2 id=\"作用与用法\"><a href=\"#作用与用法\" class=\"headerlink\" title=\"作用与用法\"></a>作用与用法</h2><p><code>assocIndexOf</code> 是 lodash 的内部函数，之前在《<a href=\"hash.md\">lodash源码分析之Hash缓存</a>》介绍过一种这样的数据结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> caches = [[<span class=\"string\">&#x27;test1&#x27;</span>, <span class=\"number\">1</span>],[<span class=\"string\">&#x27;test2&#x27;</span>,<span class=\"number\">2</span>],[<span class=\"string\">&#x27;test3&#x27;</span>,<span class=\"number\">3</span>]]</span><br></pre></td></tr></table></figure>\n\n<p>这是一个二维数组，每项中的第一项作为缓存对象的 <code>key</code>，第二项为缓存的值。</p>\n<p><code>assocIndexOf</code> 的作用是找出指定的 <code>key</code> 在数组中的索引值。</p>\n<p>例如要找 <code>key</code> 为 <code>tes1</code> 的索引 ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assocIndexOf(caches, <span class=\"string\">&#x27;test1&#x27;</span>) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> eq <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../eq.js&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"../eq.md\">lodash源码分析之NaN不是NaN</a></p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assocIndexOf</span>(<span class=\"params\">array, key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; length &#125; = array</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (length--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eq(array[length][<span class=\"number\">0</span>], key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> length</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码很精简，让 <code>length</code> 自减，调用 <code>eq</code> 函数，从二维数组的最后一项开始，逐项获取 <code>key</code> 值，与传入的 <code>key</code> 比较，遇到匹配的，马上将该项的索引返回。如果都没找到，返回 <code>-1</code> 。返回结果的规则与 <code>indexOf</code> 一致。</p>\n<h2 id=\"length–和–length\"><a href=\"#length–和–length\" class=\"headerlink\" title=\"length–和–length\"></a>length–和–length</h2><p>我们都知道自减还有另外一种前置的形式，即 <code>--length</code>，那将上面的代码改成 <code>while(--length)</code> 可不可以呢？试一下就知道了。</p>\n<p>改了之后，用 <code>caches</code> 来测试下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assocIndexOf(caches, <span class=\"string\">&#x27;test3&#x27;</span>) <span class=\"comment\">// 2</span></span><br><span class=\"line\">assocIndexOf(caches, <span class=\"string\">&#x27;test2&#x27;</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\">assocIndexOf(caches, <span class=\"string\">&#x27;test1&#x27;</span>) <span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，改了之后，只影响到了第一项的结果，也就是终止条件有问题，根本没有遍历到第一项，但是后面的结果是正确的，也就说循环体里的 <code>length</code> 没有受到影响。</p>\n<p>你可能会有点疑惑，<code>while</code> 的终止条件比较的不是 <code>length</code> 吗？为什么 <code>length--</code> 正确，而 <code>--length</code> 不正确呢？</p>\n<p>其实 <code>while</code> 的终止条件并不是 <code>length</code> ，而是 <code>length--</code> 表达式所返回的结果。现在来看一下 <code>length--</code> 和 <code>--length</code> 所返回的结果有什么差别。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = <span class=\"number\">3</span></span><br><span class=\"line\">length-- <span class=\"comment\">// 3</span></span><br><span class=\"line\">length <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到， <code>length--</code> 返回的结果和自减前的一致，但是 <code>length</code> 已经减少 <code>1</code> 了。因此使用 <code>length--</code> ，最后一次进入循环体应该在 <code>length</code> 等于 <code>1</code> 的时候。</p>\n<p>再来看 <code>--length</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = <span class=\"number\">3</span></span><br><span class=\"line\">--length <span class=\"comment\">// 2</span></span><br><span class=\"line\">length <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p><code>--length</code> 返回的结果跟自减后的结果一致，因此最后一次进入循环体应该是 <code>length</code> 为 <code>2</code> 的时候，因此如果换成这种形式，会漏掉一次循环。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-expression-and-statement.html\">代码之谜（二）- 语句与表达式</a></li>\n</ol>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p><a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>\n<p>最后，所有文章都会同步发送到微信公众号上，欢迎关注，欢迎提意见：  <img src=\"https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg\"> </p>\n<p>作者：对角另一面</p>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h1 id=\"lodash源码分析之自减的两种形式\"><a href=\"#lodash源码分析之自减的两种形式\" class=\"headerlink\" title=\"lodash源码分析之自减的两种形式\"></a>lodash源码分析之自减的两种形式</h1><blockquote>\n<p>这个世界需要一个特定的恶人，可以供人们指名道姓，千夫所指：“全都怪你”。</p>\n<p>——村上春树《当我谈跑步时我谈些什么》</p>\n</blockquote>\n<p>本文为读 lodash 源码的第六篇，后续文章会更新到这个仓库中，欢迎 star：<a href=\"https://github.com/yeyuqiudeng/pocket-lodash\">pocket-lodash</a></p>\n<p>gitbook也会同步仓库的更新，gitbook地址：<a href=\"https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details\">pocket-lodash</a></p>\n<p>本篇分析的是 <code>assocIndexOf</code> 函数。</p>\n<h2 id=\"作用与用法\"><a href=\"#作用与用法\" class=\"headerlink\" title=\"作用与用法\"></a>作用与用法</h2><p><code>assocIndexOf</code> 是 lodash 的内部函数，之前在《<a href=\"hash.md\">lodash源码分析之Hash缓存</a>》介绍过一种这样的数据结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> caches = [[<span class=\"string\">&#x27;test1&#x27;</span>, <span class=\"number\">1</span>],[<span class=\"string\">&#x27;test2&#x27;</span>,<span class=\"number\">2</span>],[<span class=\"string\">&#x27;test3&#x27;</span>,<span class=\"number\">3</span>]]</span><br></pre></td></tr></table></figure>\n\n<p>这是一个二维数组，每项中的第一项作为缓存对象的 <code>key</code>，第二项为缓存的值。</p>\n<p><code>assocIndexOf</code> 的作用是找出指定的 <code>key</code> 在数组中的索引值。</p>\n<p>例如要找 <code>key</code> 为 <code>tes1</code> 的索引 ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assocIndexOf(caches, <span class=\"string\">&#x27;test1&#x27;</span>) <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> eq <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../eq.js&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><a href=\"../eq.md\">lodash源码分析之NaN不是NaN</a></p>\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assocIndexOf</span>(<span class=\"params\">array, key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; length &#125; = array</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (length--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eq(array[length][<span class=\"number\">0</span>], key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> length</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码很精简，让 <code>length</code> 自减，调用 <code>eq</code> 函数，从二维数组的最后一项开始，逐项获取 <code>key</code> 值，与传入的 <code>key</code> 比较，遇到匹配的，马上将该项的索引返回。如果都没找到，返回 <code>-1</code> 。返回结果的规则与 <code>indexOf</code> 一致。</p>\n<h2 id=\"length–和–length\"><a href=\"#length–和–length\" class=\"headerlink\" title=\"length–和–length\"></a>length–和–length</h2><p>我们都知道自减还有另外一种前置的形式，即 <code>--length</code>，那将上面的代码改成 <code>while(--length)</code> 可不可以呢？试一下就知道了。</p>\n<p>改了之后，用 <code>caches</code> 来测试下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assocIndexOf(caches, <span class=\"string\">&#x27;test3&#x27;</span>) <span class=\"comment\">// 2</span></span><br><span class=\"line\">assocIndexOf(caches, <span class=\"string\">&#x27;test2&#x27;</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\">assocIndexOf(caches, <span class=\"string\">&#x27;test1&#x27;</span>) <span class=\"comment\">// -1</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，改了之后，只影响到了第一项的结果，也就是终止条件有问题，根本没有遍历到第一项，但是后面的结果是正确的，也就说循环体里的 <code>length</code> 没有受到影响。</p>\n<p>你可能会有点疑惑，<code>while</code> 的终止条件比较的不是 <code>length</code> 吗？为什么 <code>length--</code> 正确，而 <code>--length</code> 不正确呢？</p>\n<p>其实 <code>while</code> 的终止条件并不是 <code>length</code> ，而是 <code>length--</code> 表达式所返回的结果。现在来看一下 <code>length--</code> 和 <code>--length</code> 所返回的结果有什么差别。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = <span class=\"number\">3</span></span><br><span class=\"line\">length-- <span class=\"comment\">// 3</span></span><br><span class=\"line\">length <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到， <code>length--</code> 返回的结果和自减前的一致，但是 <code>length</code> 已经减少 <code>1</code> 了。因此使用 <code>length--</code> ，最后一次进入循环体应该在 <code>length</code> 等于 <code>1</code> 的时候。</p>\n<p>再来看 <code>--length</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = <span class=\"number\">3</span></span><br><span class=\"line\">--length <span class=\"comment\">// 2</span></span><br><span class=\"line\">length <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p><code>--length</code> 返回的结果跟自减后的结果一致，因此最后一次进入循环体应该是 <code>length</code> 为 <code>2</code> 的时候，因此如果换成这种形式，会漏掉一次循环。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-expression-and-statement.html\">代码之谜（二）- 语句与表达式</a></li>\n</ol>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p><a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>\n<p>最后，所有文章都会同步发送到微信公众号上，欢迎关注，欢迎提意见：  <img src=\"https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg\"> </p>\n<p>作者：对角另一面</p>\n"},{"title":"(转载) lodash源码 内部 baseFindIndex","date":"2022-01-19T16:00:00.000Z","_content":"# lodash源码分析之baseFindIndex中的运算符优先级\n\n> 我悟出权力本来就是不讲理的——蟑螂就是海米；也悟出要造反，内心必须强大到足以承受任何后果才行。\n>\n> ——北岛《城门开》\n\n本文为读 lodash 源码的第十篇，后续文章会更新到这个仓库中，欢迎 star：[pocket-lodash](https://github.com/yeyuqiudeng/pocket-lodash)\n\ngitbook也会同步仓库的更新，gitbook地址：[pocket-lodash](https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details)\n\n## 作用与用法\n\n`baseFindIndex` 是内部方法，其作用类似于ES6的 `findIndex`，查找符合条件的第一个元素的索引。\n\n`baseFindIndex` 除了从前向后查找外，还可以从后向前查找。\n\n用法如下：\n\n```javascript\nbaseFindIndex([3,1,2], function(val, index, array) {\n  return val > 1\n}, 1) // 从前向后查找，从索引1开始查找，返回2\nbaseFindIndex([3,1,2], function(val, index, array) {\n  return val > 1\n}, 1, true) // 从后向前查找，从索引1开始查找，返回3\n```\n\n## 源码分析\n\n```javascript\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  const { length } = array\n  let index = fromIndex + (fromRight ? 1 : -1)\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index\n    }\n  }\n  return -1\n}\n```\n\n这段代码再次展示了 lodash 的特点，短小精悍！\n\n这次读源码我们从里往外看。\n\n从代码中很容易看到，`predicate` 是传递进来的函数，在 `baseFindIndex` 调用该函数，如果返回的结果为真值，则中止查找，返回索引。\n\n### 运算符优先级\n\n我们再往外看，看看 `while` 的循环条件：\n\n```javascript\nfromRight ? index-- : ++index < length\n```\n\n现在问题来了，这个三元表达式有两种可能，一种是：\n\n```javascript\n(fromRight ? index-- : ++index) < length\n```\n\n一种是：\n\n```javascript\nfromRight ? index-- : (++index < length)\n```\n\n究竟是那一种呢？这就要看运算符的优化级了，下面这个表是 MDN 上的截图：\n\n![](../images/baseFindIndex.png)\n\n这个表将优化级划分成了20个级别，数字越大，优化级越高。\n\n从表中可以看到，比较运算符的优先级为11，而三元表达式（条件运算符）的优化级为4，因此可以确定比较运算符的优先级要比三元表达式的要高，循环条件其实等价于第二种写法。\n\n### 增减迷局\n\n再往上看，可以看到这句代码：\n\n```javascript\nlet index = fromIndex + (fromRight ? 1 : -1)\n```\n\n在向后查找时， `index` 减少了1，而向前查找时，`index` 增加了1，为什么要这样做呢？\n\n再结合循环条件看下：\n\n```javascript\nfromRight ? index-- : ++index < length\n```\n\n在向前查找时，使用的是 `index--` 表达式的运算结果，向后查找时，使用的是 `++index < lenth` 表达式的运算结果。\n\n从上表中也可以看出前缀自增比比较运算符的优化级要高。\n\n前缀自增返回的是自增后的结果，而在循环条件中就要将索引 `index` 增加1，这样会忽略掉第一个需要遍历的元素，作为补救，在开始遍历前，需要将 `index` 减少1。\n\n同理，在向前查找时，需要将索引增加1，因为在遍历开始时就已经将索引减少1。\n\n那又为什么向前查找时用的是后缀自减，而不是用前缀自减呢？\n\n因为在向前查找时，最终要查找到数组索引 `0` 的位置，后缀自减返回的是自减前的数值，因此当 `index` 为 `1` 时，自减后的 `index` 为 `0` ，但是在循环条件中依然拿 `1` 来进行判断，所以使得索引 `0` 得以进入循环体。\n\n关于前缀自增/减和后缀自增/减的区别可以看《[lodash源码分析之自减的两种形式](./assocIndexOf.md)》。\n\n## 参考\n\n1. [MDN:运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n\n## License\n\n[署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](http://creativecommons.org/licenses/by-nc-nd/4.0/)\n\n最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：  ![](https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg) \n\n作者：对角另一面","source":"_posts/lodash源码 内部 baseFindIndex.md","raw":"---\ntitle: (转载) lodash源码 内部 baseFindIndex\ndate: 2022-01-20\ncategories:\n- 前端\ntags:\n- javascript\n- lodash\n---\n# lodash源码分析之baseFindIndex中的运算符优先级\n\n> 我悟出权力本来就是不讲理的——蟑螂就是海米；也悟出要造反，内心必须强大到足以承受任何后果才行。\n>\n> ——北岛《城门开》\n\n本文为读 lodash 源码的第十篇，后续文章会更新到这个仓库中，欢迎 star：[pocket-lodash](https://github.com/yeyuqiudeng/pocket-lodash)\n\ngitbook也会同步仓库的更新，gitbook地址：[pocket-lodash](https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details)\n\n## 作用与用法\n\n`baseFindIndex` 是内部方法，其作用类似于ES6的 `findIndex`，查找符合条件的第一个元素的索引。\n\n`baseFindIndex` 除了从前向后查找外，还可以从后向前查找。\n\n用法如下：\n\n```javascript\nbaseFindIndex([3,1,2], function(val, index, array) {\n  return val > 1\n}, 1) // 从前向后查找，从索引1开始查找，返回2\nbaseFindIndex([3,1,2], function(val, index, array) {\n  return val > 1\n}, 1, true) // 从后向前查找，从索引1开始查找，返回3\n```\n\n## 源码分析\n\n```javascript\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  const { length } = array\n  let index = fromIndex + (fromRight ? 1 : -1)\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index\n    }\n  }\n  return -1\n}\n```\n\n这段代码再次展示了 lodash 的特点，短小精悍！\n\n这次读源码我们从里往外看。\n\n从代码中很容易看到，`predicate` 是传递进来的函数，在 `baseFindIndex` 调用该函数，如果返回的结果为真值，则中止查找，返回索引。\n\n### 运算符优先级\n\n我们再往外看，看看 `while` 的循环条件：\n\n```javascript\nfromRight ? index-- : ++index < length\n```\n\n现在问题来了，这个三元表达式有两种可能，一种是：\n\n```javascript\n(fromRight ? index-- : ++index) < length\n```\n\n一种是：\n\n```javascript\nfromRight ? index-- : (++index < length)\n```\n\n究竟是那一种呢？这就要看运算符的优化级了，下面这个表是 MDN 上的截图：\n\n![](../images/baseFindIndex.png)\n\n这个表将优化级划分成了20个级别，数字越大，优化级越高。\n\n从表中可以看到，比较运算符的优先级为11，而三元表达式（条件运算符）的优化级为4，因此可以确定比较运算符的优先级要比三元表达式的要高，循环条件其实等价于第二种写法。\n\n### 增减迷局\n\n再往上看，可以看到这句代码：\n\n```javascript\nlet index = fromIndex + (fromRight ? 1 : -1)\n```\n\n在向后查找时， `index` 减少了1，而向前查找时，`index` 增加了1，为什么要这样做呢？\n\n再结合循环条件看下：\n\n```javascript\nfromRight ? index-- : ++index < length\n```\n\n在向前查找时，使用的是 `index--` 表达式的运算结果，向后查找时，使用的是 `++index < lenth` 表达式的运算结果。\n\n从上表中也可以看出前缀自增比比较运算符的优化级要高。\n\n前缀自增返回的是自增后的结果，而在循环条件中就要将索引 `index` 增加1，这样会忽略掉第一个需要遍历的元素，作为补救，在开始遍历前，需要将 `index` 减少1。\n\n同理，在向前查找时，需要将索引增加1，因为在遍历开始时就已经将索引减少1。\n\n那又为什么向前查找时用的是后缀自减，而不是用前缀自减呢？\n\n因为在向前查找时，最终要查找到数组索引 `0` 的位置，后缀自减返回的是自减前的数值，因此当 `index` 为 `1` 时，自减后的 `index` 为 `0` ，但是在循环条件中依然拿 `1` 来进行判断，所以使得索引 `0` 得以进入循环体。\n\n关于前缀自增/减和后缀自增/减的区别可以看《[lodash源码分析之自减的两种形式](./assocIndexOf.md)》。\n\n## 参考\n\n1. [MDN:运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)\n\n## License\n\n[署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)](http://creativecommons.org/licenses/by-nc-nd/4.0/)\n\n最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：  ![](https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg) \n\n作者：对角另一面","slug":"lodash源码 内部 baseFindIndex","published":1,"updated":"2022-01-29T13:58:05.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p6x000irwh98rev53hj","content":"<h1 id=\"lodash源码分析之baseFindIndex中的运算符优先级\"><a href=\"#lodash源码分析之baseFindIndex中的运算符优先级\" class=\"headerlink\" title=\"lodash源码分析之baseFindIndex中的运算符优先级\"></a>lodash源码分析之baseFindIndex中的运算符优先级</h1><blockquote>\n<p>我悟出权力本来就是不讲理的——蟑螂就是海米；也悟出要造反，内心必须强大到足以承受任何后果才行。</p>\n<p>——北岛《城门开》</p>\n</blockquote>\n<p>本文为读 lodash 源码的第十篇，后续文章会更新到这个仓库中，欢迎 star：<a href=\"https://github.com/yeyuqiudeng/pocket-lodash\">pocket-lodash</a></p>\n<p>gitbook也会同步仓库的更新，gitbook地址：<a href=\"https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details\">pocket-lodash</a></p>\n<h2 id=\"作用与用法\"><a href=\"#作用与用法\" class=\"headerlink\" title=\"作用与用法\"></a>作用与用法</h2><p><code>baseFindIndex</code> 是内部方法，其作用类似于ES6的 <code>findIndex</code>，查找符合条件的第一个元素的索引。</p>\n<p><code>baseFindIndex</code> 除了从前向后查找外，还可以从后向前查找。</p>\n<p>用法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">baseFindIndex([<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val, index, array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val &gt; <span class=\"number\">1</span></span><br><span class=\"line\">&#125;, <span class=\"number\">1</span>) <span class=\"comment\">// 从前向后查找，从索引1开始查找，返回2</span></span><br><span class=\"line\">baseFindIndex([<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val, index, array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val &gt; <span class=\"number\">1</span></span><br><span class=\"line\">&#125;, <span class=\"number\">1</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// 从后向前查找，从索引1开始查找，返回3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseFindIndex</span>(<span class=\"params\">array, predicate, fromIndex, fromRight</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = fromIndex + (fromRight ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((fromRight ? index-- : ++index &lt; length)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (predicate(array[index], index, array)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> index</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码再次展示了 lodash 的特点，短小精悍！</p>\n<p>这次读源码我们从里往外看。</p>\n<p>从代码中很容易看到，<code>predicate</code> 是传递进来的函数，在 <code>baseFindIndex</code> 调用该函数，如果返回的结果为真值，则中止查找，返回索引。</p>\n<h3 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h3><p>我们再往外看，看看 <code>while</code> 的循环条件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fromRight ? index-- : ++index &lt; length</span><br></pre></td></tr></table></figure>\n\n<p>现在问题来了，这个三元表达式有两种可能，一种是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(fromRight ? index-- : ++index) &lt; length</span><br></pre></td></tr></table></figure>\n\n<p>一种是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fromRight ? index-- : (++index &lt; length)</span><br></pre></td></tr></table></figure>\n\n<p>究竟是那一种呢？这就要看运算符的优化级了，下面这个表是 MDN 上的截图：</p>\n<p><img src=\"../images/baseFindIndex.png\"></p>\n<p>这个表将优化级划分成了20个级别，数字越大，优化级越高。</p>\n<p>从表中可以看到，比较运算符的优先级为11，而三元表达式（条件运算符）的优化级为4，因此可以确定比较运算符的优先级要比三元表达式的要高，循环条件其实等价于第二种写法。</p>\n<h3 id=\"增减迷局\"><a href=\"#增减迷局\" class=\"headerlink\" title=\"增减迷局\"></a>增减迷局</h3><p>再往上看，可以看到这句代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> index = fromIndex + (fromRight ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在向后查找时， <code>index</code> 减少了1，而向前查找时，<code>index</code> 增加了1，为什么要这样做呢？</p>\n<p>再结合循环条件看下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fromRight ? index-- : ++index &lt; length</span><br></pre></td></tr></table></figure>\n\n<p>在向前查找时，使用的是 <code>index--</code> 表达式的运算结果，向后查找时，使用的是 <code>++index &lt; lenth</code> 表达式的运算结果。</p>\n<p>从上表中也可以看出前缀自增比比较运算符的优化级要高。</p>\n<p>前缀自增返回的是自增后的结果，而在循环条件中就要将索引 <code>index</code> 增加1，这样会忽略掉第一个需要遍历的元素，作为补救，在开始遍历前，需要将 <code>index</code> 减少1。</p>\n<p>同理，在向前查找时，需要将索引增加1，因为在遍历开始时就已经将索引减少1。</p>\n<p>那又为什么向前查找时用的是后缀自减，而不是用前缀自减呢？</p>\n<p>因为在向前查找时，最终要查找到数组索引 <code>0</code> 的位置，后缀自减返回的是自减前的数值，因此当 <code>index</code> 为 <code>1</code> 时，自减后的 <code>index</code> 为 <code>0</code> ，但是在循环条件中依然拿 <code>1</code> 来进行判断，所以使得索引 <code>0</code> 得以进入循环体。</p>\n<p>关于前缀自增/减和后缀自增/减的区别可以看《<a href=\"./assocIndexOf.md\">lodash源码分析之自减的两种形式</a>》。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\">MDN:运算符优先级</a></li>\n</ol>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p><a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>\n<p>最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：  <img src=\"https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg\"> </p>\n<p>作者：对角另一面</p>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h1 id=\"lodash源码分析之baseFindIndex中的运算符优先级\"><a href=\"#lodash源码分析之baseFindIndex中的运算符优先级\" class=\"headerlink\" title=\"lodash源码分析之baseFindIndex中的运算符优先级\"></a>lodash源码分析之baseFindIndex中的运算符优先级</h1><blockquote>\n<p>我悟出权力本来就是不讲理的——蟑螂就是海米；也悟出要造反，内心必须强大到足以承受任何后果才行。</p>\n<p>——北岛《城门开》</p>\n</blockquote>\n<p>本文为读 lodash 源码的第十篇，后续文章会更新到这个仓库中，欢迎 star：<a href=\"https://github.com/yeyuqiudeng/pocket-lodash\">pocket-lodash</a></p>\n<p>gitbook也会同步仓库的更新，gitbook地址：<a href=\"https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details\">pocket-lodash</a></p>\n<h2 id=\"作用与用法\"><a href=\"#作用与用法\" class=\"headerlink\" title=\"作用与用法\"></a>作用与用法</h2><p><code>baseFindIndex</code> 是内部方法，其作用类似于ES6的 <code>findIndex</code>，查找符合条件的第一个元素的索引。</p>\n<p><code>baseFindIndex</code> 除了从前向后查找外，还可以从后向前查找。</p>\n<p>用法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">baseFindIndex([<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val, index, array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val &gt; <span class=\"number\">1</span></span><br><span class=\"line\">&#125;, <span class=\"number\">1</span>) <span class=\"comment\">// 从前向后查找，从索引1开始查找，返回2</span></span><br><span class=\"line\">baseFindIndex([<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val, index, array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> val &gt; <span class=\"number\">1</span></span><br><span class=\"line\">&#125;, <span class=\"number\">1</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// 从后向前查找，从索引1开始查找，返回3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">baseFindIndex</span>(<span class=\"params\">array, predicate, fromIndex, fromRight</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; length &#125; = array</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = fromIndex + (fromRight ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((fromRight ? index-- : ++index &lt; length)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (predicate(array[index], index, array)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> index</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码再次展示了 lodash 的特点，短小精悍！</p>\n<p>这次读源码我们从里往外看。</p>\n<p>从代码中很容易看到，<code>predicate</code> 是传递进来的函数，在 <code>baseFindIndex</code> 调用该函数，如果返回的结果为真值，则中止查找，返回索引。</p>\n<h3 id=\"运算符优先级\"><a href=\"#运算符优先级\" class=\"headerlink\" title=\"运算符优先级\"></a>运算符优先级</h3><p>我们再往外看，看看 <code>while</code> 的循环条件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fromRight ? index-- : ++index &lt; length</span><br></pre></td></tr></table></figure>\n\n<p>现在问题来了，这个三元表达式有两种可能，一种是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(fromRight ? index-- : ++index) &lt; length</span><br></pre></td></tr></table></figure>\n\n<p>一种是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fromRight ? index-- : (++index &lt; length)</span><br></pre></td></tr></table></figure>\n\n<p>究竟是那一种呢？这就要看运算符的优化级了，下面这个表是 MDN 上的截图：</p>\n<p><img src=\"../images/baseFindIndex.png\"></p>\n<p>这个表将优化级划分成了20个级别，数字越大，优化级越高。</p>\n<p>从表中可以看到，比较运算符的优先级为11，而三元表达式（条件运算符）的优化级为4，因此可以确定比较运算符的优先级要比三元表达式的要高，循环条件其实等价于第二种写法。</p>\n<h3 id=\"增减迷局\"><a href=\"#增减迷局\" class=\"headerlink\" title=\"增减迷局\"></a>增减迷局</h3><p>再往上看，可以看到这句代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> index = fromIndex + (fromRight ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n\n<p>在向后查找时， <code>index</code> 减少了1，而向前查找时，<code>index</code> 增加了1，为什么要这样做呢？</p>\n<p>再结合循环条件看下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fromRight ? index-- : ++index &lt; length</span><br></pre></td></tr></table></figure>\n\n<p>在向前查找时，使用的是 <code>index--</code> 表达式的运算结果，向后查找时，使用的是 <code>++index &lt; lenth</code> 表达式的运算结果。</p>\n<p>从上表中也可以看出前缀自增比比较运算符的优化级要高。</p>\n<p>前缀自增返回的是自增后的结果，而在循环条件中就要将索引 <code>index</code> 增加1，这样会忽略掉第一个需要遍历的元素，作为补救，在开始遍历前，需要将 <code>index</code> 减少1。</p>\n<p>同理，在向前查找时，需要将索引增加1，因为在遍历开始时就已经将索引减少1。</p>\n<p>那又为什么向前查找时用的是后缀自减，而不是用前缀自减呢？</p>\n<p>因为在向前查找时，最终要查找到数组索引 <code>0</code> 的位置，后缀自减返回的是自减前的数值，因此当 <code>index</code> 为 <code>1</code> 时，自减后的 <code>index</code> 为 <code>0</code> ，但是在循环条件中依然拿 <code>1</code> 来进行判断，所以使得索引 <code>0</code> 得以进入循环体。</p>\n<p>关于前缀自增/减和后缀自增/减的区别可以看《<a href=\"./assocIndexOf.md\">lodash源码分析之自减的两种形式</a>》。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\">MDN:运算符优先级</a></li>\n</ol>\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p><a href=\"http://creativecommons.org/licenses/by-nc-nd/4.0/\">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>\n<p>最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：  <img src=\"https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg\"> </p>\n<p>作者：对角另一面</p>\n"},{"title":"promise","date":"2021-12-02T16:00:00.000Z","_content":"### 概念\nPromise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。\n\n### promise 有哪三种状态：\npending(等待态)、fulfiled(成功态)、rejected(失败态)\n\n### promise 使用来解决什么问题的？\n回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象\npromise可以支持多个并发的请求，获取并发请求中的数据\n这个promise可以解决异步的问题，本身不能说promise是异步的\n\n### promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\npromise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：  \n- resolve ：异步操作执行成功后的回调函数\n- reject：异步操作执行失败后的回调函数  \n\n```javascript\nlet p = new Promise((resolve, reject) => {\n    //做一些异步操作\n    setTimeout(() => {\n        console.log('执行完成');\n        resolve('我是成功！！');\n    }, 2000);\n});\n```\n\n### then\nthen中可以传递两个参数--请求成功（resolved）的函数和请求失败（reject）的函数\n```javascript\nlet p = new Promise((resolve, reject) => {\n    //做一些异步操作\n  setTimeout(function(){\n        var num = Math.ceil(Math.random()*10); //生成1-10的随机数\n        if(num<=5){\n            resolve(num);\n        }\n        else{\n            reject('数字太大了');\n        }\n  }, 2000);\n});\np.then((data) => {\n        console.log('resolved',data); // resolved 5\n    },(err) => {\n        console.log('rejected',err); // rejected 数字太大了\n    }\n);\n```\n\n### catch的用法\n其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：\n```javascript\np.then((data) => {\n    console.log('resolved',data);\n}).catch((err) => {\n    console.log('rejected',err);\n});\n// 效果和写在then第二个参数里面一样\ncatch会把then中的报错展示出来，例如:\np.then((data) => {\n    console.log('resolved',data);\n    console.log(somedata); //此处的somedata未定义\n})\n.catch((err) => {\n    console.log('rejected',err);\n});\n```\n控制台输出 ： rejected ReferenceError：somedata is not defined at p.then\n与try/catch有相同的功能\n\n### Promise.all\nall 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调，即all中promise 的 resolve 或者 reject执行完了再执行then  \n例：\n```javascript\nlet Promise1 = new Promise(function(resolve, reject){\n    setTimeout(()=>{\n        resolve(console.log(1))\n    },1000)\n})\nlet Promise2 = new Promise(function(resolve, reject){resolve(console.log(2))})\nlet Promise3 = new Promise(function(resolve, reject){resolve(console.log(3))})\nlet p = Promise.all([Promise1, Promise2, Promise3])\np.then(function(){\n    // 三个都成功则成功\n    console.log('aaaaaa')  // 如果promise123 不通过resolve输出，这段话不执行\n}, function(){\n    // 只要有失败，则失败 \n})\n```\nall的作用：\n有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。  \n\n参考： 作者：蔓蔓雒轩  链接：https://juejin.cn/post/6844903607968481287。","source":"_posts/promise.md","raw":"---\ntitle: promise\ndate: 2021-12-03\ncategories:\n- 前端\ntags:\n- javascript\n- promise\n---\n### 概念\nPromise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。\n\n### promise 有哪三种状态：\npending(等待态)、fulfiled(成功态)、rejected(失败态)\n\n### promise 使用来解决什么问题的？\n回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象\npromise可以支持多个并发的请求，获取并发请求中的数据\n这个promise可以解决异步的问题，本身不能说promise是异步的\n\n### promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\npromise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：  \n- resolve ：异步操作执行成功后的回调函数\n- reject：异步操作执行失败后的回调函数  \n\n```javascript\nlet p = new Promise((resolve, reject) => {\n    //做一些异步操作\n    setTimeout(() => {\n        console.log('执行完成');\n        resolve('我是成功！！');\n    }, 2000);\n});\n```\n\n### then\nthen中可以传递两个参数--请求成功（resolved）的函数和请求失败（reject）的函数\n```javascript\nlet p = new Promise((resolve, reject) => {\n    //做一些异步操作\n  setTimeout(function(){\n        var num = Math.ceil(Math.random()*10); //生成1-10的随机数\n        if(num<=5){\n            resolve(num);\n        }\n        else{\n            reject('数字太大了');\n        }\n  }, 2000);\n});\np.then((data) => {\n        console.log('resolved',data); // resolved 5\n    },(err) => {\n        console.log('rejected',err); // rejected 数字太大了\n    }\n);\n```\n\n### catch的用法\n其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：\n```javascript\np.then((data) => {\n    console.log('resolved',data);\n}).catch((err) => {\n    console.log('rejected',err);\n});\n// 效果和写在then第二个参数里面一样\ncatch会把then中的报错展示出来，例如:\np.then((data) => {\n    console.log('resolved',data);\n    console.log(somedata); //此处的somedata未定义\n})\n.catch((err) => {\n    console.log('rejected',err);\n});\n```\n控制台输出 ： rejected ReferenceError：somedata is not defined at p.then\n与try/catch有相同的功能\n\n### Promise.all\nall 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调，即all中promise 的 resolve 或者 reject执行完了再执行then  \n例：\n```javascript\nlet Promise1 = new Promise(function(resolve, reject){\n    setTimeout(()=>{\n        resolve(console.log(1))\n    },1000)\n})\nlet Promise2 = new Promise(function(resolve, reject){resolve(console.log(2))})\nlet Promise3 = new Promise(function(resolve, reject){resolve(console.log(3))})\nlet p = Promise.all([Promise1, Promise2, Promise3])\np.then(function(){\n    // 三个都成功则成功\n    console.log('aaaaaa')  // 如果promise123 不通过resolve输出，这段话不执行\n}, function(){\n    // 只要有失败，则失败 \n})\n```\nall的作用：\n有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。  \n\n参考： 作者：蔓蔓雒轩  链接：https://juejin.cn/post/6844903607968481287。","slug":"promise","published":1,"updated":"2022-01-29T13:58:31.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p6z000nrwh9bwpod3tq","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p>\n<h3 id=\"promise-有哪三种状态：\"><a href=\"#promise-有哪三种状态：\" class=\"headerlink\" title=\"promise 有哪三种状态：\"></a>promise 有哪三种状态：</h3><p>pending(等待态)、fulfiled(成功态)、rejected(失败态)</p>\n<h3 id=\"promise-使用来解决什么问题的？\"><a href=\"#promise-使用来解决什么问题的？\" class=\"headerlink\" title=\"promise 使用来解决什么问题的？\"></a>promise 使用来解决什么问题的？</h3><p>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象<br>promise可以支持多个并发的请求，获取并发请求中的数据<br>这个promise可以解决异步的问题，本身不能说promise是异步的</p>\n<h3 id=\"promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\"><a href=\"#promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\" class=\"headerlink\" title=\"promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\"></a>promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</h3><p>promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：  </p>\n<ul>\n<li>resolve ：异步操作执行成功后的回调函数</li>\n<li>reject：异步操作执行失败后的回调函数  </li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//做一些异步操作</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;执行完成&#x27;</span>);</span><br><span class=\"line\">        resolve(<span class=\"string\">&#x27;我是成功！！&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\"then\"></a>then</h3><p>then中可以传递两个参数–请求成功（resolved）的函数和请求失败（reject）的函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//做一些异步操作</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> num = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random()*<span class=\"number\">10</span>); <span class=\"comment\">//生成1-10的随机数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num&lt;=<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">            resolve(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            reject(<span class=\"string\">&#x27;数字太大了&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;resolved&#x27;</span>,data); <span class=\"comment\">// resolved 5</span></span><br><span class=\"line\">    &#125;,<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;rejected&#x27;</span>,err); <span class=\"comment\">// rejected 数字太大了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"catch的用法\"><a href=\"#catch的用法\" class=\"headerlink\" title=\"catch的用法\"></a>catch的用法</h3><p>其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;resolved&#x27;</span>,data);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;rejected&#x27;</span>,err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 效果和写在then第二个参数里面一样</span></span><br><span class=\"line\"><span class=\"keyword\">catch</span>会把then中的报错展示出来，例如:</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;resolved&#x27;</span>,data);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(somedata); <span class=\"comment\">//此处的somedata未定义</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;rejected&#x27;</span>,err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>控制台输出 ： rejected ReferenceError：somedata is not defined at p.then<br>与try/catch有相同的功能</p>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><p>all 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调，即all中promise 的 resolve 或者 reject执行完了再执行then<br>例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>))</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> Promise2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;resolve(<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>))&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> Promise3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;resolve(<span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>))&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"built_in\">Promise</span>.all([Promise1, Promise2, Promise3])</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 三个都成功则成功</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;aaaaaa&#x27;</span>)  <span class=\"comment\">// 如果promise123 不通过resolve输出，这段话不执行</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只要有失败，则失败 </span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>all的作用：<br>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。  </p>\n<p>参考： 作者：蔓蔓雒轩  链接：<a href=\"https://juejin.cn/post/6844903607968481287%E3%80%82\">https://juejin.cn/post/6844903607968481287。</a></p>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p>\n<h3 id=\"promise-有哪三种状态：\"><a href=\"#promise-有哪三种状态：\" class=\"headerlink\" title=\"promise 有哪三种状态：\"></a>promise 有哪三种状态：</h3><p>pending(等待态)、fulfiled(成功态)、rejected(失败态)</p>\n<h3 id=\"promise-使用来解决什么问题的？\"><a href=\"#promise-使用来解决什么问题的？\" class=\"headerlink\" title=\"promise 使用来解决什么问题的？\"></a>promise 使用来解决什么问题的？</h3><p>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象<br>promise可以支持多个并发的请求，获取并发请求中的数据<br>这个promise可以解决异步的问题，本身不能说promise是异步的</p>\n<h3 id=\"promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\"><a href=\"#promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\" class=\"headerlink\" title=\"promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。\"></a>promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</h3><p>promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：  </p>\n<ul>\n<li>resolve ：异步操作执行成功后的回调函数</li>\n<li>reject：异步操作执行失败后的回调函数  </li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//做一些异步操作</span></span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;执行完成&#x27;</span>);</span><br><span class=\"line\">        resolve(<span class=\"string\">&#x27;我是成功！！&#x27;</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"then\"><a href=\"#then\" class=\"headerlink\" title=\"then\"></a>then</h3><p>then中可以传递两个参数–请求成功（resolved）的函数和请求失败（reject）的函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//做一些异步操作</span></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> num = <span class=\"built_in\">Math</span>.ceil(<span class=\"built_in\">Math</span>.random()*<span class=\"number\">10</span>); <span class=\"comment\">//生成1-10的随机数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num&lt;=<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">            resolve(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            reject(<span class=\"string\">&#x27;数字太大了&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;resolved&#x27;</span>,data); <span class=\"comment\">// resolved 5</span></span><br><span class=\"line\">    &#125;,<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;rejected&#x27;</span>,err); <span class=\"comment\">// rejected 数字太大了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"catch的用法\"><a href=\"#catch的用法\" class=\"headerlink\" title=\"catch的用法\"></a>catch的用法</h3><p>其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;resolved&#x27;</span>,data);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;rejected&#x27;</span>,err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 效果和写在then第二个参数里面一样</span></span><br><span class=\"line\"><span class=\"keyword\">catch</span>会把then中的报错展示出来，例如:</span><br><span class=\"line\">p.then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;resolved&#x27;</span>,data);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(somedata); <span class=\"comment\">//此处的somedata未定义</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;rejected&#x27;</span>,err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>控制台输出 ： rejected ReferenceError：somedata is not defined at p.then<br>与try/catch有相同的功能</p>\n<h3 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all\"></a>Promise.all</h3><p>all 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调，即all中promise 的 resolve 或者 reject执行完了再执行then<br>例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Promise1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        resolve(<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>))</span><br><span class=\"line\">    &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> Promise2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;resolve(<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>))&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> Promise3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>)</span>&#123;resolve(<span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>))&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> p = <span class=\"built_in\">Promise</span>.all([Promise1, Promise2, Promise3])</span><br><span class=\"line\">p.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 三个都成功则成功</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;aaaaaa&#x27;</span>)  <span class=\"comment\">// 如果promise123 不通过resolve输出，这段话不执行</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只要有失败，则失败 </span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>all的作用：<br>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。  </p>\n<p>参考： 作者：蔓蔓雒轩  链接：<a href=\"https://juejin.cn/post/6844903607968481287%E3%80%82\">https://juejin.cn/post/6844903607968481287。</a></p>\n"},{"title":"webpack","cover":false,"_content":"## webpack\n\n### 概念\n![Image text](/images/webpack_01.jpg)\n<center>核心概念脑图</center>\n****\n#### 入口   `entry`\n默认：`./src`\n\n单个入口用法：`entry: string|Array<string>`\n```js\nconst config = {\n  entry: './path/to/my/entry/file.js'\n};\n\n// entry 属性的单个入口语法，是下面的简写：\n\nconst config = {\n  entry: {\n    main: './path/to/my/entry/file.js'\n  }\n};\n```\n\n对象语法：`entry: {[entryChunkName: string]: string|Array<string>}`\n```js\nconst config = {\n  entry: {\n    app: './src/app.js',\n    vendors: './src/vendors.js'\n  }\n};\n```\n#### 输出  `output`\n默认：`./dist`\n用法：\n```js\n// 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包含 filename 和 path\nconst config = {\n  output: {\n    filename: 'bundle.js',\n    path: '/home/proj/public/assets'\n  }\n};\n\nmodule.exports = config;\n```\n**多个起点的情况（使用占位符确保文件具有唯一名称）**\n```js\n{\n  entry: {\n    app: './src/app.js',\n    search: './src/search.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: __dirname + '/dist'\n  }\n}\n// 写入到硬盘：./dist/app.js, ./dist/search.js\n```\n#### 模式  `mode`\n描述：提供 `mode` 配置选项，告知 `webpack` 使用相应模式的内置优化。\n分 `development` 和 `production`\n#### loader\n- 用于处理非 JavaScript 文件，webpack 自身只理解 JavaScript\n- 在 webpack 配置中定义 loader 时，要定义在 module.rules 中\n\n🌰：你可以使用 `loader` 告诉 `webpack` 加载 `CSS` 文件，或者将 `TypeScript` 转为 `JavaScript`。为此，首先安装相对应的 `loader`：\n```shell\nnpm install --save-dev css-loader\nnpm install --save-dev ts-loader\n```\n\n三种方式使用loader\n**配置  `Configuration`**\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.css$/,\n      use: [\n        { loader: 'style-loader' },\n        {\n          loader: 'css-loader',\n          options: {\n            modules: true\n          }\n        }\n      ]\n    }\n  ]\n}\n```\n**内联**\n可以在 import 语句或任何等效于 \"import\" 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。\n```js\nimport Styles from 'style-loader!css-loader?modules!./styles.css';\n```\n**CLI**\n```js\nwebpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'\n```\n这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。\n#### 插件  `plugins`","source":"_posts/webpack.md","raw":"---\ntitle: webpack\ncover: false\ncategories:\n- 前端\ntags:\n- webpack\n---\n## webpack\n\n### 概念\n![Image text](/images/webpack_01.jpg)\n<center>核心概念脑图</center>\n****\n#### 入口   `entry`\n默认：`./src`\n\n单个入口用法：`entry: string|Array<string>`\n```js\nconst config = {\n  entry: './path/to/my/entry/file.js'\n};\n\n// entry 属性的单个入口语法，是下面的简写：\n\nconst config = {\n  entry: {\n    main: './path/to/my/entry/file.js'\n  }\n};\n```\n\n对象语法：`entry: {[entryChunkName: string]: string|Array<string>}`\n```js\nconst config = {\n  entry: {\n    app: './src/app.js',\n    vendors: './src/vendors.js'\n  }\n};\n```\n#### 输出  `output`\n默认：`./dist`\n用法：\n```js\n// 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包含 filename 和 path\nconst config = {\n  output: {\n    filename: 'bundle.js',\n    path: '/home/proj/public/assets'\n  }\n};\n\nmodule.exports = config;\n```\n**多个起点的情况（使用占位符确保文件具有唯一名称）**\n```js\n{\n  entry: {\n    app: './src/app.js',\n    search: './src/search.js'\n  },\n  output: {\n    filename: '[name].js',\n    path: __dirname + '/dist'\n  }\n}\n// 写入到硬盘：./dist/app.js, ./dist/search.js\n```\n#### 模式  `mode`\n描述：提供 `mode` 配置选项，告知 `webpack` 使用相应模式的内置优化。\n分 `development` 和 `production`\n#### loader\n- 用于处理非 JavaScript 文件，webpack 自身只理解 JavaScript\n- 在 webpack 配置中定义 loader 时，要定义在 module.rules 中\n\n🌰：你可以使用 `loader` 告诉 `webpack` 加载 `CSS` 文件，或者将 `TypeScript` 转为 `JavaScript`。为此，首先安装相对应的 `loader`：\n```shell\nnpm install --save-dev css-loader\nnpm install --save-dev ts-loader\n```\n\n三种方式使用loader\n**配置  `Configuration`**\n```js\nmodule: {\n  rules: [\n    {\n      test: /\\.css$/,\n      use: [\n        { loader: 'style-loader' },\n        {\n          loader: 'css-loader',\n          options: {\n            modules: true\n          }\n        }\n      ]\n    }\n  ]\n}\n```\n**内联**\n可以在 import 语句或任何等效于 \"import\" 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。\n```js\nimport Styles from 'style-loader!css-loader?modules!./styles.css';\n```\n**CLI**\n```js\nwebpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'\n```\n这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。\n#### 插件  `plugins`","slug":"webpack","published":1,"date":"2022-01-29T13:00:06.723Z","updated":"2022-01-29T14:17:55.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p6z000prwh9c80wckex","content":"<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p><img src=\"/images/webpack_01.jpg\" alt=\"Image text\"></p>\n<center>核心概念脑图</center>\n****\n#### 入口   `entry`\n默认：`./src`\n\n<p>单个入口用法：<code>entry: string|Array&lt;string&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// entry 属性的单个入口语法，是下面的简写：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">main</span>: <span class=\"string\">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对象语法：<code>entry: &#123;[entryChunkName: string]: string|Array&lt;string&gt;&#125;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">&#x27;./src/app.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">vendors</span>: <span class=\"string\">&#x27;./src/vendors.js&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出-output\"><a href=\"#输出-output\" class=\"headerlink\" title=\"输出  output\"></a>输出  <code>output</code></h4><p>默认：<code>./dist</code><br>用法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包含 filename 和 path</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;bundle.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/home/proj/public/assets&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<p><strong>多个起点的情况（使用占位符确保文件具有唯一名称）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">&#x27;./src/app.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">search</span>: <span class=\"string\">&#x27;./src/search.js&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;[name].js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">path</span>: __dirname + <span class=\"string\">&#x27;/dist&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"模式-mode\"><a href=\"#模式-mode\" class=\"headerlink\" title=\"模式  mode\"></a>模式  <code>mode</code></h4><p>描述：提供 <code>mode</code> 配置选项，告知 <code>webpack</code> 使用相应模式的内置优化。<br>分 <code>development</code> 和 <code>production</code></p>\n<h4 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h4><ul>\n<li>用于处理非 JavaScript 文件，webpack 自身只理解 JavaScript</li>\n<li>在 webpack 配置中定义 loader 时，要定义在 module.rules 中</li>\n</ul>\n<p>🌰：你可以使用 <code>loader</code> 告诉 <code>webpack</code> 加载 <code>CSS</code> 文件，或者将 <code>TypeScript</code> 转为 <code>JavaScript</code>。为此，首先安装相对应的 <code>loader</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev css-loader</span><br><span class=\"line\">npm install --save-dev ts-loader</span><br></pre></td></tr></table></figure>\n\n<p>三种方式使用loader<br><strong>配置  <code>Configuration</code></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">      use: [</span><br><span class=\"line\">        &#123; <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">modules</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>内联</strong><br>可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Styles <span class=\"keyword\">from</span> <span class=\"string\">&#x27;style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>CLI</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --<span class=\"built_in\">module</span>-bind jade-loader --<span class=\"built_in\">module</span>-bind <span class=\"string\">&#x27;css=style-loader!css-loader&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。</p>\n<h4 id=\"插件-plugins\"><a href=\"#插件-plugins\" class=\"headerlink\" title=\"插件  plugins\"></a>插件  <code>plugins</code></h4>","site":{"data":{}},"randomcover":"/images/home.JPG","excerpt":"","more":"<h2 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p><img src=\"/images/webpack_01.jpg\" alt=\"Image text\"></p>\n<center>核心概念脑图</center>\n****\n#### 入口   `entry`\n默认：`./src`\n\n<p>单个入口用法：<code>entry: string|Array&lt;string&gt;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// entry 属性的单个入口语法，是下面的简写：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">main</span>: <span class=\"string\">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对象语法：<code>entry: &#123;[entryChunkName: string]: string|Array&lt;string&gt;&#125;</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">&#x27;./src/app.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">vendors</span>: <span class=\"string\">&#x27;./src/vendors.js&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出-output\"><a href=\"#输出-output\" class=\"headerlink\" title=\"输出  output\"></a>输出  <code>output</code></h4><p>默认：<code>./dist</code><br>用法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包含 filename 和 path</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> config = &#123;</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;bundle.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">path</span>: <span class=\"string\">&#x27;/home/proj/public/assets&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = config;</span><br></pre></td></tr></table></figure>\n<p><strong>多个起点的情况（使用占位符确保文件具有唯一名称）</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">&#x27;./src/app.js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">search</span>: <span class=\"string\">&#x27;./src/search.js&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;[name].js&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">path</span>: __dirname + <span class=\"string\">&#x27;/dist&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"模式-mode\"><a href=\"#模式-mode\" class=\"headerlink\" title=\"模式  mode\"></a>模式  <code>mode</code></h4><p>描述：提供 <code>mode</code> 配置选项，告知 <code>webpack</code> 使用相应模式的内置优化。<br>分 <code>development</code> 和 <code>production</code></p>\n<h4 id=\"loader\"><a href=\"#loader\" class=\"headerlink\" title=\"loader\"></a>loader</h4><ul>\n<li>用于处理非 JavaScript 文件，webpack 自身只理解 JavaScript</li>\n<li>在 webpack 配置中定义 loader 时，要定义在 module.rules 中</li>\n</ul>\n<p>🌰：你可以使用 <code>loader</code> 告诉 <code>webpack</code> 加载 <code>CSS</code> 文件，或者将 <code>TypeScript</code> 转为 <code>JavaScript</code>。为此，首先安装相对应的 <code>loader</code>：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev css-loader</span><br><span class=\"line\">npm install --save-dev ts-loader</span><br></pre></td></tr></table></figure>\n\n<p>三种方式使用loader<br><strong>配置  <code>Configuration</code></strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">rules</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.css$/</span>,</span><br><span class=\"line\">      use: [</span><br><span class=\"line\">        &#123; <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">loader</span>: <span class=\"string\">&#x27;css-loader&#x27;</span>,</span><br><span class=\"line\">          <span class=\"attr\">options</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">modules</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>内联</strong><br>可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Styles <span class=\"keyword\">from</span> <span class=\"string\">&#x27;style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><strong>CLI</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --<span class=\"built_in\">module</span>-bind jade-loader --<span class=\"built_in\">module</span>-bind <span class=\"string\">&#x27;css=style-loader!css-loader&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。</p>\n<h4 id=\"插件-plugins\"><a href=\"#插件-plugins\" class=\"headerlink\" title=\"插件  plugins\"></a>插件  <code>plugins</code></h4>"},{"title":"yarn和npm命令对比","date":"2022-01-24T16:00:00.000Z","_content":"```js\nnpm                                     yarn\n\nnpm init                                yarn init              // 初始化\nnpm i | install                         yarn  (install)        // 安装依赖包\nnpm i x --S | --save                    yarn add  x            // 安装生产依赖并保存包名\nnpm i x --D | --save-dev                yarn add x -D          // 安装开发依赖并保存包名\nnpm un | uninstall  x                   yarn remove            // 删除依赖包\nnpm i -g | npm -g i x                   yarn global add x      // 全局安装\nnpm un -g x                             yarn global remove x   // 全局下载\nnpm run dev                             yarn dev | run dev     // 运行命令\n```","source":"_posts/yarn和npm命令对比.md","raw":"---\ntitle: yarn和npm命令对比\ndate: 2022-1-25\n---\n```js\nnpm                                     yarn\n\nnpm init                                yarn init              // 初始化\nnpm i | install                         yarn  (install)        // 安装依赖包\nnpm i x --S | --save                    yarn add  x            // 安装生产依赖并保存包名\nnpm i x --D | --save-dev                yarn add x -D          // 安装开发依赖并保存包名\nnpm un | uninstall  x                   yarn remove            // 删除依赖包\nnpm i -g | npm -g i x                   yarn global add x      // 全局安装\nnpm un -g x                             yarn global remove x   // 全局下载\nnpm run dev                             yarn dev | run dev     // 运行命令\n```","slug":"yarn和npm命令对比","published":1,"updated":"2022-01-29T13:13:26.165Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p71000trwh93t877lif","content":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm                                     yarn</span><br><span class=\"line\"></span><br><span class=\"line\">npm init                                yarn init              <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">npm i | install                         yarn  (install)        <span class=\"comment\">// 安装依赖包</span></span><br><span class=\"line\">npm i x --S | --save                    yarn add  x            <span class=\"comment\">// 安装生产依赖并保存包名</span></span><br><span class=\"line\">npm i x --D | --save-dev                yarn add x -D          <span class=\"comment\">// 安装开发依赖并保存包名</span></span><br><span class=\"line\">npm un | uninstall  x                   yarn remove            <span class=\"comment\">// 删除依赖包</span></span><br><span class=\"line\">npm i -g | npm -g i x                   yarn <span class=\"built_in\">global</span> add x      <span class=\"comment\">// 全局安装</span></span><br><span class=\"line\">npm un -g x                             yarn <span class=\"built_in\">global</span> remove x   <span class=\"comment\">// 全局下载</span></span><br><span class=\"line\">npm run dev                             yarn dev | run dev     <span class=\"comment\">// 运行命令</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm                                     yarn</span><br><span class=\"line\"></span><br><span class=\"line\">npm init                                yarn init              <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">npm i | install                         yarn  (install)        <span class=\"comment\">// 安装依赖包</span></span><br><span class=\"line\">npm i x --S | --save                    yarn add  x            <span class=\"comment\">// 安装生产依赖并保存包名</span></span><br><span class=\"line\">npm i x --D | --save-dev                yarn add x -D          <span class=\"comment\">// 安装开发依赖并保存包名</span></span><br><span class=\"line\">npm un | uninstall  x                   yarn remove            <span class=\"comment\">// 删除依赖包</span></span><br><span class=\"line\">npm i -g | npm -g i x                   yarn <span class=\"built_in\">global</span> add x      <span class=\"comment\">// 全局安装</span></span><br><span class=\"line\">npm un -g x                             yarn <span class=\"built_in\">global</span> remove x   <span class=\"comment\">// 全局下载</span></span><br><span class=\"line\">npm run dev                             yarn dev | run dev     <span class=\"comment\">// 运行命令</span></span><br></pre></td></tr></table></figure>"},{"title":"事件循环Eventloop","date":"2021-09-06T16:00:00.000Z","_content":"### 1. javascript是单线程语言\n### 2. 所有的线程，都是有同步队列，和异步队列\n立即执行，如函数 是同步；promise，ajax为异步\n### 3. 任务队列-事件循环\n同步任务会立刻执行，进入到主线程当中，异步任务会被放到任务队列（Event Queue）当中。  \n等待同步代码执行完毕后，返回来，再将异步中的任务放到主线程中执行,反复这样的循环，这就是事件循环。也就是先执行同步，返回来按照异步的顺序再次执行\n### 4. 宏观任务和微观任务（先执行微观任务，再执行宏观任务）\n宏观任务主要包含：setTimeout、setInterval、script(整体代码)、I/O、UI 交互事件、setImmediate(Node.js 环境)  \n微观任务主要包括：Promise、MutaionObserver、process.nextTick(Node.js 环境)","source":"_posts/事件循环EventLoop.md","raw":"---\ntitle: 事件循环Eventloop\ndate: 2021-09-07\ncategories:\n- 前端\ntags:\n- javascript\n---\n### 1. javascript是单线程语言\n### 2. 所有的线程，都是有同步队列，和异步队列\n立即执行，如函数 是同步；promise，ajax为异步\n### 3. 任务队列-事件循环\n同步任务会立刻执行，进入到主线程当中，异步任务会被放到任务队列（Event Queue）当中。  \n等待同步代码执行完毕后，返回来，再将异步中的任务放到主线程中执行,反复这样的循环，这就是事件循环。也就是先执行同步，返回来按照异步的顺序再次执行\n### 4. 宏观任务和微观任务（先执行微观任务，再执行宏观任务）\n宏观任务主要包含：setTimeout、setInterval、script(整体代码)、I/O、UI 交互事件、setImmediate(Node.js 环境)  \n微观任务主要包括：Promise、MutaionObserver、process.nextTick(Node.js 环境)","slug":"事件循环EventLoop","published":1,"updated":"2022-01-29T13:56:32.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p72000wrwh9a2y8dqrb","content":"<h3 id=\"1-javascript是单线程语言\"><a href=\"#1-javascript是单线程语言\" class=\"headerlink\" title=\"1. javascript是单线程语言\"></a>1. javascript是单线程语言</h3><h3 id=\"2-所有的线程，都是有同步队列，和异步队列\"><a href=\"#2-所有的线程，都是有同步队列，和异步队列\" class=\"headerlink\" title=\"2. 所有的线程，都是有同步队列，和异步队列\"></a>2. 所有的线程，都是有同步队列，和异步队列</h3><p>立即执行，如函数 是同步；promise，ajax为异步</p>\n<h3 id=\"3-任务队列-事件循环\"><a href=\"#3-任务队列-事件循环\" class=\"headerlink\" title=\"3. 任务队列-事件循环\"></a>3. 任务队列-事件循环</h3><p>同步任务会立刻执行，进入到主线程当中，异步任务会被放到任务队列（Event Queue）当中。<br>等待同步代码执行完毕后，返回来，再将异步中的任务放到主线程中执行,反复这样的循环，这就是事件循环。也就是先执行同步，返回来按照异步的顺序再次执行</p>\n<h3 id=\"4-宏观任务和微观任务（先执行微观任务，再执行宏观任务）\"><a href=\"#4-宏观任务和微观任务（先执行微观任务，再执行宏观任务）\" class=\"headerlink\" title=\"4. 宏观任务和微观任务（先执行微观任务，再执行宏观任务）\"></a>4. 宏观任务和微观任务（先执行微观任务，再执行宏观任务）</h3><p>宏观任务主要包含：setTimeout、setInterval、script(整体代码)、I/O、UI 交互事件、setImmediate(Node.js 环境)<br>微观任务主要包括：Promise、MutaionObserver、process.nextTick(Node.js 环境)</p>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h3 id=\"1-javascript是单线程语言\"><a href=\"#1-javascript是单线程语言\" class=\"headerlink\" title=\"1. javascript是单线程语言\"></a>1. javascript是单线程语言</h3><h3 id=\"2-所有的线程，都是有同步队列，和异步队列\"><a href=\"#2-所有的线程，都是有同步队列，和异步队列\" class=\"headerlink\" title=\"2. 所有的线程，都是有同步队列，和异步队列\"></a>2. 所有的线程，都是有同步队列，和异步队列</h3><p>立即执行，如函数 是同步；promise，ajax为异步</p>\n<h3 id=\"3-任务队列-事件循环\"><a href=\"#3-任务队列-事件循环\" class=\"headerlink\" title=\"3. 任务队列-事件循环\"></a>3. 任务队列-事件循环</h3><p>同步任务会立刻执行，进入到主线程当中，异步任务会被放到任务队列（Event Queue）当中。<br>等待同步代码执行完毕后，返回来，再将异步中的任务放到主线程中执行,反复这样的循环，这就是事件循环。也就是先执行同步，返回来按照异步的顺序再次执行</p>\n<h3 id=\"4-宏观任务和微观任务（先执行微观任务，再执行宏观任务）\"><a href=\"#4-宏观任务和微观任务（先执行微观任务，再执行宏观任务）\" class=\"headerlink\" title=\"4. 宏观任务和微观任务（先执行微观任务，再执行宏观任务）\"></a>4. 宏观任务和微观任务（先执行微观任务，再执行宏观任务）</h3><p>宏观任务主要包含：setTimeout、setInterval、script(整体代码)、I/O、UI 交互事件、setImmediate(Node.js 环境)<br>微观任务主要包括：Promise、MutaionObserver、process.nextTick(Node.js 环境)</p>\n"},{"title":"地址","date":"2021-12-02T16:00:00.000Z","_content":"## Blog\nHongwei Blog： https://yin-hongwei.github.io/  \n飞鸟：https://lzxjack.top/  \nHexo 博客主题个性化：https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/\n\n## UI框架\n### 1.Soybean Admin\n简介：Soybean Admin 是一个基于 Vue3、Vite、Naive UI、TypeScript 的中后台解决方案，它使用了最新的前端技术栈，并提炼了典型的业务模型，页面，包括二次封装组件、动态菜单、权限校验、粒子化权限控制等功能，它可以帮助你快速搭建企业级中后台项目，相信不管是从新技术使用还是其他方面，都能帮助到你。  \n地址：https://github.com/honghuangdc/soybean-admin\n\n## CSS 样式类\n1.渐变按钮 https://gradientbuttons.colorion.co/\n\n## icon\n1.xicons https://www.xicons.org/#/","source":"_posts/地址.md","raw":"---\ntitle: 地址\ndate: 2021-12-03\ncategories:\n- 杂\ntags:\n- 网站\n---\n## Blog\nHongwei Blog： https://yin-hongwei.github.io/  \n飞鸟：https://lzxjack.top/  \nHexo 博客主题个性化：https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/\n\n## UI框架\n### 1.Soybean Admin\n简介：Soybean Admin 是一个基于 Vue3、Vite、Naive UI、TypeScript 的中后台解决方案，它使用了最新的前端技术栈，并提炼了典型的业务模型，页面，包括二次封装组件、动态菜单、权限校验、粒子化权限控制等功能，它可以帮助你快速搭建企业级中后台项目，相信不管是从新技术使用还是其他方面，都能帮助到你。  \n地址：https://github.com/honghuangdc/soybean-admin\n\n## CSS 样式类\n1.渐变按钮 https://gradientbuttons.colorion.co/\n\n## icon\n1.xicons https://www.xicons.org/#/","slug":"地址","published":1,"updated":"2022-01-29T13:55:08.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p730010rwh9d92x1mtn","content":"<h2 id=\"Blog\"><a href=\"#Blog\" class=\"headerlink\" title=\"Blog\"></a>Blog</h2><p>Hongwei Blog： <a href=\"https://yin-hongwei.github.io/\">https://yin-hongwei.github.io/</a><br>飞鸟：<a href=\"https://lzxjack.top/\">https://lzxjack.top/</a><br>Hexo 博客主题个性化：<a href=\"https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/\">https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/</a></p>\n<h2 id=\"UI框架\"><a href=\"#UI框架\" class=\"headerlink\" title=\"UI框架\"></a>UI框架</h2><h3 id=\"1-Soybean-Admin\"><a href=\"#1-Soybean-Admin\" class=\"headerlink\" title=\"1.Soybean Admin\"></a>1.Soybean Admin</h3><p>简介：Soybean Admin 是一个基于 Vue3、Vite、Naive UI、TypeScript 的中后台解决方案，它使用了最新的前端技术栈，并提炼了典型的业务模型，页面，包括二次封装组件、动态菜单、权限校验、粒子化权限控制等功能，它可以帮助你快速搭建企业级中后台项目，相信不管是从新技术使用还是其他方面，都能帮助到你。<br>地址：<a href=\"https://github.com/honghuangdc/soybean-admin\">https://github.com/honghuangdc/soybean-admin</a></p>\n<h2 id=\"CSS-样式类\"><a href=\"#CSS-样式类\" class=\"headerlink\" title=\"CSS 样式类\"></a>CSS 样式类</h2><p>1.渐变按钮 <a href=\"https://gradientbuttons.colorion.co/\">https://gradientbuttons.colorion.co/</a></p>\n<h2 id=\"icon\"><a href=\"#icon\" class=\"headerlink\" title=\"icon\"></a>icon</h2><p>1.xicons <a href=\"https://www.xicons.org/#/\">https://www.xicons.org/#/</a></p>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h2 id=\"Blog\"><a href=\"#Blog\" class=\"headerlink\" title=\"Blog\"></a>Blog</h2><p>Hongwei Blog： <a href=\"https://yin-hongwei.github.io/\">https://yin-hongwei.github.io/</a><br>飞鸟：<a href=\"https://lzxjack.top/\">https://lzxjack.top/</a><br>Hexo 博客主题个性化：<a href=\"https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/\">https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/</a></p>\n<h2 id=\"UI框架\"><a href=\"#UI框架\" class=\"headerlink\" title=\"UI框架\"></a>UI框架</h2><h3 id=\"1-Soybean-Admin\"><a href=\"#1-Soybean-Admin\" class=\"headerlink\" title=\"1.Soybean Admin\"></a>1.Soybean Admin</h3><p>简介：Soybean Admin 是一个基于 Vue3、Vite、Naive UI、TypeScript 的中后台解决方案，它使用了最新的前端技术栈，并提炼了典型的业务模型，页面，包括二次封装组件、动态菜单、权限校验、粒子化权限控制等功能，它可以帮助你快速搭建企业级中后台项目，相信不管是从新技术使用还是其他方面，都能帮助到你。<br>地址：<a href=\"https://github.com/honghuangdc/soybean-admin\">https://github.com/honghuangdc/soybean-admin</a></p>\n<h2 id=\"CSS-样式类\"><a href=\"#CSS-样式类\" class=\"headerlink\" title=\"CSS 样式类\"></a>CSS 样式类</h2><p>1.渐变按钮 <a href=\"https://gradientbuttons.colorion.co/\">https://gradientbuttons.colorion.co/</a></p>\n<h2 id=\"icon\"><a href=\"#icon\" class=\"headerlink\" title=\"icon\"></a>icon</h2><p>1.xicons <a href=\"https://www.xicons.org/#/\">https://www.xicons.org/#/</a></p>\n"},{"title":"移位运算符","date":"2021-12-14T16:00:00.000Z","_content":"## # 简述\n> 移位运算就是对二进制进行有规律低移位\n## # “<<”运算符\n> “<<”运算符执行左移位运算。在移位运算过程中，符号位始终保持不变。如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃。\n\n```javascript\nconsole.log(5 << 2);  // 返回值20\n```\n## # “>>”运算符\n>“>>”运算符执行有符号右移位运算。与左移运算操作相反，它把 32 位数字中的所有有效位整体右移，再使用符号位的值填充空位。移动过程中超出的值将被丢弃。\n\n```javascript\nconsole.log(1000 >> 8);  // 返回值3\nconsole.log(-1000 >> 8);  //返回值 -4，负数涉及二进制的原码、反码、补码\n```\n\n## # “>>>”运算符\n>“>>>”运算符执行五符号右移位运算。它把无符号的 32 位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的。\n```javascript\nconsole.log(1000 >> 8);  //返回值3\nconsole.log(1000 >> 8);  //返回值3\n```\n>对于负数来说，无符号右移将使用 0 来填充所有的空位，同时会把负数作为正数来处理，所得结果会非常大所以，使用无符号右移运算符时要特别小心，避免意外错误。\n\n## # something >>> 0\n`>>>` 确保 `something` 为整数或0。","source":"_posts/移位运算符.md","raw":"---\ntitle: 移位运算符\ndate: 2021-12-15\ncategories:\n- 前端\ntags:\n- javascript\n---\n## # 简述\n> 移位运算就是对二进制进行有规律低移位\n## # “<<”运算符\n> “<<”运算符执行左移位运算。在移位运算过程中，符号位始终保持不变。如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃。\n\n```javascript\nconsole.log(5 << 2);  // 返回值20\n```\n## # “>>”运算符\n>“>>”运算符执行有符号右移位运算。与左移运算操作相反，它把 32 位数字中的所有有效位整体右移，再使用符号位的值填充空位。移动过程中超出的值将被丢弃。\n\n```javascript\nconsole.log(1000 >> 8);  // 返回值3\nconsole.log(-1000 >> 8);  //返回值 -4，负数涉及二进制的原码、反码、补码\n```\n\n## # “>>>”运算符\n>“>>>”运算符执行五符号右移位运算。它把无符号的 32 位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的。\n```javascript\nconsole.log(1000 >> 8);  //返回值3\nconsole.log(1000 >> 8);  //返回值3\n```\n>对于负数来说，无符号右移将使用 0 来填充所有的空位，同时会把负数作为正数来处理，所得结果会非常大所以，使用无符号右移运算符时要特别小心，避免意外错误。\n\n## # something >>> 0\n`>>>` 确保 `something` 为整数或0。","slug":"移位运算符","published":1,"updated":"2022-01-29T13:56:40.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p740013rwh9ba6oam9m","content":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"# 简述\"></a># 简述</h2><blockquote>\n<p>移位运算就是对二进制进行有规律低移位</p>\n</blockquote>\n<h2 id=\"“-lt-lt-”运算符\"><a href=\"#“-lt-lt-”运算符\" class=\"headerlink\" title=\"# “&lt;&lt;”运算符\"></a># “&lt;&lt;”运算符</h2><blockquote>\n<p>“&lt;&lt;”运算符执行左移位运算。在移位运算过程中，符号位始终保持不变。如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">5</span> &lt;&lt; <span class=\"number\">2</span>);  <span class=\"comment\">// 返回值20</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"“-gt-gt-”运算符\"><a href=\"#“-gt-gt-”运算符\" class=\"headerlink\" title=\"# “&gt;&gt;”运算符\"></a># “&gt;&gt;”运算符</h2><blockquote>\n<p>“&gt;&gt;”运算符执行有符号右移位运算。与左移运算操作相反，它把 32 位数字中的所有有效位整体右移，再使用符号位的值填充空位。移动过程中超出的值将被丢弃。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1000</span> &gt;&gt; <span class=\"number\">8</span>);  <span class=\"comment\">// 返回值3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(-<span class=\"number\">1000</span> &gt;&gt; <span class=\"number\">8</span>);  <span class=\"comment\">//返回值 -4，负数涉及二进制的原码、反码、补码</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"“-gt-gt-gt-”运算符\"><a href=\"#“-gt-gt-gt-”运算符\" class=\"headerlink\" title=\"# “&gt;&gt;&gt;”运算符\"></a># “&gt;&gt;&gt;”运算符</h2><blockquote>\n<p>“&gt;&gt;&gt;”运算符执行五符号右移位运算。它把无符号的 32 位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1000</span> &gt;&gt; <span class=\"number\">8</span>);  <span class=\"comment\">//返回值3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1000</span> &gt;&gt; <span class=\"number\">8</span>);  <span class=\"comment\">//返回值3</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于负数来说，无符号右移将使用 0 来填充所有的空位，同时会把负数作为正数来处理，所得结果会非常大所以，使用无符号右移运算符时要特别小心，避免意外错误。</p>\n</blockquote>\n<h2 id=\"something-gt-gt-gt-0\"><a href=\"#something-gt-gt-gt-0\" class=\"headerlink\" title=\"# something &gt;&gt;&gt; 0\"></a># something &gt;&gt;&gt; 0</h2><p><code>&gt;&gt;&gt;</code> 确保 <code>something</code> 为整数或0。</p>\n","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"# 简述\"></a># 简述</h2><blockquote>\n<p>移位运算就是对二进制进行有规律低移位</p>\n</blockquote>\n<h2 id=\"“-lt-lt-”运算符\"><a href=\"#“-lt-lt-”运算符\" class=\"headerlink\" title=\"# “&lt;&lt;”运算符\"></a># “&lt;&lt;”运算符</h2><blockquote>\n<p>“&lt;&lt;”运算符执行左移位运算。在移位运算过程中，符号位始终保持不变。如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">5</span> &lt;&lt; <span class=\"number\">2</span>);  <span class=\"comment\">// 返回值20</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"“-gt-gt-”运算符\"><a href=\"#“-gt-gt-”运算符\" class=\"headerlink\" title=\"# “&gt;&gt;”运算符\"></a># “&gt;&gt;”运算符</h2><blockquote>\n<p>“&gt;&gt;”运算符执行有符号右移位运算。与左移运算操作相反，它把 32 位数字中的所有有效位整体右移，再使用符号位的值填充空位。移动过程中超出的值将被丢弃。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1000</span> &gt;&gt; <span class=\"number\">8</span>);  <span class=\"comment\">// 返回值3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(-<span class=\"number\">1000</span> &gt;&gt; <span class=\"number\">8</span>);  <span class=\"comment\">//返回值 -4，负数涉及二进制的原码、反码、补码</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"“-gt-gt-gt-”运算符\"><a href=\"#“-gt-gt-gt-”运算符\" class=\"headerlink\" title=\"# “&gt;&gt;&gt;”运算符\"></a># “&gt;&gt;&gt;”运算符</h2><blockquote>\n<p>“&gt;&gt;&gt;”运算符执行五符号右移位运算。它把无符号的 32 位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1000</span> &gt;&gt; <span class=\"number\">8</span>);  <span class=\"comment\">//返回值3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1000</span> &gt;&gt; <span class=\"number\">8</span>);  <span class=\"comment\">//返回值3</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于负数来说，无符号右移将使用 0 来填充所有的空位，同时会把负数作为正数来处理，所得结果会非常大所以，使用无符号右移运算符时要特别小心，避免意外错误。</p>\n</blockquote>\n<h2 id=\"something-gt-gt-gt-0\"><a href=\"#something-gt-gt-gt-0\" class=\"headerlink\" title=\"# something &gt;&gt;&gt; 0\"></a># something &gt;&gt;&gt; 0</h2><p><code>&gt;&gt;&gt;</code> 确保 <code>something</code> 为整数或0。</p>\n"},{"title":"箭头函数的部分简写方式","date":"2021-06-22T16:00:00.000Z","_content":"### 简写一\n参数列表只有单个参数时，左边括号（）可以省去\n```javascript\n(singleParam) => { statements }\n// 等价于\nsingleParam => { statements }\n```\n### 简写二\n函数体是返回一个表达式的值时，右边大括号 {} 可以省去\n```javascript\n(param1, param2) => {\n\t return param1 + param2;\n}\n// 等价于\n(param1, param2)=> param1 + param2\n\n// 或者返回一个字符串，布尔值\nconst func1 = param1 => true\n```\n### 简写三\n返回一个对象\n```javascript\n(x) => { return {'name':x}; }\n// 等价于\n(x) => ({'name':x})\n```","source":"_posts/箭头函数的部分简写方式.md","raw":"---\ntitle: 箭头函数的部分简写方式\ndate: 2021-06-23\ncategories:\n- 前端\ntags:\n- javascript\n- 箭头函数\n---\n### 简写一\n参数列表只有单个参数时，左边括号（）可以省去\n```javascript\n(singleParam) => { statements }\n// 等价于\nsingleParam => { statements }\n```\n### 简写二\n函数体是返回一个表达式的值时，右边大括号 {} 可以省去\n```javascript\n(param1, param2) => {\n\t return param1 + param2;\n}\n// 等价于\n(param1, param2)=> param1 + param2\n\n// 或者返回一个字符串，布尔值\nconst func1 = param1 => true\n```\n### 简写三\n返回一个对象\n```javascript\n(x) => { return {'name':x}; }\n// 等价于\n(x) => ({'name':x})\n```","slug":"箭头函数的部分简写方式","published":1,"updated":"2022-01-29T13:56:15.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckyzx5p750016rwh9e4pd46g5","content":"<h3 id=\"简写一\"><a href=\"#简写一\" class=\"headerlink\" title=\"简写一\"></a>简写一</h3><p>参数列表只有单个参数时，左边括号（）可以省去</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(singleParam) =&gt; &#123; statements &#125;</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">singleParam =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简写二\"><a href=\"#简写二\" class=\"headerlink\" title=\"简写二\"></a>简写二</h3><p>函数体是返回一个表达式的值时，右边大括号 {} 可以省去</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(param1, param2) =&gt; &#123;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> param1 + param2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">(param1, param2)=&gt; param1 + param2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者返回一个字符串，布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> func1 = <span class=\"function\"><span class=\"params\">param1</span> =&gt;</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"简写三\"><a href=\"#简写三\" class=\"headerlink\" title=\"简写三\"></a>简写三</h3><p>返回一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(x) =&gt; &#123; <span class=\"keyword\">return</span> &#123;<span class=\"string\">&#x27;name&#x27;</span>:x&#125;; &#125;</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">(x) =&gt; (&#123;<span class=\"string\">&#x27;name&#x27;</span>:x&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"/images/home.JPG","excerpt":"","more":"<h3 id=\"简写一\"><a href=\"#简写一\" class=\"headerlink\" title=\"简写一\"></a>简写一</h3><p>参数列表只有单个参数时，左边括号（）可以省去</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(singleParam) =&gt; &#123; statements &#125;</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">singleParam =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简写二\"><a href=\"#简写二\" class=\"headerlink\" title=\"简写二\"></a>简写二</h3><p>函数体是返回一个表达式的值时，右边大括号 {} 可以省去</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(param1, param2) =&gt; &#123;</span><br><span class=\"line\">\t <span class=\"keyword\">return</span> param1 + param2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">(param1, param2)=&gt; param1 + param2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者返回一个字符串，布尔值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> func1 = <span class=\"function\"><span class=\"params\">param1</span> =&gt;</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"简写三\"><a href=\"#简写三\" class=\"headerlink\" title=\"简写三\"></a>简写三</h3><p>返回一个对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(x) =&gt; &#123; <span class=\"keyword\">return</span> &#123;<span class=\"string\">&#x27;name&#x27;</span>:x&#125;; &#125;</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">(x) =&gt; (&#123;<span class=\"string\">&#x27;name&#x27;</span>:x&#125;)</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckyzx5p670001rwh9g1kr9yxv","category_id":"ckyzx5p6h0004rwh96nrp54j4","_id":"ckyzx5p6u000drwh93435biq1"},{"post_id":"ckyzx5p6t000brwh9ft3cd163","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p6y000jrwh92rix7d0l"},{"post_id":"ckyzx5p6b0003rwh99knv34in","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p6z000orwh998d2415n"},{"post_id":"ckyzx5p6u000crwh9gh1vbd7e","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p70000qrwh90bqkbzkz"},{"post_id":"ckyzx5p6w000grwh9b4z7azmp","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p72000urwh9ahrqb6qs"},{"post_id":"ckyzx5p6k0006rwh9grjx65lo","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p73000xrwh9683l5jg7"},{"post_id":"ckyzx5p6x000irwh98rev53hj","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p740011rwh98yya52qh"},{"post_id":"ckyzx5p6z000nrwh9bwpod3tq","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p740014rwh90e812doj"},{"post_id":"ckyzx5p6q0007rwh9dcvs6vng","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p750017rwh9cslrft3k"},{"post_id":"ckyzx5p6z000prwh9c80wckex","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p76001arwh9295d3pp9"},{"post_id":"ckyzx5p6r0008rwh9enekgb3l","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p76001crwh9fgp0ha7v"},{"post_id":"ckyzx5p72000wrwh9a2y8dqrb","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p76001frwh9gday3rhh"},{"post_id":"ckyzx5p740013rwh9ba6oam9m","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p77001grwh96iw25vdp"},{"post_id":"ckyzx5p750016rwh9e4pd46g5","category_id":"ckyzx5p6s0009rwh970nv3hw5","_id":"ckyzx5p77001jrwh979rnguua"},{"post_id":"ckyzx5p730010rwh9d92x1mtn","category_id":"ckyzx5p740015rwh93ehl6cac","_id":"ckyzx5p77001lrwh9c9rq82k9"}],"PostTag":[{"post_id":"ckyzx5p670001rwh9g1kr9yxv","tag_id":"ckyzx5p6i0005rwh953b38v3l","_id":"ckyzx5p6x000hrwh989e1bvp3"},{"post_id":"ckyzx5p670001rwh9g1kr9yxv","tag_id":"ckyzx5p6s000arwh9cxq35heq","_id":"ckyzx5p6y000krwh9hwutd664"},{"post_id":"ckyzx5p6b0003rwh99knv34in","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p72000vrwh955x4d5s8"},{"post_id":"ckyzx5p6b0003rwh99knv34in","tag_id":"ckyzx5p6y000mrwh95zhz4gla","_id":"ckyzx5p73000yrwh99d8u4l5d"},{"post_id":"ckyzx5p72000wrwh9a2y8dqrb","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p740012rwh9g3prf56r"},{"post_id":"ckyzx5p740013rwh9ba6oam9m","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p760019rwh9ay64csgz"},{"post_id":"ckyzx5p6k0006rwh9grjx65lo","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p76001brwh96uxxgica"},{"post_id":"ckyzx5p6k0006rwh9grjx65lo","tag_id":"ckyzx5p73000zrwh99ug01duq","_id":"ckyzx5p76001erwh9c8j9cq3s"},{"post_id":"ckyzx5p6q0007rwh9dcvs6vng","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p77001irwh90sjhhsqu"},{"post_id":"ckyzx5p6q0007rwh9dcvs6vng","tag_id":"ckyzx5p73000zrwh99ug01duq","_id":"ckyzx5p77001krwh9c4o4go2t"},{"post_id":"ckyzx5p6r0008rwh9enekgb3l","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p78001orwh91upwehn2"},{"post_id":"ckyzx5p6r0008rwh9enekgb3l","tag_id":"ckyzx5p73000zrwh99ug01duq","_id":"ckyzx5p78001prwh9hltqebcy"},{"post_id":"ckyzx5p6t000brwh9ft3cd163","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p78001srwh91jcbenej"},{"post_id":"ckyzx5p6t000brwh9ft3cd163","tag_id":"ckyzx5p73000zrwh99ug01duq","_id":"ckyzx5p78001trwh97rs9fg2s"},{"post_id":"ckyzx5p6u000crwh9gh1vbd7e","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p79001wrwh97swqh45n"},{"post_id":"ckyzx5p6u000crwh9gh1vbd7e","tag_id":"ckyzx5p73000zrwh99ug01duq","_id":"ckyzx5p79001xrwh98qszh036"},{"post_id":"ckyzx5p6w000grwh9b4z7azmp","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p7a001zrwh9bywe3kgq"},{"post_id":"ckyzx5p6w000grwh9b4z7azmp","tag_id":"ckyzx5p73000zrwh99ug01duq","_id":"ckyzx5p7a0020rwh99ziv0eut"},{"post_id":"ckyzx5p6x000irwh98rev53hj","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p7a0022rwh9crit155l"},{"post_id":"ckyzx5p6x000irwh98rev53hj","tag_id":"ckyzx5p73000zrwh99ug01duq","_id":"ckyzx5p7a0023rwh9738qe9r8"},{"post_id":"ckyzx5p6z000nrwh9bwpod3tq","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p7a0025rwh92e9saut0"},{"post_id":"ckyzx5p6z000nrwh9bwpod3tq","tag_id":"ckyzx5p7a0021rwh94d5m69z2","_id":"ckyzx5p7a0026rwh994zy3j3f"},{"post_id":"ckyzx5p6z000prwh9c80wckex","tag_id":"ckyzx5p7a0024rwh9a0i1171b","_id":"ckyzx5p7b0028rwh9cxdsgq56"},{"post_id":"ckyzx5p730010rwh9d92x1mtn","tag_id":"ckyzx5p7a0027rwh99wgabv8g","_id":"ckyzx5p7b002arwh98joz5k5p"},{"post_id":"ckyzx5p750016rwh9e4pd46g5","tag_id":"ckyzx5p6u000frwh95y5mcfwv","_id":"ckyzx5p7b002brwh93tmocbtu"},{"post_id":"ckyzx5p750016rwh9e4pd46g5","tag_id":"ckyzx5p7b0029rwh9flrt50sq","_id":"ckyzx5p7b002crwh9507ad1vt"}],"Tag":[{"name":"git flow","_id":"ckyzx5p6i0005rwh953b38v3l"},{"name":"git命令","_id":"ckyzx5p6s000arwh9cxq35heq"},{"name":"javascript","_id":"ckyzx5p6u000frwh95y5mcfwv"},{"name":"防抖节流","_id":"ckyzx5p6y000mrwh95zhz4gla"},{"name":"lodash","_id":"ckyzx5p73000zrwh99ug01duq"},{"name":"promise","_id":"ckyzx5p7a0021rwh94d5m69z2"},{"name":"webpack","_id":"ckyzx5p7a0024rwh9a0i1171b"},{"name":"网站","_id":"ckyzx5p7a0027rwh99wgabv8g"},{"name":"箭头函数","_id":"ckyzx5p7b0029rwh9flrt50sq"}]}}