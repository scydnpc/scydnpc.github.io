<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS BFC</title>
    <url>/2022/02/06/CSS-BFC/</url>
    <content><![CDATA[<p>关于BFC</p>
<h4 id="BFC概念"><a href="#BFC概念" class="headerlink" title="BFC概念"></a>BFC概念</h4><p><code>BFC</code> 全称：<code>Block Formatting Context</code>， 名为 “块级格式化上下文”。</p>
<p><code>W3C</code>官方解释为：<code>BFC</code>它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，<code>Block Formatting Context</code>提供了一个环境，<code>HTML</code>在这个环境中按照一定的规则进行布局。</p>
<p>简单来说就是，<code>BFC</code>是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用<code>BFC</code>呢，<code>BFC</code>可以看做是一个<code>CSS</code>元素属性</p>
<h4 id="触发BFC"><a href="#触发BFC" class="headerlink" title="触发BFC"></a>触发BFC</h4><ul>
<li>根元素，即<code>html</code></li>
<li><code>overflow</code>不为<code>visible</code>(hidden、auto、scroll)</li>
<li><code>float</code>的值不为<code>none</code></li>
<li><code>display</code>的值为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code></li>
<li><code>display</code>为<code>flex</code>、<code>grid</code>、<code>flow-root</code>的元素(<code>flow-root</code>为专门设置BFC的属性值)</li>
<li><code>position</code>的值为<code>absolute</code>或<code>fixed</code><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4></li>
</ul>
<ol>
<li><p>内部的<strong>块级</strong>盒子会在垂直方向上一个接一个的排列（可以看作BFC中有一个常规流）</p>
<p>例如<code>&lt;html&gt;</code>是BFC，它内部写<code>div</code>、<code>p</code>元素都会占一行；</p>
</li>
<li><p>Box垂直方向的距离由<code>margin</code>决定。属于同一个BFC的两个相邻Box的<code>margin</code>会发生重叠；</p>
<p><code>&lt;html&gt;</code>是BFC，所以垂直方向内部元素margin会重叠，但是直接子孙元素与该BFC上下边界<code>margin</code>不能折叠，保证了BFC内部的元素不会影响外部的元素。两个上下相邻的BFC之间折不折叠要看具体情况，如<code>display: inline-block</code> <code>float: left</code>不会折叠，而<code>overflow: hidden</code>则会折叠。</p>
</li>
<li><p>每一个BFC盒子的左外边距应该和包含块的左边缘相接触。即使存在浮动也是如此，除非子盒子形成了一个新的BFC。</p>
<ul>
<li>包含块未必就是父级元素。对于<code>position: absolute</code>来说，包含块是指第一个<code>positoin</code>不为<code>static</code>的祖先元素。</li>
<li>BFC中的盒子应该与其自身的包含块相接触，而非与BFC盒子本身相接触。</li>
<li>BFC中的盒子是与其包含块的 <code>left edge</code> 相接触，而不是包含块的 <code>left-border</code> 相接触。<code>left edge</code> 正确的翻译为左边缘。左边缘可能是<code>content box</code>的左边缘（非绝对定位如<code>position: relative</code> <code>float: left</code>），也可能是<code>padding box</code>的左边缘（如绝对定位<code>position: absolute</code> <code>position: fixed</code>）。</li>
</ul>
</li>
<li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然；</p>
<p>例如子元素无论<code>margin-top: -10000px</code> <code>float: left</code> 等都不会影响到BFC外部的元素的布局，所以BFC是最好的清除浮动的方式，连浮动的文字环绕问题都能解决。</p>
</li>
<li><p>计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；</p>
<p>这就是为什么利用BFC此特性解决浮动元素高度坍塌的问题。</p>
</li>
<li><p>BFC的区域不会与<code>float box</code>重叠；</p>
<p>例子是两栏布局的实现，左侧<code>float：left</code>，右侧<code>overflow：auto</code>。</p>
</li>
</ol>
<p>作者：蛙人<br>链接：<a href="https://juejin.cn/post/6950082193632788493">https://juejin.cn/post/6950082193632788493</a></p>
<p>作者：幻灵尔依<br>链接：<a href="https://juejin.cn/post/6844903894313598989">https://juejin.cn/post/6844903894313598989</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css基础复习</title>
    <url>/2022/01/30/css%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><code>css</code>的基本定位和布局机制是<strong>文档流</strong>，默认自上而下，从左到右</p>
<h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p><code>div、ul、li、p、table、h1</code> 等元素，他们的默认<code>display</code>默认是<code>block、table、list-item</code></p>
<h3 id="内联元素（行内元素）"><a href="#内联元素（行内元素）" class="headerlink" title="内联元素（行内元素）"></a>内联元素（行内元素）</h3><p>如<code>span、a、em、i、img、td</code>等，这些元素的display值默认是<code>inline、inline-block、inline-table、table-cell</code>等。</p>
<h3 id="关于-width-auto-和-height-auto"><a href="#关于-width-auto-和-height-auto" class="headerlink" title="关于 width: auto  和 height: auto"></a>关于 <code>width: auto</code>  和 <code>height: auto</code></h3><p><code>width</code>、<code>height</code>的默认值都是<code>auto</code>。</p>
<p><strong>对于width</strong></p>
<p>块级元素：流体布局之下<code>width: auto</code>自适应撑满父元素宽度。这里的撑满并不同于<code>width: 100%</code>的固定宽度，而是像水一样能够根据<code>margin</code>不同而自适应父元素的宽度。</p>
<p>内联元素：<code>width: auto</code>则呈现出包裹性，即由子元素的宽度决定。</p>
<p><strong>对于height</strong></p>
<p>无论内联元素还是块级元素，<code>height: auto</code>都是呈现包裹性，即高度由子级元素撑开。</p>
<p>父元素<code>height: auto</code>会导致子元素<code>height: 100%</code>百分比失效。</p>
<p><code>css</code>的属性非常有意思，正常流下，如果块级元素的<code>width</code>是个固定值，<code>margin</code>是<code>auto</code>，则<code>margin</code>会撑满剩下的空间；如果<code>margin</code>是固定值，<code>width</code>是<code>auto</code>，则<code>width</code>会撑满剩下的空间。这就是流体布局的根本所在。</p>
<h3 id="css权重"><a href="#css权重" class="headerlink" title="css权重"></a><code>css</code>权重</h3><table>
<thead>
<tr>
<th>权重值</th>
<th>选择器</th>
</tr>
</thead>
<tbody><tr>
<td>1,0,0,0</td>
<td>内联样式：style=””</td>
</tr>
<tr>
<td>0,1,0,0</td>
<td>ID选择器：<code>#idName&#123;...&#125;</code></td>
</tr>
<tr>
<td>0,0,1,0</td>
<td>类、伪类、属性选择器：<code>.className&#123;...&#125;</code> / <code>:hover&#123;...&#125;</code> / <code>[type=&quot;text&quot;] =&#123;...&#125;</code></td>
</tr>
<tr>
<td>0,0,0,1</td>
<td>标签、伪元素选择器：<code>div&#123;...&#125;</code> / <code>:after&#123;...&#125;</code></td>
</tr>
<tr>
<td>0,0,0,0</td>
<td>通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）</td>
</tr>
</tbody></table>
<h3 id="盒模型（盒尺寸）"><a href="#盒模型（盒尺寸）" class="headerlink" title="盒模型（盒尺寸）"></a>盒模型（盒尺寸）</h3><p>元素的内在盒子是由<code>margin box</code>、<code>border box</code>、<code>padding box</code>、<code>content box</code>组成的，这四个盒子由外到内构成了盒模型。</p>
<p>IE模型： <code>box-sizing: border-box</code>  此模式下，元素的宽度计算为<code>border+padding+content</code>的宽度总和。</p>
<p>w3c标准盒子模型： <code>box-sizing: content-box</code> 此模式下，元素的宽度计算为<code>content</code>的宽度。</p>
<p>由于<code>content-box</code>在计算宽度的时候不包含<code>border pading</code>很烦人，而且又是默认值，业内一般采用以下代码重置样式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">    box-<span class="attr">sizing</span>: border-box;    </span><br><span class="line">&#125;</span><br><span class="line">* &#123;</span><br><span class="line">    box-<span class="attr">sizing</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内联盒模型"><a href="#内联盒模型" class="headerlink" title="内联盒模型"></a>内联盒模型</h3><p><img src="/images/%E5%86%85%E8%81%94%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="Image text"><br>内联元素是指外在盒子是内联盒子的元素。从表现来说，内联元素的典型特征就是可以和文字在一行显示。文字也是内联元素。图片、按钮、输入框、下拉框等替换元素也是内联元素。内联盒模型是指内联元素包含的几个盒子，理解记忆下面的几个概念对css的深入学习极其重要。</p>
<ol>
<li><p>内容区域：本质上是字符盒子。在浏览器中，文字选中状态的背景色就是内容区域。</p>
</li>
<li><p>内联盒子：内联盒子就是指元素的外在盒子是内联的，会和其他内联盒子排成一行。</p>
</li>
<li><p>行框盒子：由内联元素组成的每一行都是一个行框盒子。如果一行里面没有内联元素如一个空的<code>div</code>标签，则不会形成行框盒子。行框盒子由一个个内联盒子组成，如果换行，那就是两个行框盒子。比如一个包含了很多字符的换行的的<code>p</code>标签，每一行都存在一个行框盒子。值得注意的是，如果给元素设置<code>display: inline-block</code>，则创建了一个独立的行框盒子。<code>line-height</code>是作用在行框盒子上的，并最终决定高度。</p>
</li>
<li><p>包含盒子：就是包含块。多行文字组成一个包含块，一个包含块有若干个行框盒子。</p>
</li>
<li><p>幽灵空白节点：内联元素的每个行框盒子前面有一个“空白节点”，这个“空白节点”不占据任何宽度，无法选中获取，但是又实实在在存在，表现就如同文本节点一样（本文中大量例子会用字母x模拟幽灵空白节点）。  </p>
</li>
</ol>
<h3 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h3><p>替换元素是指内容可以替换的元素，实际上就是<code>content box</code>可以被替换的元素。</p>
<ol>
<li><p>存在<code>src=&quot;&quot;</code>属性的<code>&lt;img&gt; &lt;audio&gt; &lt;video&gt; &lt;iframe&gt;</code>元素</p>
</li>
<li><p>可以输入文本的<code>&lt;input&gt; &lt;select&gt; &lt;textarea&gt;</code>元素等。</p>
</li>
</ol>
<p>所有替换元素都是内联元素，默认<code>display</code>属性是<code>inline</code>或<code>inline-block</code>（除了<code>input[type=&quot;hidden&quot;]</code>默认<code>display: none;</code>）。</p>
<h3 id="盒模型四大金刚-gt-content-、-padding-、-margin-、-border"><a href="#盒模型四大金刚-gt-content-、-padding-、-margin-、-border" class="headerlink" title="盒模型四大金刚 ===&gt; content 、 padding 、 margin 、 border"></a>盒模型四大金刚 ===&gt; <code>content</code> 、 <code>padding</code> 、 <code>margin</code> 、 <code>border</code></h3><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>对于非替换元素如<code>div</code>,其<code>content</code>就是div内部的元素。 而对于替换元素，其<code>content</code>就是可替换部分的内容。</p>
<p>CSS中的<code>content</code>属性主要用于伪元素<code>:before/:after</code>中，除了做字体库或少写个<code>div</code>，对于一般开发来说并无卵用。</p>
<h4 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h4><ol>
<li><p>设置<code>box-sizing: border-box</code>，宽高计算<code>padding</code>，但内容区域的宽高只是<code>content box</code>的宽高。</p>
</li>
<li><p><code>padding</code>不可为负值，但是可以为百分比值。为百分比时水平和垂直方向的<code>padding</code>都是相对于父级元素<strong>宽度</strong>计算的。将一个<code>div</code>设为<code>padding: 100%</code>就能得到一个正方形，<code>padding: 10% 50%</code>可以得到一个宽高比 5:1 的矩形。</p>
</li>
<li><p><code>padding</code>配合<code>background-clip</code>属性，可以制作一些特殊形状。</p>
</li>
</ol>
<h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><ol>
<li><p><code>margin</code>属性并不会参与盒子宽度的计算，但在<strong>流体布局下，即元素<code>width</code>是默认的<code>auto</code>并且可以撑满一行的时候</strong>，通过设置<code>margin</code>为负值，却能改变元素水平方向的尺寸；如果元素设定了宽度，或者元素设置了<code>float: left</code> / <code>position: absolute</code>这样的属性改变了流体布局，那么<code>margin</code>为负也无法改变元素的宽度了。</p>
</li>
<li><p>块级元素的垂直方向会发生<code>margin</code>合并，存在以下三种场景：</p>
<ul>
<li><p>相邻兄弟元素之间<code>margin</code>合并</p>
</li>
<li><p>父元素<code>margin-top</code>和子元素<code>margin-top</code>，父元素<code>margin-bottom</code>和子元素<code>margin-bottom</code></p>
</li>
<li><p>空块级元素自身的<code>margin-top</code>和<code>margin-botom</code>合并</p>
<p><strong>如何阻止<code>margin</code>合并：</strong></p>
<ul>
<li>把元素放到<code>bfc</code>中</li>
<li>设置<code>border</code>或<code>padding</code>阻隔<code>margin</code></li>
<li>用内联元素（如文字）阻隔</li>
<li>给父元素设定高度</li>
<li>具体使用请参考文章<code>css bfc</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>margin</code>的百分比值跟<code>padding</code>一样，垂直方向的<code>margin</code>和水平方向上的一样都是相对于父元素<strong>宽度</strong>计算的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时 .box 是一个宽高比 2:1 的矩形，因为空块级元素自身的垂直方向的<code>margin</code>发生了合并。</p>
</li>
<li><p><code>margin: auto</code>能在块级元素设定宽高之后自动填充剩余宽高</p>
<p>如果一侧<code>margin</code>是固定的，另一侧是<code>auto</code>，则这一侧<code>auto</code>为剩余宽度</p>
<p>垂直方向的margin也能实现垂直居中，但是需要元素在垂直方向具有自动填充特性，而这个特性可以利用position实现：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="border"><a href="#border" class="headerlink" title="border"></a>border</h4><ol>
<li><p><code>border-style</code>属性的值有<code>none/solid/dashed（虚线）/dotted（点线）/double（双实线）</code>等</p>
</li>
<li><p><code>border-width</code>属性的默认值是<code>3px</code>，是为了照顾小弟<code>border-style: double</code></p>
</li>
<li><p><code>border-color</code>默认是跟随字体的颜色，相当于默认设置了<code>border-color: currentColor</code>一样。</p>
</li>
<li><p><code>border</code>另一广受欢迎的功能就是图形构建，特别是做应用广泛的三角形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">20px</span> solid;</span><br><span class="line">  <span class="attribute">border-color</span>: blue red orange green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">20px</span> solid;</span><br><span class="line">  <span class="attribute">border-color</span>: blue transparent transparent transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">20px</span> solid;</span><br><span class="line">  <span class="attribute">border-color</span>: blue transparent transparent transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>)&#123;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">40px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: blue transparent transparent transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>)&#123;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">40px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: blue red transparent transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/border%E5%9B%BE%E5%BD%A2%E6%9E%84%E5%BB%BA.png" alt="Image text"></p>
<p>其实就是将其他三个边框的颜色设置透明，并把宽高设为 0 。图中4-5两个图形，是通过调整边框宽度和颜色调整三角形的形状，把最后一个图的红色改为蓝色，则是一个直角三角形了。</p>
</li>
</ol>
<h2 id="line-height和vertical-align"><a href="#line-height和vertical-align" class="headerlink" title="line-height和vertical-align"></a><code>line-height</code>和<code>vertical-align</code></h2><p><code>line-height</code>和<code>vertical-align</code>是控制元素垂直对齐的两大属性</p>
<h4 id="字母-x"><a href="#字母-x" class="headerlink" title="字母 x"></a>字母 x</h4><p><code>line-height</code>定义的就是两基线之间的距离，<code>vertical-align</code>的默认值就是基线。基线的定义则是字母 x 的下边缘。</p>
<p><code>css</code>中有个概念叫<code>x-height</code>，指的是小写字母 x 的高度。<code>vertical-align: middle</code>对齐的就是基线往上1/2<code>x-height</code>高度的地方，可以理解为近似字母 x 的交叉点。</p>
<p><code>css</code>中除了<code>px/em/rem</code>等，还有个单位是<code>ex</code>。指的就是小写字母x的高度，即<code>x-height</code>。用处不大，不再介绍。</p>
<h4 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a><code>line-height</code></h4><p>各类属性值</p>
<ul>
<li><p><code>normal</code>： 默认值<code>normal</code>其实是类型为数值的变量，根据浏览器和字体<code>font-family</code>不同而不同，一般约为 1.2 。</p>
</li>
<li><p>数值和百分比：最终会被计算为带单位的值，具体计算方法就是乘以字体大小<code>font-size</code>。</p>
</li>
<li><p>长度值：就是<code>100px</code>这样带单位的值。</p>
</li>
</ul>
<p><code>line-height</code>的作用</p>
<p><code>line-height</code>属性用于设置多行元素的空间量，如多行文本的间距。</p>
<p>对块级元素来说，<code>line-height</code>决定了<strong>行框盒子</strong>的最小高度。注意是行框盒子的最小高度，而不是块级元素的实际高度。（图中两个<code>div</code>行高一样，<code>div.one</code> 的背景色区域就是行框盒子的高度，而 <code>div.two</code> 的背景区域则是实际高度，其行框盒子高度和 <code>div.one</code> 是一样的。）</p>
<p><img src="/images/line-height%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="Image text"></p>
<p>对于非替代的 inline 元素，它用于计算行框盒子的高度。此时内联元素的行框盒子的高度完全由<code>line-height</code>决定，不受其他任何属性的影响。</p>
<p><img src="/images/line-height%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0.png" alt="Image text"></p>
<h4 id="line-height实现垂直居中的本质：行距"><a href="#line-height实现垂直居中的本质：行距" class="headerlink" title="line-height实现垂直居中的本质：行距"></a><code>line-height</code>实现垂直居中的本质：行距</h4><p>行距是指一行文本和相邻文本之间的距离。行距 = <code>line-height</code> - <code>font-size</code>。</p>
<p>行距具有上下等分的机制：意思就是文字上下的行距是一样的，各占一半，这也是<code>line-height</code>能让内联元素垂直居中的原因。</p>
<p><strong>特别注意</strong>：有幽灵空白节点的元素在设置行高的情况下也会撑起盒子，比如设置了<code>display: inline-block</code>的<code>span</code>元素</p>
<h4 id="内联元素的大值特性"><a href="#内联元素的大值特性" class="headerlink" title="内联元素的大值特性"></a>内联元素的大值特性</h4><p>无论内联元素的<code>line-height</code>如何设置，最终父元素的高度都是数值大的那个<code>line-height</code>决定的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>asdf<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background</span>: lightgreen;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="comment">/* box高度是100px */</span></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">line-height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background</span>: lightgreen;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="comment">/* box高度也是100px */</span></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a><code>vertical-align</code></h4><p>各类属性值</p>
<ul>
<li><p>线类：</p>
<ol>
<li><p><code>baseline</code>(默认值)：使元素的基线与父元素的基线对齐</p>
</li>
<li><p><code>top</code> <code>bottom</code>使元素及其后代元素的底部与整行或整块的底部对齐。</p>
</li>
<li><p><code>middle</code>使元素的中部与父元素的基线往上<code>x-height</code>的一半对齐。</p>
</li>
</ol>
</li>
<li><p>文本类：<code>text-top</code> <code>text-bottom</code>（使元素的顶部与父元素的字体顶部对齐。）</p>
</li>
<li><p>上标下标：<code>sub</code> <code>super</code>（使元素的基线与父元素的下标基线对齐。）</p>
</li>
<li><p>数值： <code>20px</code> <code>2em</code> （默认值<code>baseline</code>相当于数值的 0 。使元素的基线对齐到父元素的基线之上的给定长度，数值正值是基线往上偏移，负值是往下偏移，借此可以实现元素垂直方向精确对齐。）</p>
</li>
<li><p>百分比：<code>20%</code> （使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。）</p>
</li>
</ul>
<p><code>vertical-align</code>的作用</p>
<p><strong>vertical-align属性起作用的前提必须是作用在内联元素上。</strong> 即<code>display</code>计算值为<code>inline</code> <code>inline-block</code> <code>inline-table</code> <code>table-cell</code>的元素。所以如果元素设置了<code>float: left</code>或者<code>position: absolute</code>，则其<code>vertical-align</code>属性不能生效，因为此时元素的<code>display</code>计算值为<code>block</code>了。</p>
<h3 id="float属性的特性"><a href="#float属性的特性" class="headerlink" title="float属性的特性"></a><code>float</code>属性的特性</h3><p><code>float</code>属性起初只是为了实现“文字环绕图片”的效果</p>
<p><img src="/images/%E6%96%87%E5%AD%97%E7%8E%AF%E7%BB%95.png" alt="文字环绕"></p>
<h4 id="关于float属性的特性："><a href="#关于float属性的特性：" class="headerlink" title="关于float属性的特性："></a>关于float属性的特性：</h4><ol>
<li><p>包裹性：即此时元素<code>width</code>会像<code>height</code>一样由子元素决定，而不是默认撑满父元素。</p>
<p>![如图此时为文字宽度和高度](/images/float 包裹性.png)</p>
</li>
<li><p>块状化并格式化上下文：设置<code>float: left</code>之后，<code>display</code>的计算值变成<code>block</code>。格式化上下文是指会创建一个<code>BFC</code>。</p>
</li>
<li><p>没有<code>margin</code>合并</p>
</li>
<li><p>脱离文档流：与float并列的元素b是会和该元素重叠，（但是b中的行框盒子不会（例如文字，因为浮动和行框元素同属BFC，不互相影响），这就是形成环绕文字的原因）</p>
</li>
</ol>
<h4 id="解决浮动的办法：设置clear：both："><a href="#解决浮动的办法：设置clear：both：" class="headerlink" title="解决浮动的办法：设置clear：both："></a>解决浮动的办法：设置<code>clear：both</code>：</h4><p><code>clear</code>的定义是：元素盒子的边不能与前面的浮动元素相邻。也就是虽然浮动元素高度坍塌，但是设置了<code>clear: both</code>的元素却将其高度视为仍然占据位置。</p>
<p><strong><code>clear</code>只能作用于块级元素</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>作者：幻灵尔依<br>链接：<a href="https://juejin.cn/post/6844903894313598989">https://juejin.cn/post/6844903894313598989</a><br>来源：稀土掘金</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 chunk</title>
    <url>/2021/12/20/lodash%E6%BA%90%E7%A0%81%20chunk/</url>
    <content><![CDATA[<h2 id="chunk-array-size-1"><a href="#chunk-array-size-1" class="headerlink" title="_.chunk(array, [size=1])"></a>_.chunk(array, [size=1])</h2><blockquote>
<p>介绍：将数组（<code>array</code>）拆分成多个 <code>size</code> 长度的区块，并将这些区块组成一个新数组。 如果array 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。<br>参数：<br><code>array</code> (Array): 需要处理的数组<br><code>[size=1]</code> (number): 每个数组区块的长度</p>
</blockquote>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p><code>chunk</code> 函数在前端可以用来缓解一些性能问题。例如大量的 <code>DOM</code> 操作，可以分块让浏览器在空闲的时候处理，避免页面卡死。如下面的代码，向页面中插入大量的 <code>DOM</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [] <span class="comment">// 1万条数据</span></span><br><span class="line"><span class="keyword">const</span> chunks = _.<span class="title function_">chunk</span>(arr, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> append = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (chunks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = chunks.<span class="title function_">pop</span>()</span><br><span class="line">    current.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> node = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">      node.<span class="property">innerText</span> = item</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(node)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">setTimeout</span>(append, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">append</span>()</span><br></pre></td></tr></table></figure>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> slice <span class="keyword">from</span> <span class="string">&#x27;./slice.js&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><code>chunk</code> 的原理归结起来就是切割和放置。  </p>
<p><code>chunk</code> 最后返回的结果如<code>[[1],[1],[1]]</code>的形式，放置就是将切割下来的块放置到数组容器中。  </p>
<p>那要怎样切割呢？</p>
<p>因为指定了大小，因此切割跟切蛋糕很像，参数 <code>size</code> 是尺子，测好每块的长度，<code>slice</code> 函数是刀， 将数组一块一块切出来。  例如有 <code>[1,2,3,4,5]</code> 这个数组，<code>size</code> 指定为 <code>2</code>，则第一次切割会得到 <code>[1,2]</code> 的块，第二次切割得到 <code>[4,5]</code>，剩下的是 <code>[5]</code> 。这个数组最终会被切为三块。</p>
<h4 id="源码总览"><a href="#源码总览" class="headerlink" title="源码总览"></a>源码总览</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chunk</span>(<span class="params">array, size</span>) &#123;</span><br><span class="line">  <span class="comment">// 确保 length 存在 且 size 比 1 大</span></span><br><span class="line">  size = <span class="title class_">Math</span>.<span class="title function_">max</span>(size, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> length = array == <span class="literal">null</span> ? <span class="number">0</span> : array.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 否则 返回空数组</span></span><br><span class="line">  <span class="keyword">if</span> (!length || size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> resIndex = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 新建数组result，长度为分割后块的数量</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(length / size))</span><br><span class="line">  <span class="comment">// 切割 array 放于 result 中，注意 index，每次切割，index增加size长度</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; length) &#123;</span><br><span class="line">    result[resIndex++] = <span class="title function_">slice</span>(array, index, (index += size))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p><code>Math.round()</code>  “四舍五入”， 该函数返回的是一个四舍五入后的的整数<br><code>Math.ceil()</code>  “向上取整”， 即小数部分直接舍去，并向正数部分进1<br><code>Math.floor()</code>  “向下取整” ，即小数部分直接舍去</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>Js防抖与节流</title>
    <url>/2021/12/06/Js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</span><br></pre></td></tr></table></figure>
<p>实际🌰：监听input输入来请求接口，未进行防抖时，键入内容就会请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟一段ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">content</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ajax request &#x27;</span> + content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inputa = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;unDebounce&#x27;</span>)</span><br><span class="line"></span><br><span class="line">inputa.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title function_">ajax</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟一段ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">content</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ajax request &#x27;</span> + content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fun, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(fun.<span class="property">id</span>)</span><br><span class="line">        fun.<span class="property">id</span> = <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fun.<span class="title function_">call</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;, delay) </span><br><span class="line">        <span class="comment">// setTimeout 返回一个唯一id，在delay时间内clearTimeout 该id可阻止事件</span></span><br><span class="line">        <span class="comment">// 该处的作用是：事件触发时间内再次触发事件则停止原事件，重新计时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> inputb = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;debounce&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> debounceAjax = <span class="title function_">debounce</span>(ajax, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">inputb.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="title function_">debounceAjax</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>函数防抖就像法师发技能的时候要读条，技能读条没完再按技能就会重新读条。</strong></p>
<h3 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</span><br></pre></td></tr></table></figure>

<p>实际🌰：需求：无论多快输入，但每1s执行一次请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function throttle(fun, delay) &#123;</span><br><span class="line">    let last, deferTimer</span><br><span class="line">    return function (args) &#123;</span><br><span class="line">        let that = this</span><br><span class="line">        let _args = arguments</span><br><span class="line">        let now = +new Date()</span><br><span class="line">        clearTimeout(deferTimer) // 重复调用清空上一次的setTime</span><br><span class="line">        // 当第一次调用 或者 键入操作持续一秒后（此时由于clear的作用，last一直没更新，last + delay 会小于now） 会走 else分支</span><br><span class="line">        if (last &amp;&amp; now &lt; last + delay) &#123;</span><br><span class="line">            deferTimer = setTimeout(function () &#123;</span><br><span class="line">                last = now</span><br><span class="line">                fun.apply(that, _args)</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            last = now</span><br><span class="line">            fun.apply(that,_args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let throttleAjax = throttle(ajax, 1000)</span><br><span class="line"></span><br><span class="line">let inputc = document.getElementById(&#x27;throttle&#x27;)</span><br><span class="line">inputc.addEventListener(&#x27;keyup&#x27;, function(e) &#123;</span><br><span class="line">    throttleAjax(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li>
<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>
</ul>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><ul>
<li>debounce<ul>
<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
</li>
<li>throttle<ul>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
</li>
</ul>
<h2 id="lodash-中的防抖节流方法"><a href="#lodash-中的防抖节流方法" class="headerlink" title="lodash 中的防抖节流方法"></a>lodash 中的防抖节流方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装 `lodash`</span><br><span class="line">npm i --save lodash</span><br><span class="line">// 引用</span><br><span class="line">import _ from &#x27;lodash&#x27;</span><br><span class="line"></span><br><span class="line">// 使用防抖</span><br><span class="line">const debounced = _.debounced(func, wait, options)</span><br></pre></td></tr></table></figure>
<p><strong>各参数</strong><br><code>func</code> (Function): 要防抖动的函数。<br><code>[wait=0]</code> (number): 需要延迟的毫秒数。<br><code>[options=]</code> (Object): 选项对象。<br><code>[options.leading=false]</code> (boolean): 指定在延迟开始前调用。<br><code>[options.maxWait]</code> (number): 设置 func 允许被延迟的最大值。<br><code>[options.trailing=true]</code> (boolean): 指定在延迟结束后调用。</p>
<p><strong>需要注意的点</strong><br><code>_.debounced()</code>的返回值为<code>func</code>的返回值，默认参数情况（例如：<code>_.debounced(func, 500)</code>）在防抖阶段，因为还未执行<code>func</code>的<code>return</code>，返回为<code>undefined</code>  </p>
<p><strong>节流<code>_.throttle()</code></strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>作者：薄荷前端<br>链接：<a href="https://juejin.cn/post/6844903669389885453">https://juejin.cn/post/6844903669389885453</a><br>来源：稀土掘金</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>防抖节流</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Flow &amp; 常用Git命名和操作</title>
    <url>/2021/12/10/Git%20Flow%20&amp;%20%E5%B8%B8%E7%94%A8Git%E5%91%BD%E5%90%8D%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="简述-Git-Flow"><a href="#简述-Git-Flow" class="headerlink" title="# 简述 Git Flow"></a># 简述 Git Flow</h2><p>简单来说，<code>Git Flow</code> 就是一套规范的代码管理流程</p>
<h2 id="分支应用情景"><a href="#分支应用情景" class="headerlink" title="# 分支应用情景"></a># 分支应用情景</h2><ul>
<li>在<code>Git Flow</code>中，主要的分支有<code>master</code>、<code>develop</code>、<code>hotfix</code>、<code>release</code>、<code>feature</code> 这五种分支  </li>
<li><code>develop</code> 和 <code>master</code>会被保留，其他的随任务结束而删除  <h3 id="master-分支"><a href="#master-分支" class="headerlink" title="# master 分支"></a># master 分支</h3></li>
<li>存放稳定上线版本</li>
<li>这个分支的来源只能从别的分支合并过来，开发者不会直接commit到这个分支上。</li>
<li>通常我们也会在这个分支上的提交打上版本号标签。<h3 id="develop-分支"><a href="#develop-分支" class="headerlink" title="# develop 分支"></a># develop 分支</h3></li>
<li>这个分支主要是所有开发的基础分支。</li>
<li>当要添加功能时，所有功能都是从这个分支切出去的，而功能分支实现后，也都会合并回来这个分支中。<h3 id="hotfix-分支"><a href="#hotfix-分支" class="headerlink" title="# hotfix 分支"></a># hotfix 分支</h3></li>
<li>用途：处理紧急线上问题</li>
<li>基于master分支创建</li>
<li>修复完成，合并到master分支和develop分支中<h3 id="release-分支-预上线分支"><a href="#release-分支-预上线分支" class="headerlink" title="# release 分支 (预上线分支)"></a># release 分支 (预上线分支)</h3></li>
<li>当<code>develop</code>分支完成需求后，就可以从<code>develop</code>分支中开一个<code>release</code>分支，进行上线前最后的测试。</li>
<li>测试完成后，释放<code>release</code>分支将会同时合并到<code>master</code>以及<code>develop</code>分支中。<h3 id="feature分支"><a href="#feature分支" class="headerlink" title="# feature分支"></a># feature分支</h3></li>
<li>当我们需要补充功能的时候，就会从develop分支中开一个feature分支进行功能开发。</li>
<li>当功能实现后，在将feature分支合并到develop分支中，等待最后的测试发布。</li>
</ul>
<h3 id="具体场景"><a href="#具体场景" class="headerlink" title="# 具体场景"></a># 具体场景</h3><h4 id="1-新功能开发"><a href="#1-新功能开发" class="headerlink" title="1. 新功能开发"></a>1. 新功能开发</h4><blockquote>
<p>基于<code>develop</code>，新建功能分支 <code>f1-feature</code>，切换到该分支下进行开发<br>需要多人开发时，可以推到远端分支<br>完成功能开发，将该分支合并到<code>develop</code>分支，**并删除<code>f1-feature</code>**分支</p>
</blockquote>
<p><strong>2021/12/24 – 更新：使用 <code>rebase</code> 整理提交</strong><br>关于新分支（命名<code>f1-feature</code> 或者 <code>feat/xxx</code> ）<br><strong>1. develop有更新内容需要同步</strong>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">提交代码</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;message&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换 develop 拉取代码</span></span><br><span class="line">git checkout develop</span><br><span class="line">git pull</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换 本地分支（例：feature），合并代码</span></span><br><span class="line">git checkout feature</span><br><span class="line">git rebase -i develop</span><br></pre></td></tr></table></figure>
<p>-i 意为合并多次提交，运行后显示前几次的提交内容如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 281812b message1  </span><br><span class="line">pick e60c7f4 message2  </span><br></pre></td></tr></table></figure>
<p>当需要合并所有提交的时候，保留一个<code>pick</code>，其余修改为 <code>s</code>，如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 281812b message1  </span><br><span class="line">s e60c7f4 message2  </span><br></pre></td></tr></table></figure>
<p><code>:wq</code> 提交修改</p>
<p><strong>代码冲突时，修改冲突后，重新<code>add</code>提交，执行<code>git commit</code>，展示<code>message</code>，根据需求自行修改，再 <code>git rebase --continue</code></strong>  </p>
<p><strong>2. 本地分支开发完毕需要合并到develop</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">先提交本地分支代码 add --&gt; commit</span></span><br><span class="line">git rebase -i develop</span><br><span class="line"><span class="meta"># </span><span class="language-bash">后面的操作如1所示</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">需要新增的步骤：切换到develop分支，merge 本地分支</span></span><br><span class="line">git merge feature</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">最后 git push</span></span><br></pre></td></tr></table></figure>
<p>需要注意的点：在 <code>git rebase -i develop</code> 的时候，根据自身情况选择对commit是否进行合并</p>
<h4 id="2-发布上线"><a href="#2-发布上线" class="headerlink" title="2. 发布上线"></a>2. 发布上线</h4><p>基于<code>develop</code>分支创建<code>release-0.1</code>分支作为预上线分支,有问题，在该分支上修改，最后切换到<code>develop</code>和<code>master</code>分支下合并该分支，删除<code>release-0.1</code>分支</p>
<h4 id="3-紧急bug修复"><a href="#3-紧急bug修复" class="headerlink" title="3.紧急bug修复"></a>3.紧急bug修复</h4><p>基于<code>master</code>分支新建<code>hotfix-bug1</code>分支进行修改，修改完切换到<code>develop</code>和<code>master</code>分支下合并该分支，删除<code>hotfix-bug1</code>分支</p>
<h3 id="常用git操作"><a href="#常用git操作" class="headerlink" title="# 常用git操作"></a># 常用git操作</h3><p><strong>分支相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查看本地分支</span><br><span class="line">git branch</span><br><span class="line">返回🌰</span><br><span class="line">*master</span><br><span class="line"></span><br><span class="line">// 查看远程分支</span><br><span class="line">git branch -r</span><br><span class="line">返回🌰</span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line">// 查看本地和远程分支</span><br><span class="line">git branch -a</span><br><span class="line">返回🌰</span><br><span class="line">*master</span><br><span class="line"> remotes/origin/master</span><br><span class="line"> </span><br><span class="line">// 切换分支</span><br><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line">// 创建并切换到该分支</span><br><span class="line">git checkout -b &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line">// 删除分支</span><br><span class="line">git branch -d &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line">// 删除远端分支</span><br><span class="line">git push origin -d &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line">// 重命名分支</span><br><span class="line">git branch -m &lt;oldbranch-name&gt; &lt;newbranch-name&gt;</span><br><span class="line"></span><br><span class="line">// 合并指定分支到当前分支</span><br><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git flow</tag>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 compact</title>
    <url>/2021/12/20/lodash%E6%BA%90%E7%A0%81%20compact/</url>
    <content><![CDATA[<h2 id="compact-array"><a href="#compact-array" class="headerlink" title="_.compact(array)"></a>_.compact(array)</h2><blockquote>
<p>介绍：创建一个新数组，包含原数组中所有的非假值元素。例如<code>false</code> , <code>null</code> , <code>0</code> , <code>&quot;&quot;</code> , <code>undefined</code> , 和 <code>NaN</code> 都是被认为是“假值”。<br>🌰</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="literal">false</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="title class_">NaN</span>,<span class="number">5</span>,<span class="literal">undefined</span>]</span><br><span class="line">_.<span class="title function_">compact</span>(arr) <span class="comment">// 返回 [1，2，3，4，5]</span></span><br></pre></td></tr></table></figure>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compact</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> resIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (array == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      result[resIndex++] = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么使用-for-of"><a href="#为什么使用-for-of" class="headerlink" title="为什么使用 for  of"></a>为什么使用 <code>for  of</code></h4><blockquote>
<p>遍历除了 <code>for  of</code> 还有 <code>for</code>、<code>for in</code>，使用 <code>for</code>的话，不够间接，下面讨论为什么不使用<code>for in</code></p>
</blockquote>
<h5 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h5><p>for in是以<strong>任意顺序</strong>遍历一个对象的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举属性</a>。  </p>
<p>在数组中，数组的索引是可枚举属性，可以用 for…in 来遍历数组的索引，数组中的稀疏部分不存在索引，可以避免用 for 循环造成无效遍历的弊端。</p>
<p>但是，for…in 的遍历顺序依赖于执行环境，不同执行环境的实现方式可能会不一样。单凭这一点，就断然不能在数组遍历中使用 for…in，大多数情况下，顺序对于数组的遍历都相当重要。</p>
<p>另外，先看个🌰</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，你期望输出的是 0,1,2，但是最后输出的可能是 0,1,2,foo （for…in 不能保证顺序）。因为 foo 也是可枚举属性，在 for..in 会被遍历出来。</p>
<h5 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h5><p><code>for...of</code> 循环内部调用的就是数组原型链上的 <code>Symbol.iterator</code> 方法。</p>
<p><code>Symbol.iterator</code> 在调用的时候会返回一个遍历器对象，这个遍历器对象中包含 <code>next</code> 方法，<code>for...of</code> 在每次循环的时候都会调用 <code>next</code> 方法来获取值，直到 <code>next</code> 返回的对象中的 <code>done</code>属性值为 <code>true</code> 时停止。</p>
<p>手动调用来模拟遍历的过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>因此在不改写 <code>Symbol.iterator</code> 的情况下, 使用 <code>for...of</code> 来遍历数组是安全的，因为这个方法(<code>Symbol.iterator</code>)是数组的原生方法。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 eq</title>
    <url>/2021/12/27/lodash%E6%BA%90%E7%A0%81%20eq/</url>
    <content><![CDATA[<h3 id="eq-value-other"><a href="#eq-value-other" class="headerlink" title="_.eq(value, other)"></a>_.eq(value, other)</h3><blockquote>
<p>介绍：执行 <code>SameValueZero</code> 比较两者的值，来确定它们是否相等。</p>
</blockquote>
<h4 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123; <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> other = &#123; <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line">_.<span class="title function_">eq</span>(object, object);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"> </span><br><span class="line">_.<span class="title function_">eq</span>(object, other);</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"> </span><br><span class="line">_.<span class="title function_">eq</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"> </span><br><span class="line">_.<span class="title function_">eq</span>(<span class="string">&#x27;a&#x27;</span>, <span class="title class_">Object</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"> </span><br><span class="line">_.<span class="title function_">eq</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<h4 id="规则比较"><a href="#规则比较" class="headerlink" title="规则比较"></a>规则比较</h4><blockquote>
<p>前排提示：以下提到的规则，<code>SameValueNonNumber</code> 是基本，<code>Strict Equality Comparison</code> 、<code>SameValue</code> 和 <code>SameValueZero</code> 只是在对待 <code>+0</code>、<code>-0</code> 和 <code>NaN</code> 上有区别。</p>
</blockquote>
<h5 id="基础规则：SameValueNonNumber"><a href="#基础规则：SameValueNonNumber" class="headerlink" title="基础规则：SameValueNonNumber"></a>基础规则：SameValueNonNumber</h5><p>这个规范规定比较的值 x 和 y 都不为 Number 类型，照抄规范如下：</p>
<ol>
<li><code>x</code> 的类型不为 <code>Number</code> 类型</li>
<li><code>y</code> 的类型与 <code>x</code> 的类型一致</li>
<li>如果 <code>x</code> 的类型为 <code>Undefined</code> ，返回 <code>true</code></li>
<li>如果 <code>x</code> 的类型为 <code>Null</code> ，返回 <code>true</code></li>
<li>如果 <code>x</code> 的类型为 <code>String</code>，并且 <code>x</code> 和 <code>y</code> 的长度及编码相同，返回 <code>true</code>，否则返回 <code>false</code></li>
<li>如果 <code>x</code> 的类型为 <code>Boolean</code> ，并且 <code>x</code> 和 <code>y</code> 同为 <code>true</code> 或同为 <code>false</code> ，返回 <code>true</code>，否则返回 <code>false</code></li>
<li>如果 <code>x</code>的类型为 <code>Symbol</code> ，并且 <code>x</code> 和 <code>y</code> 具有相同的 <code>Symbol</code> 值，返回 <code>true</code>，否则返回 <code>false</code></li>
<li>如果 <code>x</code> 和 <code>y</code> 指向同一个对象，返回 <code>true</code>， 否则返回 <code>false</code><h5 id="Strict-Equality-Comparison"><a href="#Strict-Equality-Comparison" class="headerlink" title="Strict Equality Comparison"></a>Strict Equality Comparison</h5>js 中的全等（<code>===</code>）便是遵循这个规范，照搬规范如下：</li>
<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>
<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>
<li>a. 如果 <code>x</code> 为 <code>NaN</code> ，返回 <code>false</code></li>
<li>b. 如果 <code>y</code> 为 <code>NaN</code> ，返回 <code>false</code></li>
<li>c. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>
<li>d. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>true</code></li>
<li>e. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>true</code></li>
<li>f. 返回 <code>false</code></li>
</ul>
</li>
<li>按照 <code>SameValueNonNumber</code> 的结果返回<h5 id="SameValue"><a href="#SameValue" class="headerlink" title="SameValue"></a>SameValue</h5></li>
<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>
<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>
<li>a. 如果 <code>x</code> 为 <code>NaN</code> 并且 <code>y</code> 为 <code>NaN</code> ，返回 <code>true</code></li>
<li>b. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>false</code></li>
<li>c. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>false</code></li>
<li>d. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>
<li>e. 返回 <code>false</code></li>
</ul>
</li>
<li>按照 <code>SameValueNonNumber</code> 的结果返回<h5 id="SameValueZero"><a href="#SameValueZero" class="headerlink" title="SameValueZero"></a>SameValueZero</h5>这个是 <code>_.eq</code> 遵循的规范，如下：</li>
<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>
<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>
<li>a. 如果 <code>x</code> 为 <code>NaN</code> 并且 <code>y</code> 为 <code>NaN</code> ，返回 <code>true</code></li>
<li>b. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>true</code></li>
<li>c. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>true</code></li>
<li>d. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>
<li>e. 返回 <code>false</code></li>
</ul>
</li>
<li>按照 <code>SameValueNonNumber</code> 的结果返回</li>
</ol>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eq</span>(<span class="params">value, other</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value === other || (value !== value &amp;&amp; other !== other)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Strict Equality Comparison</code> 和 <code>SameValueZero</code> 只在对待 <code>NaN</code> 上有区别。<br>所以在此基础上使用<code>value !== value &amp;&amp; other !== other</code> 修改 <code>NaN</code> 的处理即可</p>
<h4 id="可以用-Object-is-替代吗？"><a href="#可以用-Object-is-替代吗？" class="headerlink" title="可以用 Object.is() 替代吗？"></a>可以用 Object.is() 替代吗？</h4><p><strong>不能</strong>，<code>Object.is</code> 同样是比较两个值是否一样，遵循是的 <code>SameValue</code> 规范，<code>Object.is(+0, -0)</code> 返回的是 <code>false</code>， 所以不能</p>
<p>可以用来判断 <code>NaN</code>, <code>Object.is(NaN, NaN)</code> 返回的是 <code>true</code> ，所以 <code>eq</code> 同样可以改成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eq</span>(<span class="params">value, other</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value === other || <span class="title class_">Object</span>.<span class="title function_">is</span>(value, other)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以用-isNaN-吗？"><a href="#可以用-isNaN-吗？" class="headerlink" title="可以用 isNaN() 吗？"></a>可以用 isNaN() 吗？</h4><p><strong>不能</strong>，如果传入的参数不为 Number 类型，会尝试转换成 Number 类型之后再做是否为 NaN 的判断。所以类似 isNaN(‘notNaN’) 返回的也是 true ，因为字符串 notNaN 会先被转换成 NaN 再做判断，这不是我们想要的结果。</p>
<h4 id="可以用-Number-isNaN-吗？"><a href="#可以用-Number-isNaN-吗？" class="headerlink" title="可以用 Number.isNaN() 吗？"></a>可以用 Number.isNaN() 吗？</h4><p>为了修复 <code>isNaN</code> 的缺陷，<code>es6</code> 在 <code>Number</code> 对象上扩展了 <code>isNaN</code> 方法，只有是 <code>NaN</code> 时才会返回 <code>true</code>，因此用 Number.isNaN 来判断是安全的。所以 <code>eq</code> 同样可以改成以下形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eq</span>(<span class="params">value, other</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value === other || (<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(value) &amp;&amp; <span class="title class_">Number</span>.<span class="built_in">isNaN</span>(other))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 内部 Hash缓存</title>
    <url>/2021/12/29/lodash%E6%BA%90%E7%A0%81%20%E5%86%85%E9%83%A8%20Hash%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="作用与用法"><a href="#作用与用法" class="headerlink" title="作用与用法"></a>作用与用法</h2><p><code>Hash</code> 顾名思义，就是要有一个离散的序列，根据 <code>key</code> 来储取数据。而在 javascript 中，最适合的无疑是对象了。</p>
<p><code>Hash</code> 在 lodash 的 <code>.internal</code> 文件夹中，作为内部文件来使用。lodash 会根据不同的数据类型选择不同的缓存方式，<code>Hash</code> 便是其中的一种方式，这种方式只能缓存 <code>key</code> 的类型符合对象键要求的数据。</p>
<p> <code>Hash</code> 只接收一个二维数组作为参数，调用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Hash</span>([[<span class="string">&#x27;test1&#x27;</span>, <span class="number">1</span>],[<span class="string">&#x27;test2&#x27;</span>,<span class="number">2</span>],[<span class="string">&#x27;test3&#x27;</span>,<span class="number">3</span>]])</span><br></pre></td></tr></table></figure>

<p>其中子项中的第一项会作为 <code>key</code> ，第二项是需要缓存的值。</p>
<p><code>Hash</code> 实例化的结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">size</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">__data__</span>: &#123;</span><br><span class="line">    <span class="attr">test1</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">test2</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">test3</span>: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存的数量储存在 <code>__data__</code> 的对象中。</p>
<h2 id="Hash与Map"><a href="#Hash与Map" class="headerlink" title="Hash与Map"></a>Hash与Map</h2><p>后面将会讲到，除了使用 <code>Hash</code> 方式缓存数据外，还会用到 <code>Map</code>，lodash 在设计 <code>Hash</code> 的数据管理接口时，也与 <code>Map</code> 的接口一致，但是不会包含 <code>Map</code> 的遍历方法。</p>
<p>先来看看这些接口都有那些：</p>
<p><img src="/images/hash.png"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">HASH_UNDEFINED</span> = <span class="string">&#x27;__lodash_hash_undefined__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">entries</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> length = entries == <span class="literal">null</span> ? <span class="number">0</span> : entries.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">clear</span>()</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">      <span class="keyword">const</span> entry = entries[index]</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">set</span>(entry[<span class="number">0</span>], entry[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">__data__</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">has</span>(key) &amp;&amp; <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">__data__</span>[key]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> -= result ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">    <span class="keyword">const</span> result = data[key]</span><br><span class="line">    <span class="keyword">return</span> result === <span class="variable constant_">HASH_UNDEFINED</span> ? <span class="literal">undefined</span> : result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">    <span class="keyword">return</span> data[key] !== <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> += <span class="variable language_">this</span>.<span class="title function_">has</span>(key) ? <span class="number">0</span> : <span class="number">1</span></span><br><span class="line">    data[key] = value === <span class="literal">undefined</span> ? <span class="variable constant_">HASH_UNDEFINED</span> : value</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Hash</span></span><br></pre></td></tr></table></figure>

<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">entries</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> length = entries == <span class="literal">null</span> ? <span class="number">0</span> : entries.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">clear</span>()</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">      <span class="keyword">const</span> entry = entries[index]</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">set</span>(entry[<span class="number">0</span>], entry[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>constructor</code> 中并没有看到初始化 <code>__data__</code> 属性和 <code>size</code> 属性，这个其实在 <code>clear</code> 方法中初始化了，后面会解释。</p>
<p>接着遍历传入的二维数组，调用 <code>set</code> 方法，初始化缓存的值。将子项的第一项作为 <code>key</code> ，第二项为缓存的值。</p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">__data__</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clear</code> 的作用是清空缓存，因此需要将 <code>size</code> 重置为 <code>0</code>。</p>
<p>将缓存的数据 <code>__data__</code> 设置为空对象。</p>
<p>这里并没有用 <code>this.__data__ = &#123;&#125;</code> 置空，而是调用了 <code>Object.create</code> 方法，并且将 <code>null</code> 作为参数。我们都知道， <code>Object.create</code> 的第一个参数为创建对象的原型对象，传入 <code>null</code> 的时候，返回的就是一个真空对象，即没有原型的对象，因此不会有原型属性的干扰，用来做缓存对象十分适合。</p>
<h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">has</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">  <span class="keyword">return</span> data[key] !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>has</code> 用来判断是否已经有缓存数据，如果缓存数据已经存在，则返回 <code>true</code> 。</p>
<p>判断也十分简单，只需要判断取出来的值是否为 <code>undefined</code> 即可。</p>
<p>这个判断有一个坑，后面会讲到。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> += <span class="variable language_">this</span>.<span class="title function_">has</span>(key) ? <span class="number">0</span> : <span class="number">1</span></span><br><span class="line">  data[key] = value === <span class="literal">undefined</span> ? <span class="variable constant_">HASH_UNDEFINED</span> : value</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set</code> 用来增加或者更新需要缓存的值。<code>set</code> 的时候需要同时维护 <code>size</code> 和在缓存的值。</p>
<p>首先调用 <code>has</code> 方法，判断对应的 <code>key</code> 是否已经被缓存过，如果已经缓存过，则 <code>size</code> 保持不变，否则 <code>size</code> 加 <code>1</code> 。</p>
<p>缓存值其实就是设置缓存对象 <code>this.__data__</code> 对应 <code>key</code> 属性的值。</p>
<p>在 <code>has</code> 中说到用 <code>data[key] !== undefined</code> 有一个坑，因为要缓存的值也可以是 <code>undefined</code> ，如果不做处理，肯定会导致判断错误。</p>
<p>lodash 的处理方式是将 <code>undefined</code> 的值转换成 <code>HASH_UNDEFINED</code> ，也即一开始便定义的 <code>__lodash_hash_undefined__</code> 字符串来储存。</p>
<p>所以在缓存中，是用字符串 <code>__lodash_hash_undefined__</code> 来替代 <code>undefined</code> 的。</p>
<p><code>set</code> 在最后还将实例 <code>this</code> 返回，以支持链式操作。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">  <span class="keyword">const</span> result = data[key]</span><br><span class="line">  <span class="keyword">return</span> result === <span class="variable constant_">HASH_UNDEFINED</span> ? <span class="literal">undefined</span> : result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get</code> 方法是从缓存中取值。</p>
<p>取值其实就是返回缓存对象中对应 <code>key</code> 的值即可。因为 <code>undefined</code> 在缓存中是以 <code>__lodash_hash_undefined__</code> 来表示的，因此遇到值为 <code>__lodash_hash_undefined__</code> 时，返回 <code>undefined</code> 。</p>
<p>其实这样还是有小小的问题的，如果需要缓存的值刚好是 <code>__lodash_hash_undefined__</code>，那取出来的值跟预设的就不一致了。但是这样情况应该很少出现吧。</p>
<p>如果是自己写的函数，可以用数组、对象或者 <code>Symbol</code> 来替代字符串，就不会出现字符串冲突的情况了。lodash 为什么不用呢，因为 lodash 是分模块发布的，不同的模块可能依赖不同版本的 <code>Hash</code> 类，这样 <code>HASH_UNDEFINED</code> 指向的内存或者 <code>Symbol</code> 值就不一致了，也就无法区分出 <code>undefined</code> 了。具体见作者的回复：<a href="https://github.com/lodash/lodash/issues/3573">HASH_UNDEFINED why not use Object or Array</a></p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">delete</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">has</span>(key) &amp;&amp; <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">__data__</span>[key]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> -= result ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>delete</code> 方法用来删除指定 <code>key</code> 的缓存。成功删除返回 <code>true</code>， 否则返回 <code>false</code>。 删除操作同样需要维护 <code>size</code> 属性和缓存值。</p>
<p>首先调用 <code>has</code> 方法来判断缓存是否存在，如果存在，用 <code>delete</code> 操作符将 <code>__data__</code> 中对应的属性删除。</p>
<p><code>delete</code> 操作符在成功删除属性时会返回 <code>true</code>，如果成功删除，则需要将 <code>size</code> 减少 <code>1</code> 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://es6.ruanyifeng.com/#docs/set-map#Map">Set 和 Map 数据结构</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create()</a></li>
</ol>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>
<p>作者：对角另一面</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 slice</title>
    <url>/2021/12/15/lodash%E6%BA%90%E7%A0%81%20slice/</url>
    <content><![CDATA[<h2 id="slice-array-start-0-end-array-length"><a href="#slice-array-start-0-end-array-length" class="headerlink" title="_.slice(array, [start=0], [end=array.length])"></a>_.slice(array, [start=0], [end=array.length])</h2><blockquote>
<p><strong>介绍:</strong>   裁剪数组<code>array</code>，从<code>start</code> 位置开始到<code>end</code>结束，但不包括<code>end</code> 本身的位置。<strong>这个方法用于代替Array#slice 来确保数组正确返回</strong>  </p>
</blockquote>
<p><strong>为什么需要替代:</strong><br>lodash 的 slice 会将数组当成密集数组对待，原生的 slice 会将数组当成稀疏数组对待。</p>
<h4 id="密集数组VS稀疏数组"><a href="#密集数组VS稀疏数组" class="headerlink" title="密集数组VS稀疏数组"></a>密集数组VS稀疏数组</h4><blockquote>
<p>稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。</p>
</blockquote>
<p>如果数组是稀疏的，那么这个数组中至少有一个以上的位置不存在元素（undefined算元素）。<br>🌰</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sparse 的 length 为10，但是 sparse 数组中没有元素，是稀疏数组</span></span><br><span class="line"><span class="keyword">var</span> sparse = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>) </span><br><span class="line"><span class="comment">// dense 每个位置都是有元素的，虽然每个元素都为undefined，为密集数组</span></span><br><span class="line"><span class="keyword">var</span> dense = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">fill</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>
<h4 id="源码总览"><a href="#源码总览" class="headerlink" title="源码总览"></a>源码总览</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">slice</span>(<span class="params">array, start, end</span>) &#123;</span><br><span class="line">  <span class="comment">// array == null, 非 === ,包含undefined的判断 undefined == null true</span></span><br><span class="line">  <span class="keyword">let</span> length = array == <span class="literal">null</span> ? <span class="number">0</span> : array.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 不传参的情况</span></span><br><span class="line">  <span class="keyword">if</span> (!length) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此部分判断是否带start或end的参</span></span><br><span class="line">  <span class="comment">// 不带的时候赋予初始值</span></span><br><span class="line">  start = start == <span class="literal">null</span> ? <span class="number">0</span> : start</span><br><span class="line">  end = end === <span class="literal">undefined</span> ? length : end</span><br><span class="line">  <span class="comment">// start 为负数的情况</span></span><br><span class="line">  <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果负数取反后比数组的长度还要大，即超出了数组的范围，则取值为0</span></span><br><span class="line">    start = -start &gt; length ? <span class="number">0</span> : (length + start)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// end最大取数组长度</span></span><br><span class="line">  end = end &gt; length ? length : end</span><br><span class="line">  <span class="comment">// end 小于0</span></span><br><span class="line">  <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    end += length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新数组的长度</span></span><br><span class="line">  length = start &gt; end ? <span class="number">0</span> : ((end - start) &gt;&gt;&gt; <span class="number">0</span>)</span><br><span class="line">  start &gt;&gt;&gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(length)</span><br><span class="line">  <span class="comment">// 截取并返回新数组</span></span><br><span class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">    result[index] = array[index + start]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>start</strong>  </p>
<blockquote>
<ul>
<li>如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取。</li>
<li>如果省略，则从索引0开始</li>
</ul>
</blockquote>
<p><strong>end</strong></p>
<blockquote>
<ul>
<li>如果该参数为负数，则它表示在原数组中的倒数第几个元素结束制取。</li>
<li>如果end被省略，则slice会一直提取到原数组的末尾。</li>
<li>如果end大于数组长度，slice也会一直提取到原数组末尾。</li>
</ul>
</blockquote>
<p><strong>关于 <code>start &gt;&gt;&gt;= 0</code></strong>  </p>
<ul>
<li>使用 <code>&gt;&gt;&gt;</code> 来确保 <code>start</code> 参数为整数或0。  </li>
<li>因为 <code>lodash</code> 的 <code>slice</code> 除了可以处理数组外，也可以处理类数组( <code>arguments</code> 对象和 <code>DOM</code> 方法的返回结果)，因此第一个参数 <code>array</code> 可能为一个对象， <code>length</code> 属性不一定为数字。</li>
<li>更多知识请参考“移位运算符”</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2 总结</title>
    <url>/2022/02/09/vue2-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="Vue的优点和特性"><a href="#Vue的优点和特性" class="headerlink" title="Vue的优点和特性"></a>Vue的优点和特性</h3><ul>
<li><p>轻量级框架：体积小，无依赖，</p>
</li>
<li><p>双向数据绑定：angular的特点，<a href="#%E5%85%B3%E4%BA%8EVue2%E4%B8%AD%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">关于Vue2中的双向绑定</a></p>
</li>
<li><p>虚拟DOM：<a href="#%E5%85%B3%E4%BA%8EVue2%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9FDOM">关于Vue2中的虚拟DOM</a></p>
</li>
<li><p>组件化</p>
</li>
</ul>
<h3 id="关于Vue2-中的虚拟DOM"><a href="#关于Vue2-中的虚拟DOM" class="headerlink" title="关于Vue2 中的虚拟DOM"></a>关于Vue2 中的虚拟DOM</h3><h4 id="什么是虚拟Dom-Virtual-Node，简称-vnode-？"><a href="#什么是虚拟Dom-Virtual-Node，简称-vnode-？" class="headerlink" title="什么是虚拟Dom(Virtual Node，简称 vnode)？"></a>什么是虚拟Dom(<code>Virtual Node</code>，简称 <code>vnode</code>)？</h4><p>简单来说就是<strong>用JS对象来模拟 DOM 结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div id=&quot;app&quot; class=&quot;container&quot;&gt;</span><br><span class="line">  	&lt;h1&gt;沐华&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>上面的模板转在虚拟 DOM 就是下面这样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>:&#123; <span class="attr">id</span>:<span class="string">&#x27;app&#x27;</span>, <span class="attr">class</span>:<span class="string">&#x27;container&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123; <span class="attr">tag</span>: <span class="string">&#x27;h1&#x27;</span>, <span class="attr">children</span>:<span class="string">&#x27;沐华&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个属性：</p>
<ul>
<li><strong>tag</strong>：必选。就是标签。也可以是组件，或者函数</li>
<li><strong>props</strong>：非必选。就是这个标签上的属性和方法</li>
<li><strong>children</strong>：非必选。就是这个标签的内容或者子节点，如果是文本节点就是字符串，如果有子节点就是数组。换句话说 如果判断 children 是字符串的话，就表示一定是文本节点，这个节点肯定没有子元素。</li>
</ul>
<h4 id="为什么需要使用虚拟DOM？"><a href="#为什么需要使用虚拟DOM？" class="headerlink" title="为什么需要使用虚拟DOM？"></a>为什么需要使用虚拟DOM？</h4><p>轻微的修改真实DOM也会导致页面重新排版，非常消耗性能。相对于DOM操作，通过JS操作更快更简单</p>
<p>Vue2把真实DOM转换成虚拟DOM，在数据发生变化时，通过diff算法对比新旧虚拟DOM，对变化的部分进行操作，而不是更新整个视图，避免不必要的性能消耗。</p>
<h4 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h4><p>实际为一个<code>patchVnode</code>的方法，通过对比新的<code>VNode</code>和<code>oldVNode</code>，做以下事情：</p>
<ul>
<li>创建节点：<code>VNode</code>中有而<code>oldVNode</code>中没有，就在<code>oldVNode</code>中创建。</li>
<li>删除节点：<code>VNode</code>中没有<code>oldVNode</code>中有，就从<code>oldVNode</code>中删除。</li>
<li>更新节点：<code>VNode</code>和<code>oldVNode</code>中都有，就以<code>VNode</code>为准，更新<code>oldVNode</code></li>
</ul>
<p>具体操作包括：</p>
<p><img src="/images/%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9patch.png" alt="Image text"></p>
<ul>
<li><p><code>VNode</code>是静态节点：不受数据变化影响，无需处理。</p>
</li>
<li><p><code>VNode</code>是文本节点：<code>VNode</code>是文本节点即表示这个节点内只包含纯文本，那么只需看<code>oldVNode</code>是否也是文本节点，如果是，那就比较两个文本是否不同，如果不同则把<code>oldVNode</code>里的文本改成跟<code>VNode</code>的文本一样。如果<code>oldVNode</code>不是文本节点，那么不论它是什么，直接调用<code>setTextNode</code>方法把它改成文本节点，并且文本内容跟<code>VNode</code>相同。</p>
</li>
<li><p><code>VNode</code>是元素节点：</p>
<ol>
<li>该节点包含子节点：此时要看旧的节点是否包含子节点，如果旧的节点里也包含了子节点，那就需要递归对比更新子节点；如果旧的节点里不包含子节点，那么这个旧节点有可能是空节点或者是文本节点，如果旧的节点是空节点就把新的节点里的子节点创建一份然后插入到旧的节点里面，如果旧的节点是文本节点，则把文本清空，然后把新的节点里的子节点创建一份然后插入到旧的节点里面。</li>
<li>该节点不包含子节点：如果该节点不包含子节点，同时它又不是文本节点，那就说明该节点是个空节点，那就好办了，不管旧节点之前里面都有啥，直接清空即可。</li>
</ol>
</li>
</ul>
<h3 id="关于Vue2中的双向绑定"><a href="#关于Vue2中的双向绑定" class="headerlink" title="关于Vue2中的双向绑定"></a>关于Vue2中的双向绑定</h3><p>vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个模块：</p>
<ul>
<li><p>监听器 <code>Observer</code> ：用来劫持并监听所有属性，如果属性发生变化，就通知订阅者；</p>
</li>
<li><p>订阅器 <code>Dep</code>：用来收集订阅者，对监听器 <code>Observer</code> 和 订阅者 <code>Watcher</code> 进行统一管理；</p>
</li>
<li><p>订阅者 <code>Watcher</code>：可以收到属性的变化通知并执行相应的方法，从而更新视图；</p>
</li>
<li><p>解析器 <code>Compile</code>：可以解析每个节点的相关指令，对模板数据和订阅器进行初始化。</p>
<p><img src="/images/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.png" alt="双向绑定"></p>
</li>
</ul>
<h4 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h4><p>我们需要从Vue初始化的过程中来学习双向绑定的过程。</p>
<ol>
<li><p><code>init.js</code> 中 调用 <code>intState()</code>，初始化 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 与 <code>watch</code></p>
</li>
<li><p><code>intState()</code>方法中有个initData方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/state.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  vm.<span class="property">_watchers</span> = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="comment">/*初始化props*/</span></span><br><span class="line">  <span class="comment">/*初始化方法*/</span></span><br><span class="line">  <span class="comment">/*初始化data*/</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*该组件没有data的时候绑定一个空对象*/</span></span><br><span class="line">    <span class="title function_">observe</span>(vm.<span class="property">_data</span> = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*初始化computed*/</span></span><br><span class="line">  <span class="comment">/*初始化watchers*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化data</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span>(<span class="params">vm</span>)&#123;</span><br><span class="line">  <span class="comment">// 得到data数据</span></span><br><span class="line">  <span class="keyword">let</span> data = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历data中的数据（处理data中的数据），</span></span><br><span class="line">  <span class="comment">// 这一步有个proxy(vm, `_data`, keys[i])，</span></span><br><span class="line">  <span class="comment">// 能将data上面的属性代理到了vm实例上</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重点是observe，开始对数据进行绑定</span></span><br><span class="line">  <span class="title function_">observe</span>(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="监听器Observer"><a href="#监听器Observer" class="headerlink" title="监听器Observer"></a>监听器<code>Observer</code></h4><p>监听器的作用是让数据变得“可观测”，即感知数据的读取和修改。<code>Vue 2.0</code> 源码中用到 <code>Object.defineProperty()</code> 给对象的属性添加 getter 和 setter，用于依赖收集和派发更新。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: any;</span><br><span class="line">  <span class="attr">dep</span>: <span class="title class_">Dep</span>;</span><br><span class="line">  <span class="attr">vmCount</span>: number; </span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">value</span>: any) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="comment">// 首先实例化 Dep 对象，这块稍后会介绍</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vmCount</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 把自身实例添加到数据对象 value 的 __ob__ 属性上</span></span><br><span class="line">    <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    <span class="comment">// 判断数组还是纯对象，调用不同方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        <span class="title function_">protoAugment</span>(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">copyAugment</span>(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 纯对象调用 walk 方法</span></span><br><span class="line">  walk (<span class="attr">obj</span>: <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// defineReactive 的功能就是定义一个响应式对象</span></span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理数组的方法</span></span><br><span class="line">  observeArray (<span class="attr">items</span>: <span class="title class_">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="title function_">observe</span>(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="defineReactive-和-defineProperty"><a href="#defineReactive-和-defineProperty" class="headerlink" title="defineReactive 和 defineProperty"></a>defineReactive 和 defineProperty</h5><p>主要关注get和set的主流程</p>
<p>初始化到这一步的目的是为了设置get和set的逻辑当有依赖去get 数据时，就会将该依赖加入到dep中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/observer/index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">key</span>: string,</span><br><span class="line">  <span class="attr">val</span>: any,</span><br><span class="line">  customSetter?: <span class="title class_">Function</span></span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">/*在闭包中定义一个dep对象*/</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*对象的子对象递归进行observe并返回子节点的Observer对象*/</span></span><br><span class="line">  <span class="keyword">let</span> childOb = <span class="title function_">observe</span>(val)</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">      <span class="comment">/*如果原本对象拥有getter方法则执行*/</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="comment">/*进行依赖收集*/</span></span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">/*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span></span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">          <span class="comment">/*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span></span><br><span class="line">          <span class="title function_">dependArray</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">      <span class="comment">/*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        <span class="comment">/*如果原本对象拥有setter方法则执行setter*/</span></span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*新的值需要重新进行observe，保证数据响应式*/</span></span><br><span class="line">      childOb = <span class="title function_">observe</span>(newVal)</span><br><span class="line">      <span class="comment">/*dep对象通知所有的观察者*/</span></span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="订阅器-Dep"><a href="#订阅器-Dep" class="headerlink" title="订阅器 Dep"></a>订阅器 <code>Dep</code></h4><h5 id="发布-订阅设计模式"><a href="#发布-订阅设计模式" class="headerlink" title="发布-订阅设计模式"></a>发布-订阅设计模式</h5><p>发布订阅模式之前，需要先讲一下什么是观察者模式</p>
<p>观察者模式定义对象间的一种一对多的依赖关系，当一个对象的状态改变时，所有依赖于它的对象都将得到通知。具体如下图：</p>
<p><img src="/images/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式"></p>
<p>那么发布订阅模式呢？</p>
<p><img src="/images/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.png" alt="发布订阅模式"></p>
<p>可以看到，发布订阅模式，相当于在观察者模式中添加了一个中介的角色来执行订阅和发送操作。订阅方和发布方可以互不关心</p>
<table>
<thead>
<tr>
<th>设计模式</th>
<th>观察者模式</th>
<th>发布订阅模式</th>
</tr>
</thead>
<tbody><tr>
<td>主体</td>
<td>Object观察者、Subject目标对象</td>
<td>Publisher发布者、Event Channel事件中心、Subscribe订阅者</td>
</tr>
<tr>
<td>主体关系</td>
<td>Subject中通过observerList记录ObServer</td>
<td>Publisher和Subscribe不想知道对方，通过中介联系</td>
</tr>
<tr>
<td>优点</td>
<td>角色明确，Subject和Object要遵循约定的成员方法</td>
<td>松散耦合，灵活度高，通常应用在异步编程中</td>
</tr>
<tr>
<td>缺点</td>
<td>紧耦合</td>
<td>当事件类型变多时，会增加维护成本</td>
</tr>
</tbody></table>
<p>本质上，设计模式应该结合应用场景和边界来理解，举个例子：观察者，具有高内聚的特点，仅适用同模块或者同一组件内使用；当需要监听的对象和执行动作不在同一模块或者组件，用订阅发布模式是适合的，能做到很好的解耦，不会破坏封装</p>
<h5 id="订阅器-Dep-的实现"><a href="#订阅器-Dep-的实现" class="headerlink" title="订阅器 Dep 的实现"></a>订阅器 <code>Dep</code> 的实现</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">target</span>: ?<span class="title class_">Watcher</span>;</span><br><span class="line">  <span class="attr">id</span>: number;</span><br><span class="line">  <span class="attr">subs</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Watcher</span>&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*添加一个观察者对象*/</span></span><br><span class="line">  addSub (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*移除一个观察者对象*/</span></span><br><span class="line">  removeSub (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*依赖收集，当存在Dep.target的时候添加观察者对象*/</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*通知所有订阅者*/</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushTarget</span> (<span class="attr">target</span>: ?<span class="title class_">Watcher</span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">push</span>(target)</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">popTarget</span> () &#123;</span><br><span class="line">  targetStack.<span class="title function_">pop</span>()</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = targetStack[targetStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="订阅者Watcher"><a href="#订阅者Watcher" class="headerlink" title="订阅者Watcher"></a>订阅者<code>Watcher</code></h3><p><code>Watcher(vm, expOrFn, cb)</code></p>
<ul>
<li><p><code>vm</code>：当前<code>vue</code>的实例对象</p>
</li>
<li><p><code>expOrFn</code>：<em>其实就是 vm._render</em>,用于更新真实DOM</p>
</li>
<li><p><code>cb</code>：<code>Watcher</code> 绑定的数据更新函数</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Dep</span>, &#123; pushTarget, popTarget &#125; <span class="keyword">from</span> <span class="string">&#x27;./dep&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">    <span class="attr">expOrFn</span>: string | <span class="title class_">Function</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">    options?: <span class="title class_">Object</span></span><br><span class="line">  )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* 这一句是重点，意味着初始化watcher会将自己设置给Dep.target</span></span><br><span class="line"><span class="comment">    	 并通过this.getter.call(vm, vm)执行render，</span></span><br><span class="line"><span class="comment">    	 render是把实例渲染成一个虚拟 Node</span></span><br><span class="line"><span class="comment">    	 会触发Dom中引用到data中数据的初始化，</span></span><br><span class="line"><span class="comment">    	 也就是触发了data中各个双向绑定数据的</span></span><br><span class="line"><span class="comment">    	 getter，内部的dep就会将依赖收集	</span></span><br><span class="line"><span class="comment">       （未进行双向绑定的data数据不参与，比如只定义了，未调用）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="comment">/*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/</span></span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="comment">// 简化源码，这一步执行render</span></span><br><span class="line">    value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将观察者实例从target栈中取出并设置给Dep.target*/</span></span><br><span class="line">    <span class="title function_">popTarget</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> 	<span class="comment">// 实际执行的是把自己加到dep中</span></span><br><span class="line">  addDep (<span class="attr">dep</span>: <span class="title class_">Dep</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解析器-Compile"><a href="#解析器-Compile" class="headerlink" title="解析器 Compile"></a>解析器 <code>Compile</code></h3><p><img src="/images/vue2%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B.jpg" alt="vue2 模板渲染过程"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>作者：沐华<br>链接：<a href="https://juejin.cn/post/7010594233253888013">https://juejin.cn/post/7010594233253888013</a></p>
<p>作者：小肥羊丶<br>链接：<a href="https://juejin.cn/post/6844904147997687821">https://juejin.cn/post/6844904147997687821</a></p>
<p>作者：zeroone001<br>链接：<a href="https://juejin.cn/post/7013227096096899085">https://juejin.cn/post/7013227096096899085</a></p>
<p>作者：monkeysoft<br>链接：<a href="https://juejin.cn/post/6850037277675454478">https://juejin.cn/post/6850037277675454478</a></p>
<p>作者：我是你的超级英雄<br>链接：<a href="https://juejin.cn/post/6844903903822086151">https://juejin.cn/post/6844903903822086151</a></p>
<p>作者：战场小包<br>链接：<a href="https://juejin.cn/post/7055441354054172709">https://juejin.cn/post/7055441354054172709</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 内部 assocIndexOf</title>
    <url>/2022/01/04/lodash%E6%BA%90%E7%A0%81%20%E5%86%85%E9%83%A8%20assocIndexOf/</url>
    <content><![CDATA[<h1 id="lodash源码分析之自减的两种形式"><a href="#lodash源码分析之自减的两种形式" class="headerlink" title="lodash源码分析之自减的两种形式"></a>lodash源码分析之自减的两种形式</h1><blockquote>
<p>这个世界需要一个特定的恶人，可以供人们指名道姓，千夫所指：“全都怪你”。</p>
<p>——村上春树《当我谈跑步时我谈些什么》</p>
</blockquote>
<p>本文为读 lodash 源码的第六篇，后续文章会更新到这个仓库中，欢迎 star：<a href="https://github.com/yeyuqiudeng/pocket-lodash">pocket-lodash</a></p>
<p>gitbook也会同步仓库的更新，gitbook地址：<a href="https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details">pocket-lodash</a></p>
<p>本篇分析的是 <code>assocIndexOf</code> 函数。</p>
<h2 id="作用与用法"><a href="#作用与用法" class="headerlink" title="作用与用法"></a>作用与用法</h2><p><code>assocIndexOf</code> 是 lodash 的内部函数，之前在《<a href="hash.md">lodash源码分析之Hash缓存</a>》介绍过一种这样的数据结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> caches = [[<span class="string">&#x27;test1&#x27;</span>, <span class="number">1</span>],[<span class="string">&#x27;test2&#x27;</span>,<span class="number">2</span>],[<span class="string">&#x27;test3&#x27;</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>

<p>这是一个二维数组，每项中的第一项作为缓存对象的 <code>key</code>，第二项为缓存的值。</p>
<p><code>assocIndexOf</code> 的作用是找出指定的 <code>key</code> 在数组中的索引值。</p>
<p>例如要找 <code>key</code> 为 <code>tes1</code> 的索引 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">assocIndexOf</span>(caches, <span class="string">&#x27;test1&#x27;</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> eq <span class="keyword">from</span> <span class="string">&#x27;../eq.js&#x27;</span></span><br></pre></td></tr></table></figure>

<p><a href="../eq.md">lodash源码分析之NaN不是NaN</a></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assocIndexOf</span>(<span class="params">array, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; length &#125; = array</span><br><span class="line">  <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">eq</span>(array[length][<span class="number">0</span>], key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很精简，让 <code>length</code> 自减，调用 <code>eq</code> 函数，从二维数组的最后一项开始，逐项获取 <code>key</code> 值，与传入的 <code>key</code> 比较，遇到匹配的，马上将该项的索引返回。如果都没找到，返回 <code>-1</code> 。返回结果的规则与 <code>indexOf</code> 一致。</p>
<h2 id="length–和–length"><a href="#length–和–length" class="headerlink" title="length–和–length"></a>length–和–length</h2><p>我们都知道自减还有另外一种前置的形式，即 <code>--length</code>，那将上面的代码改成 <code>while(--length)</code> 可不可以呢？试一下就知道了。</p>
<p>改了之后，用 <code>caches</code> 来测试下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">assocIndexOf</span>(caches, <span class="string">&#x27;test3&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">assocIndexOf</span>(caches, <span class="string">&#x27;test2&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">assocIndexOf</span>(caches, <span class="string">&#x27;test1&#x27;</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>可以看到，改了之后，只影响到了第一项的结果，也就是终止条件有问题，根本没有遍历到第一项，但是后面的结果是正确的，也就说循环体里的 <code>length</code> 没有受到影响。</p>
<p>你可能会有点疑惑，<code>while</code> 的终止条件比较的不是 <code>length</code> 吗？为什么 <code>length--</code> 正确，而 <code>--length</code> 不正确呢？</p>
<p>其实 <code>while</code> 的终止条件并不是 <code>length</code> ，而是 <code>length--</code> 表达式所返回的结果。现在来看一下 <code>length--</code> 和 <code>--length</code> 所返回的结果有什么差别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">3</span></span><br><span class="line">length-- <span class="comment">// 3</span></span><br><span class="line">length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>可以看到， <code>length--</code> 返回的结果和自减前的一致，但是 <code>length</code> 已经减少 <code>1</code> 了。因此使用 <code>length--</code> ，最后一次进入循环体应该在 <code>length</code> 等于 <code>1</code> 的时候。</p>
<p>再来看 <code>--length</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">3</span></span><br><span class="line">--length <span class="comment">// 2</span></span><br><span class="line">length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>--length</code> 返回的结果跟自减后的结果一致，因此最后一次进入循环体应该是 <code>length</code> 为 <code>2</code> 的时候，因此如果换成这种形式，会漏掉一次循环。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-expression-and-statement.html">代码之谜（二）- 语句与表达式</a></li>
</ol>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>
<p>最后，所有文章都会同步发送到微信公众号上，欢迎关注，欢迎提意见：  <img src="https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg"> </p>
<p>作者：对角另一面</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 内部 baseFindIndex</title>
    <url>/2022/01/20/lodash%E6%BA%90%E7%A0%81%20%E5%86%85%E9%83%A8%20baseFindIndex/</url>
    <content><![CDATA[<h1 id="lodash源码分析之baseFindIndex中的运算符优先级"><a href="#lodash源码分析之baseFindIndex中的运算符优先级" class="headerlink" title="lodash源码分析之baseFindIndex中的运算符优先级"></a>lodash源码分析之baseFindIndex中的运算符优先级</h1><blockquote>
<p>我悟出权力本来就是不讲理的——蟑螂就是海米；也悟出要造反，内心必须强大到足以承受任何后果才行。</p>
<p>——北岛《城门开》</p>
</blockquote>
<p>本文为读 lodash 源码的第十篇，后续文章会更新到这个仓库中，欢迎 star：<a href="https://github.com/yeyuqiudeng/pocket-lodash">pocket-lodash</a></p>
<p>gitbook也会同步仓库的更新，gitbook地址：<a href="https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details">pocket-lodash</a></p>
<h2 id="作用与用法"><a href="#作用与用法" class="headerlink" title="作用与用法"></a>作用与用法</h2><p><code>baseFindIndex</code> 是内部方法，其作用类似于ES6的 <code>findIndex</code>，查找符合条件的第一个元素的索引。</p>
<p><code>baseFindIndex</code> 除了从前向后查找外，还可以从后向前查找。</p>
<p>用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">baseFindIndex</span>([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="keyword">function</span>(<span class="params">val, index, array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val &gt; <span class="number">1</span></span><br><span class="line">&#125;, <span class="number">1</span>) <span class="comment">// 从前向后查找，从索引1开始查找，返回2</span></span><br><span class="line"><span class="title function_">baseFindIndex</span>([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="keyword">function</span>(<span class="params">val, index, array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val &gt; <span class="number">1</span></span><br><span class="line">&#125;, <span class="number">1</span>, <span class="literal">true</span>) <span class="comment">// 从后向前查找，从索引1开始查找，返回3</span></span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baseFindIndex</span>(<span class="params">array, predicate, fromIndex, fromRight</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line">  <span class="keyword">let</span> index = fromIndex + (fromRight ? <span class="number">1</span> : -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((fromRight ? index-- : ++index &lt; length)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">predicate</span>(array[index], index, array)) &#123;</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码再次展示了 lodash 的特点，短小精悍！</p>
<p>这次读源码我们从里往外看。</p>
<p>从代码中很容易看到，<code>predicate</code> 是传递进来的函数，在 <code>baseFindIndex</code> 调用该函数，如果返回的结果为真值，则中止查找，返回索引。</p>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>我们再往外看，看看 <code>while</code> 的循环条件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fromRight ? index-- : ++index &lt; length</span><br></pre></td></tr></table></figure>

<p>现在问题来了，这个三元表达式有两种可能，一种是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(fromRight ? index-- : ++index) &lt; length</span><br></pre></td></tr></table></figure>

<p>一种是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fromRight ? index-- : (++index &lt; length)</span><br></pre></td></tr></table></figure>

<p>究竟是那一种呢？这就要看运算符的优化级了，下面这个表是 MDN 上的截图：</p>
<p><img src="../images/baseFindIndex.png"></p>
<p>这个表将优化级划分成了20个级别，数字越大，优化级越高。</p>
<p>从表中可以看到，比较运算符的优先级为11，而三元表达式（条件运算符）的优化级为4，因此可以确定比较运算符的优先级要比三元表达式的要高，循环条件其实等价于第二种写法。</p>
<h3 id="增减迷局"><a href="#增减迷局" class="headerlink" title="增减迷局"></a>增减迷局</h3><p>再往上看，可以看到这句代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index = fromIndex + (fromRight ? <span class="number">1</span> : -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>在向后查找时， <code>index</code> 减少了1，而向前查找时，<code>index</code> 增加了1，为什么要这样做呢？</p>
<p>再结合循环条件看下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fromRight ? index-- : ++index &lt; length</span><br></pre></td></tr></table></figure>

<p>在向前查找时，使用的是 <code>index--</code> 表达式的运算结果，向后查找时，使用的是 <code>++index &lt; lenth</code> 表达式的运算结果。</p>
<p>从上表中也可以看出前缀自增比比较运算符的优化级要高。</p>
<p>前缀自增返回的是自增后的结果，而在循环条件中就要将索引 <code>index</code> 增加1，这样会忽略掉第一个需要遍历的元素，作为补救，在开始遍历前，需要将 <code>index</code> 减少1。</p>
<p>同理，在向前查找时，需要将索引增加1，因为在遍历开始时就已经将索引减少1。</p>
<p>那又为什么向前查找时用的是后缀自减，而不是用前缀自减呢？</p>
<p>因为在向前查找时，最终要查找到数组索引 <code>0</code> 的位置，后缀自减返回的是自减前的数值，因此当 <code>index</code> 为 <code>1</code> 时，自减后的 <code>index</code> 为 <code>0</code> ，但是在循环条件中依然拿 <code>1</code> 来进行判断，所以使得索引 <code>0</code> 得以进入循环体。</p>
<p>关于前缀自增/减和后缀自增/减的区别可以看《<a href="./assocIndexOf.md">lodash源码分析之自减的两种形式</a>》。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN:运算符优先级</a></li>
</ol>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>
<p>最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：  <img src="https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg"> </p>
<p>作者：对角另一面</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2022/02/06/webpack/</url>
    <content><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="/images/webpack_01.jpg" alt="Image text"></p>
<center>核心概念脑图</center>
****
#### 入口   `entry`
默认：`./src`

<p>单个入口用法：<code>entry: string|Array&lt;string&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry 属性的单个入口语法，是下面的简写：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">main</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象语法：<code>entry: &#123;[entryChunkName: string]: string|Array&lt;string&gt;&#125;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">    <span class="attr">vendors</span>: <span class="string">&#x27;./src/vendors.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="输出-output"><a href="#输出-output" class="headerlink" title="输出  output"></a>输出  <code>output</code></h4><p>默认：<code>./dist</code><br>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包含 filename 和 path</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home/proj/public/assets&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = config;</span><br></pre></td></tr></table></figure>
<p><strong>多个起点的情况（使用占位符确保文件具有唯一名称）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">    <span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure>
<h4 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式  mode"></a>模式  <code>mode</code></h4><p>描述：提供 <code>mode</code> 配置选项，告知 <code>webpack</code> 使用相应模式的内置优化。<br>分 <code>development</code> 和 <code>production</code></p>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><ul>
<li>用于处理非 JavaScript 文件，webpack 自身只理解 JavaScript</li>
<li>在 webpack 配置中定义 loader 时，要定义在 module.rules 中</li>
</ul>
<p>🌰：你可以使用 <code>loader</code> 告诉 <code>webpack</code> 加载 <code>CSS</code> 文件，或者将 <code>TypeScript</code> 转为 <code>JavaScript</code>。为此，首先安装相对应的 <code>loader</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br><span class="line">npm install --save-dev ts-loader</span><br></pre></td></tr></table></figure>

<p>三种方式使用loader<br><strong>配置  <code>Configuration</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123; <span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">modules</span>: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内联</strong><br>可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Styles</span> <span class="keyword">from</span> <span class="string">&#x27;style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>CLI</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">webpack --<span class="variable language_">module</span>-bind jade-loader --<span class="variable language_">module</span>-bind <span class="string">&#x27;css=style-loader!css-loader&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。</p>
<h4 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件  plugins"></a>插件  <code>plugins</code></h4>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>promise</title>
    <url>/2021/12/03/promise/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p>
<h3 id="promise-有哪三种状态："><a href="#promise-有哪三种状态：" class="headerlink" title="promise 有哪三种状态："></a>promise 有哪三种状态：</h3><p>pending(等待态)、fulfiled(成功态)、rejected(失败态)</p>
<h3 id="promise-使用来解决什么问题的？"><a href="#promise-使用来解决什么问题的？" class="headerlink" title="promise 使用来解决什么问题的？"></a>promise 使用来解决什么问题的？</h3><p>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象<br>promise可以支持多个并发的请求，获取并发请求中的数据<br>这个promise可以解决异步的问题，本身不能说promise是异步的</p>
<h3 id="promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。"><a href="#promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。" class="headerlink" title="promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。"></a>promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</h3><p>promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：  </p>
<ul>
<li>resolve ：异步操作执行成功后的回调函数</li>
<li>reject：异步操作执行失败后的回调函数  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行完成&#x27;</span>);</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;我是成功！！&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>then中可以传递两个参数–请求成功（resolved）的函数和请求失败（reject）的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">10</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;数字太大了&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data); <span class="comment">// resolved 5</span></span><br><span class="line">    &#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err); <span class="comment">// rejected 数字太大了</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a>catch的用法</h3><p>其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 效果和写在then第二个参数里面一样</span></span><br><span class="line"><span class="keyword">catch</span>会把then中的报错展示出来，例如:</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(somedata); <span class="comment">//此处的somedata未定义</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>控制台输出 ： rejected ReferenceError：somedata is not defined at p.then<br>与try/catch有相同的功能</p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>all 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调，即all中promise 的 resolve 或者 reject执行完了再执行then<br>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Promise1</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>))</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Promise2</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;<span class="title function_">resolve</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>))&#125;)</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Promise3</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;<span class="title function_">resolve</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>))&#125;)</span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title class_">Promise1</span>, <span class="title class_">Promise2</span>, <span class="title class_">Promise3</span>])</span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 三个都成功则成功</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaaaaa&#x27;</span>)  <span class="comment">// 如果promise123 不通过resolve输出，这段话不执行</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 只要有失败，则失败 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>all的作用：<br>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。  </p>
<p>参考： 作者：蔓蔓雒轩  链接：<a href="https://juejin.cn/post/6844903607968481287%E3%80%82">https://juejin.cn/post/6844903607968481287。</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn和npm命令对比</title>
    <url>/2022/01/25/yarn%E5%92%8Cnpm%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm                                     yarn</span><br><span class="line"></span><br><span class="line">npm init                                yarn init              <span class="comment">// 初始化</span></span><br><span class="line">npm i | install                         yarn  (install)        <span class="comment">// 安装依赖包</span></span><br><span class="line">npm i x --S | --save                    yarn add  x            <span class="comment">// 安装生产依赖并保存包名</span></span><br><span class="line">npm i x --D | --save-dev                yarn add x -D          <span class="comment">// 安装开发依赖并保存包名</span></span><br><span class="line">npm un | uninstall  x                   yarn remove            <span class="comment">// 删除依赖包</span></span><br><span class="line">npm i -g | npm -g i x                   yarn <span class="variable language_">global</span> add x      <span class="comment">// 全局安装</span></span><br><span class="line">npm un -g x                             yarn <span class="variable language_">global</span> remove x   <span class="comment">// 全局下载</span></span><br><span class="line">npm run dev                             yarn dev | run dev     <span class="comment">// 运行命令</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>地址</title>
    <url>/2021/12/03/%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>Hongwei Blog： <a href="https://yin-hongwei.github.io/">https://yin-hongwei.github.io/</a><br>飞鸟：<a href="https://lzxjack.top/">https://lzxjack.top/</a><br>Hexo 博客主题个性化：<a href="https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/">https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/</a><br>Mask的前端笔记: <a href="https://jsmask.gitee.io/note_blob/">https://jsmask.gitee.io/note_blob/</a><br>web全栈体系：<a href="https://hejialianghe.gitee.io/guide/">https://hejialianghe.gitee.io/guide/</a></p>
<h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2><h3 id="1-Soybean-Admin"><a href="#1-Soybean-Admin" class="headerlink" title="1.Soybean Admin"></a>1.Soybean Admin</h3><p>简介：Soybean Admin 是一个基于 Vue3、Vite、Naive UI、TypeScript 的中后台解决方案，它使用了最新的前端技术栈，并提炼了典型的业务模型，页面，包括二次封装组件、动态菜单、权限校验、粒子化权限控制等功能，它可以帮助你快速搭建企业级中后台项目，相信不管是从新技术使用还是其他方面，都能帮助到你。  </p>
<p>地址：<a href="https://github.com/honghuangdc/soybean-admin">https://github.com/honghuangdc/soybean-admin</a></p>
<h2 id="JS-相关"><a href="#JS-相关" class="headerlink" title="JS 相关"></a>JS 相关</h2><ol>
<li><code>js</code>规范：<a href="https://www.kancloud.cn/kancloud/javascript-style-guide/43119">https://www.kancloud.cn/kancloud/javascript-style-guide/43119</a></li>
</ol>
<h2 id="CSS-样式类"><a href="#CSS-样式类" class="headerlink" title="CSS 样式类"></a>CSS 样式类</h2><ol>
<li>渐变按钮： <a href="https://gradientbuttons.colorion.co/">https://gradientbuttons.colorion.co/</a></li>
</ol>
<h2 id="icon"><a href="#icon" class="headerlink" title="icon"></a>icon</h2><ol>
<li>xicons： <a href="https://www.xicons.org/#/">https://www.xicons.org/#/</a></li>
</ol>
<h2 id="vue3-富文本"><a href="#vue3-富文本" class="headerlink" title="vue3 富文本"></a>vue3 富文本</h2><p><a href="https://imzbf.github.io/md-editor-v3/index">https://imzbf.github.io/md-editor-v3/index</a></p>
<h2 id="技术网站文档"><a href="#技术网站文档" class="headerlink" title="技术网站文档"></a>技术网站文档</h2><ol>
<li>lodash：<a href="https://www.lodashjs.com/">https://www.lodashjs.com/</a></li>
<li>Vue 源码：<a href="https://ustbhuangyi.github.io/vue-analysis/">https://ustbhuangyi.github.io/vue-analysis/</a></li>
<li>lodash 源码解读：<a href="https://github.com/yeyuqiudeng/pocket-lodash">https://github.com/yeyuqiudeng/pocket-lodash</a><h2 id="语言类网站"><a href="#语言类网站" class="headerlink" title="语言类网站"></a>语言类网站</h2><h3 id="1-万词王"><a href="#1-万词王" class="headerlink" title="1.万词王"></a>1.万词王</h3>简介：解决“舌尖现象”（tip-of-the-tongue，又称话到嘴边说不出来），即暂时性忘词的问题</li>
</ol>
<p>地址：<a href="https://github.com/thunlp/WantWords/blob/main/README_ZH.md">https://github.com/thunlp/WantWords/blob/main/README_ZH.md</a></p>
<h2 id="面试类"><a href="#面试类" class="headerlink" title="面试类"></a>面试类</h2><ol>
<li>语音打卡社群(JS每日一题)维护的前端面试题库：<a href="https://github.com/febobo/web-interview">https://github.com/febobo/web-interview</a></li>
</ol>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>事件循环Eventloop</title>
    <url>/2021/09/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop/</url>
    <content><![CDATA[<h3 id="1-javascript是单线程语言"><a href="#1-javascript是单线程语言" class="headerlink" title="1. javascript是单线程语言"></a>1. javascript是单线程语言</h3><h3 id="2-所有的线程，都是有同步队列，和异步队列"><a href="#2-所有的线程，都是有同步队列，和异步队列" class="headerlink" title="2. 所有的线程，都是有同步队列，和异步队列"></a>2. 所有的线程，都是有同步队列，和异步队列</h3><p>立即执行，如函数 是同步；promise，ajax为异步</p>
<h3 id="3-任务队列-事件循环"><a href="#3-任务队列-事件循环" class="headerlink" title="3. 任务队列-事件循环"></a>3. 任务队列-事件循环</h3><p>同步任务会立刻执行，进入到主线程当中，异步任务会被放到任务队列（Event Queue）当中。<br>等待同步代码执行完毕后，返回来，再将异步中的任务放到主线程中执行,反复这样的循环，这就是事件循环。也就是先执行同步，返回来按照异步的顺序再次执行</p>
<h3 id="4-宏观任务和微观任务（先执行微观任务，再执行宏观任务）"><a href="#4-宏观任务和微观任务（先执行微观任务，再执行宏观任务）" class="headerlink" title="4. 宏观任务和微观任务（先执行微观任务，再执行宏观任务）"></a>4. 宏观任务和微观任务（先执行微观任务，再执行宏观任务）</h3><p>宏观任务主要包含：setTimeout、setInterval、script(整体代码)、I/O、UI 交互事件、setImmediate(Node.js 环境)<br>微观任务主要包括：Promise、MutaionObserver、process.nextTick(Node.js 环境)</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>移位运算符</title>
    <url>/2021/12/15/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="# 简述"></a># 简述</h2><blockquote>
<p>移位运算就是对二进制进行有规律低移位</p>
</blockquote>
<h2 id="“-lt-lt-”运算符"><a href="#“-lt-lt-”运算符" class="headerlink" title="# “&lt;&lt;”运算符"></a># “&lt;&lt;”运算符</h2><blockquote>
<p>“&lt;&lt;”运算符执行左移位运算。在移位运算过程中，符号位始终保持不变。如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> &lt;&lt; <span class="number">2</span>);  <span class="comment">// 返回值20</span></span><br></pre></td></tr></table></figure>
<h2 id="“-gt-gt-”运算符"><a href="#“-gt-gt-”运算符" class="headerlink" title="# “&gt;&gt;”运算符"></a># “&gt;&gt;”运算符</h2><blockquote>
<p>“&gt;&gt;”运算符执行有符号右移位运算。与左移运算操作相反，它把 32 位数字中的所有有效位整体右移，再使用符号位的值填充空位。移动过程中超出的值将被丢弃。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000</span> &gt;&gt; <span class="number">8</span>);  <span class="comment">// 返回值3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">1000</span> &gt;&gt; <span class="number">8</span>);  <span class="comment">//返回值 -4，负数涉及二进制的原码、反码、补码</span></span><br></pre></td></tr></table></figure>

<h2 id="“-gt-gt-gt-”运算符"><a href="#“-gt-gt-gt-”运算符" class="headerlink" title="# “&gt;&gt;&gt;”运算符"></a># “&gt;&gt;&gt;”运算符</h2><blockquote>
<p>“&gt;&gt;&gt;”运算符执行五符号右移位运算。它把无符号的 32 位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000</span> &gt;&gt; <span class="number">8</span>);  <span class="comment">//返回值3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000</span> &gt;&gt; <span class="number">8</span>);  <span class="comment">//返回值3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于负数来说，无符号右移将使用 0 来填充所有的空位，同时会把负数作为正数来处理，所得结果会非常大所以，使用无符号右移运算符时要特别小心，避免意外错误。</p>
</blockquote>
<h2 id="something-gt-gt-gt-0"><a href="#something-gt-gt-gt-0" class="headerlink" title="# something &gt;&gt;&gt; 0"></a># something &gt;&gt;&gt; 0</h2><p><code>&gt;&gt;&gt;</code> 确保 <code>something</code> 为整数或0。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数的部分简写方式</title>
    <url>/2021/06/23/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E9%83%A8%E5%88%86%E7%AE%80%E5%86%99%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="简写一"><a href="#简写一" class="headerlink" title="简写一"></a>简写一</h3><p>参数列表只有单个参数时，左边括号（）可以省去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
<h3 id="简写二"><a href="#简写二" class="headerlink" title="简写二"></a>简写二</h3><p>函数体是返回一个表达式的值时，右边大括号 {} 可以省去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(param1, param2) =&gt; &#123;</span><br><span class="line">	 <span class="keyword">return</span> param1 + param2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">(param1, param2)=&gt; param1 + param2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者返回一个字符串，布尔值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func1</span> = param1 =&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="简写三"><a href="#简写三" class="headerlink" title="简写三"></a>简写三</h3><p>返回一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(x) =&gt; &#123; <span class="keyword">return</span> &#123;<span class="string">&#x27;name&#x27;</span>:x&#125;; &#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">(x) =&gt; (&#123;<span class="string">&#x27;name&#x27;</span>:x&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 什么是执行上下文</title>
    <url>/2022/02/16/Javascript-%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h3 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h3><p>当 <code>JS</code> 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 <strong>“准备工作”</strong>，就叫做 <strong>“执行上下文(execution context 简称 <code>EC</code>)”</strong> 或者也可以叫做<strong>执行环境</strong>。</p>
<p><strong>执行上下文</strong> 为我们的可执行代码块提供了执行前的必要准备工作，例如变量对象的定义、作用域链的扩展、提供调用者的对象引用等信息。</p>
<h3 id="执行上下文类型"><a href="#执行上下文类型" class="headerlink" title="执行上下文类型"></a>执行上下文类型</h3><p>在 <code>ES3</code> 中规定了 </p>
<ol>
<li><strong>全局执行上下文</strong>：默认执行上下文，一开始就会被压到执行栈最底部</li>
<li><strong>函数执行上下文</strong>：函数被调用时创建（不管这个函数是不是被重复调用的）</li>
<li><strong>Eval 函数执行上下文</strong>：执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于并不经常使用 <code>eval</code>，所以在这里不做分析。</li>
</ol>
<h3 id="ES3-执行上下文的内容"><a href="#ES3-执行上下文的内容" class="headerlink" title="ES3 执行上下文的内容"></a>ES3 执行上下文的内容</h3><h4 id="变量对象-variable-object-简称-VO"><a href="#变量对象-variable-object-简称-VO" class="headerlink" title="变量对象(variable object 简称 VO)"></a>变量对象(<code>variable object</code> 简称 <code>VO</code>)</h4><p>简单说就是建立一个对象VO，内部的参数为三种：</p>
<p><img src="/images/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1.png" alt="变量对象"></p>
<ul>
<li><p>全局上下文的变量对象就是全局对象，对于浏览器来说就是<code>window</code>对象</p>
</li>
<li><p>函数执行上下文的变量对象(VO)，只有在函数被调用时，VO 被激活成<strong>活动对象</strong>(AO)，才能访问到其中额属性和方法</p>
</li>
</ul>
<p><strong>有一点需要注意，只有函数声明（function declaration）会被加入到变量对象中，而函数表达式（function expression）会被忽略。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="comment">// b是变量声明，会被加入变量对象，但是后面的function不会被加入变量对象</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自执行函数/立即调用函数表达式（Immediately Invoked Function Expression 简写 IIFE） -- 闭包</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">p</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>



<h4 id="活动对象（-activation-object-简称-AO）"><a href="#活动对象（-activation-object-简称-AO）" class="headerlink" title="活动对象（ activation object 简称 AO）"></a>活动对象（ <code>activation object</code> 简称 <code>AO</code>）</h4><p>函数进入执行阶段时，原本不能访问的变量对象被激活成为一个活动对象，自此，我们可以访问到其中的各种属性。</p>
<blockquote>
<p>其实变量对象和活动对象是一个东西，只不过处于不同的状态和阶段而已。</p>
</blockquote>
<h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p><strong>作用域</strong>规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。变量的查找顺序为：</p>
<p><img src="/images/%E6%9F%A5%E6%89%BE%E5%8F%98%E9%87%8F.png" alt="查找变量顺序"></p>
<p>这样由多个执行上下文的变量对象构成的链表就是 <strong>作用域链</strong></p>
<p><strong>函数的作用域在函数创建时就已经确定了</strong>，<strong>函数创建时</strong>，内部通过名为 <code>[[scope]]</code> 的内部属性保存所有父变量对象到其中；<strong>函数执行时</strong>，会创建一个执行环境，然后通过复制函数的 <code>[[scope]]</code> 属性中的对象构建起执行环境的作用域链，然后，变量对象 <code>VO</code> 被激活生成 <code>AO</code> 并添加到作用域链的前端，完整作用域链创建完成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Scope</span> = [<span class="variable constant_">AO</span>].<span class="title function_">concat</span>([[<span class="title class_">Scope</span>]]);</span><br></pre></td></tr></table></figure>



<h4 id="调用者信息（当前可执行代码块的调用者，this）"><a href="#调用者信息（当前可执行代码块的调用者，this）" class="headerlink" title="调用者信息（当前可执行代码块的调用者，this）"></a>调用者信息（当前可执行代码块的调用者，this）</h4><p>如果当前函数被作为对象方法调用或使用 <code>bind</code> <code>call</code> <code>apply</code> 等 <code>API</code> 进行委托调用，则将当前代码块的调用者信息（<code>this value</code>）存入当前执行上下文，否则默认为全局对象调用。</p>
<h4 id="执行上下文数据结构模拟"><a href="#执行上下文数据结构模拟" class="headerlink" title="执行上下文数据结构模拟"></a>执行上下文数据结构模拟</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">executionContext：&#123;</span><br><span class="line">  [variable object | activation object]：&#123;</span><br><span class="line">    <span class="variable language_">arguments</span>,</span><br><span class="line">    <span class="attr">variables</span>: [...],</span><br><span class="line">    <span class="attr">funcions</span>: [...]</span><br><span class="line">  &#125;,</span><br><span class="line">  scope <span class="attr">chain</span>: variable object + all parents scopes</span><br><span class="line">  <span class="attr">thisValue</span>: context object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES3执行上下文的声明周期"><a href="#ES3执行上下文的声明周期" class="headerlink" title="ES3执行上下文的声明周期"></a>ES3执行上下文的声明周期</h3><h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><p><strong>函数调用时但未执行函数体内的代码的这段时间</strong></p>
<p>创建阶段就是对上述的变量对象、作用域链、调用者this进行创建</p>
<h4 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h4><p>这个阶段js代码逐条执行，对创建阶段创建的这些变量进行赋值和顺着作用域链访问。</p>
<p>需要注意的是，该阶段会把执行上下文压入执行栈，该执行上下文有内部函数调用时，又会创建新的执行上下文，交出控制权。</p>
<h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><p>函数执行完，当前执行上下文弹出执行栈并销毁，控制权交给执行栈上一层的执行上下文</p>
<blockquote>
<p>闭包情况不同</p>
</blockquote>
<h3 id="ES5的执行上下文"><a href="#ES5的执行上下文" class="headerlink" title="ES5的执行上下文"></a>ES5的执行上下文</h3><p>去除了 变量对象 和 活动对象的概念，以<strong>词法环境组件</strong> <strong>（</strong> <strong><code>LexicalEnvironment component</code>）</strong> 和 <strong>变量环境组件****（</strong> <strong><code>VariableEnvironment component</code>）</strong>替代。</p>
<p>数据结构模拟如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ExecutionContext</span> = &#123;</span><br><span class="line">  <span class="title class_">ThisBinding</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">this</span> <span class="attr">value</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">  // 词法环境</span></span><br><span class="line"><span class="language-xml">  LexicalEnvironment = &#123; ... &#125;,</span></span><br><span class="line"><span class="language-xml">  // 变量环境</span></span><br><span class="line"><span class="language-xml">  VariableEnvironment = &#123; ... &#125;,</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><p><strong>环境记录器</strong>：存储变量和函数声明的实际位置。</p>
<p><strong>外部环境的引用</strong>：意味着它可以访问其父级词法环境（作用域）。</p>
<p>数据结构模拟如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">LexicalEnvironment</span> = &#123;</span><br><span class="line">  <span class="comment">//环境记录器 </span></span><br><span class="line">  <span class="title class_">EnvironmentRecord</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 外部环境的引用</span></span><br><span class="line">  <span class="attr">outer</span>: &lt;<span class="literal">null</span>&gt; | 父级词法环境</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>词法环境分</li>
</ul>
<p>​        <strong>全局环境</strong>（全局上下文中的词法环境）；</p>
<p>​        <strong>函数环境</strong>（函数上下文的词法环境）</p>
<ul>
<li>环境记录器分</li>
</ul>
<p>​        <strong>声明式环境记录器</strong>存储变量、函数和参数；</p>
<p>​        <strong>对象环境记录器</strong>用来定行下文义出现在<strong>全局上下文</strong>中的变量和函数的关系。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局环境</span></span><br><span class="line"><span class="title class_">GlobalExectionContext</span> = &#123;</span><br><span class="line">  <span class="title class_">LexicalEnvironment</span>: &#123;</span><br><span class="line">    <span class="title class_">EnvironmentRecord</span>: &#123;</span><br><span class="line">      <span class="title class_">Type</span>: <span class="string">&quot;Object&quot;</span>,</span><br><span class="line">      <span class="comment">// 在这里绑定标识符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 全局环境没有外部环境引用，所以为null</span></span><br><span class="line">    <span class="attr">outer</span>: &lt;<span class="literal">null</span>&gt; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数环境</span></span><br><span class="line"><span class="title class_">FunctionExectionContext</span> = &#123;</span><br><span class="line">  <span class="title class_">LexicalEnvironment</span>: &#123;</span><br><span class="line">    <span class="comment">// 声明式环境记录器</span></span><br><span class="line">    <span class="title class_">EnvironmentRecord</span>: &#123;</span><br><span class="line">      <span class="title class_">Type</span>: <span class="string">&quot;Declarative&quot;</span>,</span><br><span class="line">      <span class="comment">// 在这里绑定标识符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数的外部环境引用为父级词法环境或者全局词法环境</span></span><br><span class="line">    <span class="attr">outer</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">or</span> <span class="attr">outer</span> <span class="attr">function</span> <span class="attr">environment</span> <span class="attr">reference</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>另外，函数环境的声明式环境记录器中包含一个<code>arguments</code> 对象，和函数的传参相关，用来存储索引和参数的映射</p>
</blockquote>
<h4 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h4><p>变量环境也是一种词法环境。但由于ES6 中定义了const 和 let，所以：</p>
<p>词法环境主要存储（<code>let</code> 和 <code>const</code>）绑定的函数声明和变量</p>
<p>变量环境存储 <code>var</code> 绑定的函数声明和变量</p>
<p>所以根据词法环境和变量环境，结合实际的变量函数的声明，数据结构模拟如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">e, f</span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = <span class="title function_">multiply</span>(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局环境</span></span><br><span class="line"><span class="title class_">GlobalExectionContext</span> = &#123;</span><br><span class="line">  <span class="comment">// 绑定this，全局，浏览器中为window</span></span><br><span class="line">  <span class="title class_">ThisBinding</span>: &lt;Global Object&gt;,</span><br><span class="line">  // 词法环境</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">  	// 全局环境中的环境记录器为对象环境记录器</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">  		// let const定义的变量，表示 未初始化</span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">		// 全局环境中的外部环境引用为 null</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">	// 变量环境</span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // var 定义的变量，因为变量提升，所以是undefined</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 函数环境 -- 函数引用后到函数执行前创建</span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">  		// 声明式环境记录器</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 记录函数传参</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">	VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h3><p>顾名思义，执行上下文栈是栈结构的，因此遵循 <code>LIFO</code>（后进先出）的特性，代码执行期间创建的所有执行上下文，都会交给执行上下文栈进行管理。</p>
<p>当 JS 引擎开始解析脚本代码时，会首先创建一个<strong>全局执行上下文</strong>，压入栈底（这个全局执行上下文从创建一直到程序销毁，都会存在于栈的底部）。</p>
<p>每当引擎发现一处函数调用，就会创建一个新的<strong>函数执行上下文</strong>压入栈内，并将控制权交给该上下文，待函数执行完成后，即将该执行上下文从栈内弹出销毁，将控制权重新给到栈内上一个执行上下文。</p>
<h3 id="栈溢出经常出现在递归中"><a href="#栈溢出经常出现在递归中" class="headerlink" title="栈溢出经常出现在递归中"></a>栈溢出经常出现在递归中</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>作者：不写bug的米公子<br>链接：<a href="https://juejin.cn/post/6844904158957404167">https://juejin.cn/post/6844904158957404167</a></p>
<p>作者：子非<br>链接：<a href="https://juejin.cn/post/6844903682283143181">https://juejin.cn/post/6844903682283143181</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 作用域和闭包</title>
    <url>/2022/02/16/Javascript-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p><strong>作用域</strong> 指程序中定义变量的区域，它决定了当前执行代码对变量的访问权限。</p>
<p><strong>全局作用域</strong>：程序的最外层作用域，一直存在</p>
<p><strong>函数作用域</strong>：<strong>函数定义时</strong>创建的作用域，包含在父级/全局作用域内</p>
<p>由于作用域的限制，每段独立的执行代码块只能访问自己作用域和外层作用域中的变量，无法访问到内层作用域的变量。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当本地作用域内找不到目标变量时，就需要去查找父级作用域内是否存在目标变量，一直到全局作用域。我们把这种作用域的嵌套机制，称为 作用域链。</p>
<p><strong>需要注意的是，函数的参数也在函数作用域内</strong></p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域也叫静态作用域，是作用域的一种模型或者机制，例如规定函数在定义时确定其作用域。</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>简单来说，花括号内 <code>&#123;...&#125;</code> 的区域就是块级作用域区域。</p>
<p><code>javascript</code> 中大部分情况下，只有两种作用域类型：<strong>全局作用域</strong> 和 <strong>函数作用域</strong>，那么 <code>javascript</code> 中的块级作用域呢？</p>
<p>这里需要分<code>let</code> 和 <code>var</code></p>
<ul>
<li><code>let</code>  、<code>const</code> 所声明的变量会创建自己的块级作用域，创建的作用域是定义它的块级代码及其中包括的子块中，且无法自动往全局变量 <code>window</code> 上绑定属性。</li>
<li><code>var</code> 定义的变量，作用域为定义它的函数，或者全局，并且是能自动往全局对象 <code>window</code> 上绑定属性的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>

<h3 id="创建作用域"><a href="#创建作用域" class="headerlink" title="创建作用域"></a>创建作用域</h3><ol>
<li><p>定义函数，创建函数作用域</p>
</li>
<li><p>使用 <code>let</code> 和 <code>const</code> 创建块级作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>try catch</code> 创建作用域，<code>err</code> 仅存在于 <code>catch</code> 子句中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="title function_">undefined</span>(); <span class="comment">// 强制产生异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>( err ); <span class="comment">// TypeError: undefined is not a function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( err ); <span class="comment">// ReferenceError: `err` not found</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>eval</code>或者<code>with</code>，不推荐</p>
</li>
</ol>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>能够访问其他函数内部变量的函数，被称为 <strong>闭包</strong>。</p>
<h3 id="闭包的应用场景"><a href="#闭包的应用场景" class="headerlink" title="闭包的应用场景"></a>闭包的应用场景</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理函数仅作为单例的管控</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">ProxyCreateSingleton</span> = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> instance</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance) <span class="keyword">return</span> instance;</span><br><span class="line">    <span class="keyword">return</span> instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Singleton</span> = <span class="keyword">function</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Singleton</span>.<span class="property">property</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Winner</span> = <span class="keyword">new</span> <span class="title class_">ProxyCreateSingleton</span>(<span class="string">&#x27;Winner&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Looser</span> = <span class="keyword">new</span> <span class="title class_">ProxyCreateSingleton</span>(<span class="string">&#x27;Looser&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Winner</span> === <span class="title class_">Looser</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Winner</span>.<span class="title function_">getName</span>());  <span class="comment">// &#x27;Winner&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Looser</span>.<span class="title function_">getName</span>());  <span class="comment">// &#x27;Winner&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="模拟私有属性"><a href="#模拟私有属性" class="headerlink" title="模拟私有属性"></a>模拟私有属性</h4><p><code>javascript</code> 没有 <code>java</code> 中那种 <code>public</code> <code>private</code> 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟私有属性</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGeneratorFunc</span> () &#123;</span><br><span class="line">  <span class="keyword">var</span> _name = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> _age = <span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="keyword">return</span> _name;&#125;,</span><br><span class="line">      <span class="attr">getAge</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="keyword">return</span> _age;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title function_">getGeneratorFunc</span>()();</span><br><span class="line">obj.<span class="title function_">getName</span>(); <span class="comment">// John</span></span><br><span class="line">obj.<span class="title function_">getAge</span>(); <span class="comment">// 22</span></span><br><span class="line">obj.<span class="property">_age</span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><blockquote>
<p>把一个多参数的函数转换成一系列使用一个参数的函数的技术</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 柯里化前</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b,c,d,e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成柯里化函数</span></span><br><span class="line"><span class="keyword">let</span> _fn = <span class="title function_">curry</span>(fn)</span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);     <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);   <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)(<span class="number">5</span>);   <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<p>具体封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数的 length 属性，获取函数的形参个数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, len = fn.length</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> _curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, len)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_curry</span>(<span class="params">fn, len, ...args</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...params</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> _args = [...args, ...params]</span><br><span class="line">    <span class="keyword">if</span>(_args.<span class="property">length</span> &gt;= len)&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, _args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> _curry.<span class="title function_">call</span>(<span class="variable language_">this</span>, fn, len, ..._args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _fn = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">a,b,c,d,e</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c,d,e)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);     <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);   <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)(<span class="number">5</span>);   <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line"><span class="title function_">_fn</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<p>柯里化的优势之一就是 <strong>参数的服用</strong>，即可以通过传入不同的参数来生成新的函数，例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">typeOf</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> toString = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line">        <span class="keyword">const</span> map = &#123;</span><br><span class="line">            <span class="string">&#x27;[object Boolean]&#x27;</span>	 : <span class="string">&#x27;boolean&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[object Number]&#x27;</span> 	 : <span class="string">&#x27;number&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[object String]&#x27;</span> 	 : <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[object Function]&#x27;</span>  : <span class="string">&#x27;function&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[object Array]&#x27;</span>     : <span class="string">&#x27;array&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[object Date]&#x27;</span>      : <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[object RegExp]&#x27;</span>    : <span class="string">&#x27;regExp&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[object Undefined]&#x27;</span> : <span class="string">&#x27;undefined&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[object Null]&#x27;</span>      : <span class="string">&#x27;null&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;[object Object]&#x27;</span> 	 : <span class="string">&#x27;object&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> map[toString.<span class="title function_">call</span>(obj)] === value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数的服用</span></span><br><span class="line"><span class="keyword">var</span> isNumber = <span class="title function_">typeOf</span>(<span class="string">&#x27;number&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> isFunction = <span class="title function_">typeOf</span>(<span class="string">&#x27;function&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> isRegExp = <span class="title function_">typeOf</span>(<span class="string">&#x27;regExp&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">isNumber</span>(<span class="number">0</span>); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="title function_">isFunction</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isRegExp</span>(&#123;&#125;); <span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则判断也可以用上面的方式，通过传入判断手机号和邮箱的正则来生成两个函数</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包的问题-–-内存泄漏"><a href="#闭包的问题-–-内存泄漏" class="headerlink" title="闭包的问题 – 内存泄漏"></a>闭包的问题 – 内存泄漏</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( a );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = <span class="title function_">foo</span>();</span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// 这就形成了一个闭包</span></span><br></pre></td></tr></table></figure>

<p><code>javascript</code> 内部的垃圾回收机制用的是<strong>引用计数收集</strong>：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 <code>0</code> 的变量标记为失效变量并将之清除从而释放内存。</p>
<p> <code>foo</code> 函数作用域隔绝了外部环境，所有变量引用都在函数内部完成，<code>foo</code> 运行完成以后，内部的变量就应该被销毁，内存被回收。然而闭包导致了全局作用域始终存在一个 <code>baz</code> 的变量在引用着 <code>foo</code> 内部的 <code>bar</code> 函数，这就意味着 <code>foo</code> 内部定义的 <code>bar</code> 函数引用数始终为 <code>1</code>，垃圾运行机制就无法把它销毁。更糟糕的是，<code>bar</code> 有可能还要使用到父作用域 <code>foo</code> 中的变量信息，那它们自然也不能被销毁… JS 引擎无法判断你什么时候还会调用闭包函数，只能一直让这些数据占用着内存。</p>
<blockquote>
<p>这种由于闭包使用过度而导致的内存占用无法释放的情况，我们称之为：内存泄露。</p>
</blockquote>
<h4 id="内存泄漏的其他情况"><a href="#内存泄漏的其他情况" class="headerlink" title="内存泄漏的其他情况"></a>内存泄漏的其他情况</h4><ul>
<li><strong>全局变量的无意创建</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2 变量b泄漏到全局中</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>DOM</code> 的事件绑定，移除 <code>DOM</code> 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露</li>
</ul>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>使用严格模式</li>
<li>关注 <code>DOM</code> 生命周期，在销毁阶段记得解绑相关事件</li>
<li>避免过度使用闭包</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>作者：不写bug的米公子<br>链接：<a href="https://juejin.cn/post/6844904165672484871">https://juejin.cn/post/6844904165672484871</a></p>
<p>作者：云中桥<br>链接：<a href="https://juejin.cn/post/6844903882208837645">https://juejin.cn/post/6844903882208837645</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>apply，call，bind的实现</title>
    <url>/2022/02/17/apply%EF%BC%8Ccall%EF%BC%8Cbind%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>学习了<code>call</code>和<code>apply</code>会发现：**它们作用都是一样的，改变函数里的<code>this</code>指向为第一个参数<code>thisArg</code>，如果明确有多少参数，那可以用<code>call</code>，不明确则可以使用<code>apply</code>。我们只需要模拟实现<code>apply</code>，<code>call</code>可以根据参数个数都放在一个数组中，给到<code>apply</code>即可。</p>
</blockquote>
<h2 id="模拟实现apply"><a href="#模拟实现apply" class="headerlink" title="模拟实现apply"></a>模拟实现apply</h2><h3 id="ES5规范中-Function-prototype-apply-thisArg-argArray-采用如下步骤"><a href="#ES5规范中-Function-prototype-apply-thisArg-argArray-采用如下步骤" class="headerlink" title="ES5规范中**Function.prototype.apply (thisArg, argArray)**采用如下步骤"></a>ES5规范中**Function.prototype.apply (thisArg, argArray)**采用如下步骤</h3><ol>
<li><p>如果 <code>IsCallable(func)</code> 是 <code>false</code>, 则抛出一个 <code>TypeError</code> 异常。</p>
</li>
<li><p>如果 <code>argArray</code> 是 <code>null</code> 或 <code>undefined</code>, 则返回提供 <code>thisArg</code> 作为 <code>this</code> 值并以空参数列表调用 <code>func</code> 的 <code>[[Call]]</code> 内部方法的结果。</p>
</li>
<li><p>如果 <code>Type(argArray)</code> 不是 <code>Object</code>, 则抛出一个 <code>TypeError</code> 异常。</p>
</li>
<li><p>4~7 略</p>
</li>
<li><p>提供 <code>thisArg</code> 作为 <code>this</code> 值并以 <code>argList</code> 作为参数列表，调用 <code>func</code> 的 <code>[[Call]]</code> 内部方法，返回结果。<code>apply</code> 方法的 <code>length</code> 属性是 <code>2</code>。</p>
</li>
</ol>
<h3 id="结合上文进行实现"><a href="#结合上文进行实现" class="headerlink" title="结合上文进行实现"></a>结合上文进行实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器环境 非严格模式</span></span><br><span class="line"><span class="comment">// 全局this</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getGlobalObject</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property">property</span>.<span class="property">applyFn</span> = <span class="keyword">function</span> <span class="title function_">apply</span>(<span class="params">thisArg, argsArray</span>)&#123;</span><br><span class="line">  <span class="comment">// 1.如果 `IsCallable(func)` 是 `false`, 则抛出一个 `TypeError` 异常。</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> thisArg !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="variable language_">this</span> + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.如果 argArray 是 null 或 undefined, 则</span></span><br><span class="line">  <span class="comment">// 参数作空列表</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> argsArray === <span class="string">&#x27;undefind&#x27;</span> || argsArray === <span class="literal">null</span>)&#123;</span><br><span class="line">    argsArray = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 3.如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常</span></span><br><span class="line">  <span class="keyword">if</span>(argArray !== <span class="keyword">new</span> <span class="title class_">Object</span>(argArray))&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;CreateListFromArrayLike called on non-object&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果thisArg 为null 或 undefined ，this指向全局</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> thisArg === <span class="string">&#x27;undefind&#x27;</span> || thisArg === <span class="literal">null</span>)&#123;</span><br><span class="line">    thisArg = <span class="title function_">getGlobalObject</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  thisArg = <span class="keyword">new</span> <span class="title class_">Object</span>(thisArg)</span><br><span class="line">  <span class="comment">// 接下来的部分先如此写，还有优化空间</span></span><br><span class="line">  <span class="keyword">var</span> __fn = <span class="string">&#x27;__fn&#x27;</span>;</span><br><span class="line">  <span class="comment">// 在对象中绑定调用函数，并执行调用者函数</span></span><br><span class="line">  thisArg[__fn] = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> result = thisArg[__fn](...argsArray)</span><br><span class="line">  <span class="comment">// 调用完删除该参数，恢复原样</span></span><br><span class="line">  <span class="keyword">delete</span> thisArg[__fn]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="同名覆盖"><a href="#同名覆盖" class="headerlink" title="同名覆盖"></a>同名覆盖</h3><blockquote>
<p>新增参数<code>__fn</code> 可能同名覆盖原有<code>thisArg</code>上的<code>__fn</code>，之后还会<code>delete</code></p>
</blockquote>
<p>解决思路：</p>
<ol>
<li>采用<code>ES6</code> <code>Sybmol()</code> 生成独一无二的参数</li>
<li>或生成UUID （通用唯一识别码），模拟实现独一无二的<code>key</code></li>
<li>直接生成时间戳作为<code>key</code></li>
</ol>
<p>一般使用时间戳就行了</p>
<h3 id="使用了ES6扩展符"><a href="#使用了ES6扩展符" class="headerlink" title="使用了ES6扩展符..."></a>使用了<code>ES6</code>扩展符<code>...</code></h3><p>如果有人非要你不能使用扩展符的话😡😡😡😡</p>
<p>可以使用：</p>
<ol>
<li><p><code>eval</code> 使用来执行函数</p>
</li>
<li><p>毕竟<code>eval</code>是魔鬼。可以采用<code>new Function()</code>来生成执行函数。</p>
<p><strong>语法</strong>：<strong>new Function (arg1, arg2,  functionBody)</strong></p>
<p><strong>arg1, arg2, … argN</strong>：被函数使用的参数的名称必须是合法命名的。</p>
<p><strong>functionBody</strong>：一个含有包括函数定义的<code>JavaScript</code>语句的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;return a + b&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">2</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p><code>thisArg[__fn](...argsArray)</code> 需要转换成 </p>
<p><code>new Function(code)(thisArg, __fn, argsArray)</code></p>
<p>那么code就需要是这种形式：<code>return arg[0][arg[1]](参数1，参数2，...)</code>，<code>arg[0]</code>表示函数<code>thisArg</code>，<code>arg[1]</code> 就是<code>fn</code>，然后遍历<code>argsArray</code>作为参数。</p>
<p>所以写一个把展开运算符改写成遍历<code>array</code>函数来生成code的函数代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目的是为了生成</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateFunctionCode</span>(<span class="params">argArrayLength</span>)&#123;</span><br><span class="line">  <span class="comment">// argArrayLength 表示参数集合</span></span><br><span class="line">  <span class="keyword">var</span> code = <span class="string">&#x27;return arguments[0][arguments[1]](&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; argsArrayLength; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      code += <span class="string">&#x27;,&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    code += <span class="string">&#x27;arguments[2][&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  code += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>undefined</code> 在<code>ES3、ES5</code>中 <code>undefined</code> 是能修改的</p>
<p>需要用 <code>void 0</code> 替代 <code>undefined</code></p>
</li>
</ol>
<p>所以结合上文最后部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">thisArg = <span class="keyword">new</span> <span class="title class_">Object</span>(thisArg);</span><br><span class="line"><span class="keyword">var</span> __fn = <span class="string">&#x27;__&#x27;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="comment">//  万一还是有对应数据 先存储一份，删除后，再恢复该值</span></span><br><span class="line"><span class="keyword">var</span> originVal = thisArg[__fn]</span><br><span class="line"><span class="comment">// 判断是否有原始值 -- 后文用</span></span><br><span class="line"><span class="keyword">var</span> hasOriginalVal = thisArg.<span class="title function_">hasOwnProperty</span>(__fn)</span><br><span class="line">thisArg[__fn] = <span class="variable language_">this</span></span><br><span class="line"><span class="keyword">var</span> code = <span class="title function_">generateFunctionCode</span>(argsArray.<span class="property">length</span>)</span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">new</span> <span class="title class_">Function</span>(code)(thisArg, __fn, argsArray)</span><br><span class="line"><span class="keyword">delete</span> thisArg[__fn]</span><br><span class="line"><span class="comment">// 删除后会恢复原值</span></span><br><span class="line"><span class="keyword">if</span>(hasOriginalVal)&#123;</span><br><span class="line">  thisArg[__fn] = originVal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> reslut</span><br></pre></td></tr></table></figure>

<h2 id="利用apply模拟实现call"><a href="#利用apply模拟实现call" class="headerlink" title="利用apply模拟实现call"></a>利用apply模拟实现call</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property">property</span>.<span class="property">callFn</span> = <span class="keyword">function</span> <span class="title function_">call</span>(<span class="params">thisArg</span>)&#123;</span><br><span class="line">  <span class="comment">// 通过arguments获取函数的参数</span></span><br><span class="line">  <span class="keyword">var</span> argArray = []</span><br><span class="line">  <span class="keyword">var</span> argumentsLength = <span class="variable language_">arguments</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; argumentsLength - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    argsArray[i] = argsArray[i + <span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 或 argsArray.push(arguments[i + 1]);</span></span><br><span class="line">    <span class="comment">// push内部会多一层循环，不是最优解</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">applayFn</span>(thisArg, argsArry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现bind"><a href="#实现bind" class="headerlink" title="实现bind"></a>实现bind</h2><ol>
<li><code>bind</code>是<code>Functoin</code>原型链中<code>Function.prototype</code>的一个属性，每个函数都可以调用它。</li>
<li><code>bind</code>本身是一个函数名为<code>bind</code>的函数，返回值也是函数，函数名是<code>bound</code>。（打出来就是<code>bound加上一个空格</code>）。</li>
<li><code>bound</code>执行后返回值是原函数的返回值，<code>bind</code>函数形参是1，<code>bound</code>形参数为原函数形参数。</li>
</ol>
<p>所以简单实现如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property">property</span>.<span class="property">bindFn</span> = <span class="keyword">function</span> <span class="title function_">bind</span>(<span class="params">thisArg</span>)&#123;</span><br><span class="line">  <span class="comment">// 判断调用者是否是function</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="variable language_">this</span> + <span class="string">&#x27;must be a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span> <span class="comment">// 存调用者</span></span><br><span class="line">  <span class="comment">// 取出除开thisArg外的参数，转成数组</span></span><br><span class="line">  <span class="keyword">var</span> args = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">var</span> bound = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 第二个括号内的参数，转成数组</span></span><br><span class="line">    <span class="keyword">var</span> boundArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">    <span class="comment">// 例如 func.bind(obj, 1)(2)</span></span><br><span class="line">    <span class="comment">// 那么[1]就是args，[2] 就是 boundArgs</span></span><br><span class="line">    <span class="comment">// [1, 2] 就是 调用者的接收的参数</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(thisArg, args.<span class="title function_">concat</span>(boundArgs))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;若川&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">original</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bound = original.<span class="title function_">bindFn</span>(obj, <span class="number">1</span>);</span><br><span class="line"><span class="title function_">bound</span>(<span class="number">2</span>); <span class="comment">// &#x27;若川&#x27;, [1, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="关于构造函数"><a href="#关于构造函数" class="headerlink" title="关于构造函数"></a>关于构造函数</h3><p>来看看原版<code>bind</code>在遇到构造函数的情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;若川&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">original</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// original &#123;&#125;， 不是指向obj</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;typeof this&#x27;</span>, <span class="keyword">typeof</span> <span class="variable language_">this</span>); <span class="comment">// object</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = b;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>);  <span class="comment">// original &#123;name: 2&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b]); <span class="comment">// 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bound = original.<span class="title function_">bind</span>(obj, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> newBoundResult = <span class="keyword">new</span> <span class="title function_">bound</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newBoundResult, <span class="string">&#x27;newBoundResult&#x27;</span>); <span class="comment">// original &#123;name: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>因为<code>new bound</code>的返回值是以<code>original</code>原函数构造器生成的新对象。<code>original</code>原函数的<code>this</code>指向的就是这个新对象。</p>
<p><code>new</code> 做了什么</p>
<blockquote>
<ol>
<li>创建了一个全新的对象。</li>
<li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。</li>
<li>生成的新对象会绑定到函数调用的this。</li>
<li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。</li>
<li>如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</li>
</ol>
</blockquote>
<p>所以 bound这一段需要改改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bound = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// bind返回的函数 的参数转成数组</span></span><br><span class="line">  <span class="keyword">var</span> boundArgs = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">var</span> finalArgs = args.<span class="title function_">concat</span>(boundArgs);</span><br><span class="line">  <span class="comment">// new 调用时，其实this instanceof bound判断也不是很准确。es6 new.target就是解决这一问题的。</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> bound)&#123;</span><br><span class="line">    <span class="comment">// 这里是实现上文描述的 new 的第 1, 2, 4 步</span></span><br><span class="line">    <span class="comment">// 1.创建一个全新的对象</span></span><br><span class="line">    <span class="comment">// 2.并且执行[[Prototype]]链接</span></span><br><span class="line">    <span class="comment">// 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span></span><br><span class="line">    <span class="comment">// self可能是ES6的箭头函数，没有prototype，所以就没必要再指向做prototype操作。</span></span><br><span class="line">    <span class="keyword">if</span>(self.<span class="property"><span class="keyword">prototype</span></span>)&#123;</span><br><span class="line">      <span class="comment">// ES5 提供的方案 Object.create()</span></span><br><span class="line">      <span class="comment">// bound.prototype = Object.create(self.prototype);</span></span><br><span class="line">      <span class="comment">// 但 既然是模拟ES5的bind，那浏览器也基本没有实现Object.create()</span></span><br><span class="line">      <span class="comment">// 所以采用 MDN ployfill方案 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">Empty</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">      <span class="title class_">Empty</span>.<span class="property"><span class="keyword">prototype</span></span> = self.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">      bound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里是实现上文描述的 new 的第 3 步</span></span><br><span class="line">    <span class="comment">// 3.生成的新对象会绑定到函数调用的`this`。</span></span><br><span class="line">    <span class="keyword">var</span> result = self.<span class="title function_">apply</span>(<span class="variable language_">this</span>, finalArgs);</span><br><span class="line">    <span class="comment">// 这里是实现上文描述的 new 的第 5 步</span></span><br><span class="line">    <span class="comment">// 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，</span></span><br><span class="line">    <span class="comment">// 那么`new`表达式中的函数调用会自动返回这个新的对象。</span></span><br><span class="line">    <span class="keyword">var</span> isObject = <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; result !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> isFunction = <span class="keyword">typeof</span> result === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(isObject || isFunction)&#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数，返回执行结果</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="title function_">apply</span>(thisArg, finalArgs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> bound;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>作者：若川</p>
<p>链接：<a href="https://juejin.cn/post/6844903728147857415">https://juejin.cn/post/6844903728147857415</a></p>
<p>作者：若川<br>链接：<a href="https://juejin.cn/post/6844903718089916429">https://juejin.cn/post/6844903718089916429</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-什么是this关键字</title>
    <url>/2022/02/17/JavaScript-%E4%BB%80%E4%B9%88%E6%98%AFthis%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="什么是this关键字"><a href="#什么是this关键字" class="headerlink" title="什么是this关键字"></a>什么是this关键字</h2><blockquote>
<p>this 关键字为当前<strong>执行环境</strong>的 <code>ThisBinding</code>，函数的调用方式决定了this的值</p>
</blockquote>
<p>在JavaScript中，**<code>this</code>的指向是调用时决定的，而不是创建时决定的**，这就会导致<code>this</code>的指向会让人迷惑，简单来说，<code>this</code>具有运行期绑定的特性。</p>
<h2 id="全局上下文-–-this-指代全局对象"><a href="#全局上下文-–-this-指代全局对象" class="headerlink" title="全局上下文 – this 指代全局对象"></a>全局上下文 – this 指代全局对象</h2><p>浏览器中<code>var</code> === <code>this.</code> === <code>winodw.</code></p>
<h2 id="函数上下文-–-this-取决于函数调用的方式"><a href="#函数上下文-–-this-取决于函数调用的方式" class="headerlink" title="函数上下文 – this 取决于函数调用的方式"></a>函数上下文 – this 取决于函数调用的方式</h2><h3 id="直接调用-–-指向全局"><a href="#直接调用-–-指向全局" class="headerlink" title="直接调用 – 指向全局"></a>直接调用 – 指向全局</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>() === <span class="variable language_">window</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="call-、applay-、bind-–-this绑定到第一个参数上"><a href="#call-、applay-、bind-–-this绑定到第一个参数上" class="headerlink" title="call()、applay()、bind() – this绑定到第一个参数上"></a>call()、applay()、bind() – this绑定到第一个参数上</h3><p>这三个方法后面依次会讲</p>
<h3 id="箭头函数中"><a href="#箭头函数中" class="headerlink" title="箭头函数中"></a>箭头函数中</h3><p><strong>所有的箭头函数都没有自己的<code>this</code>，它只会从自己的作用域链的上一层继承<code>this</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如多层嵌套中</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) &#125;,</span><br><span class="line">  <span class="attr">b</span>: &#123;</span><br><span class="line">    <span class="attr">c</span>: <span class="function">() =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">a</span>()   <span class="comment">// 没有使用箭头函数打出的是obj</span></span><br><span class="line">obj.<span class="property">b</span>.<span class="title function_">c</span>()  <span class="comment">//打出的是window对象！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码obj对象中的b,c并没有创建作用域</span></span><br><span class="line"><span class="comment">// 所以c对应的箭头函数的作用域链还是obj，那么obj中的this还是window</span></span><br><span class="line"><span class="comment">// if for 也没有作用域，详见 作用域的创建</span></span><br></pre></td></tr></table></figure>



<p><strong>不能用<code>call</code>方法修改里面的<code>this</code></strong></p>
<h3 id="在对象的方法中"><a href="#在对象的方法中" class="headerlink" title="在对象的方法中"></a>在对象的方法中</h3><p>this 指向调用函数的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;axuebin&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// axuebin</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;xb&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;axuebin&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName = person.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getName</span>()); <span class="comment">// xb</span></span><br><span class="line"><span class="comment">// 调用着改变</span></span><br></pre></td></tr></table></figure>

<h3 id="在构造函数中"><a href="#在构造函数中" class="headerlink" title="在构造函数中"></a>在构造函数中</h3><p><strong><code>this</code>被绑定到正在构造的新对象。</strong></p>
<p>构造函数创建对象的步骤：</p>
<ol>
<li>创建新对象</li>
<li>将this指向这个对象</li>
<li>给对象赋值（属性、方法）</li>
<li>返回this</li>
</ol>
<p>所以<code>this</code>就是指向创建的这个对象上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">25</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;:&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;axuebin&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// axuebin</span></span><br><span class="line">person.<span class="title function_">say</span>(); <span class="comment">// axuebin:25</span></span><br></pre></td></tr></table></figure>

<h3 id="在DOM事件处理函数中"><a href="#在DOM事件处理函数中" class="headerlink" title="在DOM事件处理函数中"></a>在DOM事件处理函数中</h3><p><strong><code>this</code>指向触发事件的元素，也就是始事件处理程序所绑定到的DOM节点。</strong></p>
<h3 id="HTML标签内联事件处理函数中"><a href="#HTML标签内联事件处理函数中" class="headerlink" title="HTML标签内联事件处理函数中"></a>HTML标签内联事件处理函数中</h3><p><strong><code>this</code>指向所在的DOM元素</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(this);&quot;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h2><h3 id="call的使用"><a href="#call的使用" class="headerlink" title="call的使用"></a>call的使用</h3><p><strong>语法</strong>：<code>func.call(thisArg, arg1, arg2)</code></p>
<ul>
<li><p>**<code>thisArg</code>**：指定的 <code>this</code> 值，非严格模式下，指定为 <code>null</code> 和 <code>undefined</code>，那么 <code>this</code> 指向全局对象；</p>
</li>
<li><p>**arg1，arg2，…**：指定的参数列表</p>
</li>
<li><p><strong>返回值</strong>：调用方法<code>func</code>的返回值，没有就为 <code>undefined</code></p>
</li>
</ul>
<h3 id="apply的使用"><a href="#apply的使用" class="headerlink" title="apply的使用"></a>apply的使用</h3><p><strong>语法</strong>：<code>func.apply(thisArg, [argsArray])</code></p>
<p><strong>thisArg</strong>：可选值，和<code>call</code>中定义一致</p>
<p><strong>argsArray</strong>：可选的，一个数组或类数组对象（es5中开始可以使用类数组对象），其中的数组元素作为参数传给<code>func</code>函数，该参数为 <code>null</code> 和 <code>undefined</code>，表示不传入参数</p>
<p><strong>返回值</strong>：调用有指定<code>this</code>值和参数的函数的结果。</p>
<h3 id="call-和-apply-的区别"><a href="#call-和-apply-的区别" class="headerlink" title="call 和 apply 的区别"></a>call 和 apply 的区别</h3><p><code>apply</code>只接收两个参数，第二个参数可以是数组也可以是类数组，其实也可以是对象，后续的参数忽略不计。<code>call</code>接收第二个及以后一系列的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子1：浏览器环境 非严格模式下</span></span><br><span class="line"><span class="keyword">var</span> doSth = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSth.<span class="title function_">call</span>(<span class="literal">undefined</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// this 是 window // [1, 2]</span></span><br><span class="line">doSth.<span class="title function_">call</span>(<span class="string">&#x27;0&#x27;</span>, <span class="number">1</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;); <span class="comment">// this 是 String(&#x27;0&#x27;) // [1, &#123;a: 1&#125;]</span></span><br><span class="line"></span><br><span class="line">doSth.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// this是window  // [1, 2]</span></span><br><span class="line">doSth.<span class="title function_">apply</span>(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// this 是 Number(0) // [1, 2]</span></span><br><span class="line">doSth.<span class="title function_">apply</span>(<span class="literal">true</span>); <span class="comment">// this 是 Boolean(true) // [undefined, undefined]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子2：浏览器环境 严格模式下</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> doSth2 = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>([a, b]);</span><br><span class="line">&#125;</span><br><span class="line">doSth2.<span class="title function_">call</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// this 是 0 // [1, 2]</span></span><br><span class="line">doSth2.<span class="title function_">apply</span>(<span class="string">&#x27;1&#x27;</span>); <span class="comment">// this 是 &#x27;1&#x27; // [undefined, undefined]</span></span><br><span class="line">doSth2.<span class="title function_">apply</span>(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// this 是 null // [1, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="call-和-apply-的实现"><a href="#call-和-apply-的实现" class="headerlink" title="call 和 apply 的实现"></a>call 和 apply 的实现</h3><p>详情请见单独文章《apply，call，bind的实现》</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><strong>语法</strong>：<code>func.bind(thisArg, arg1, arg2)</code></p>
<ul>
<li>**<code>thisArg</code>**：指定的 <code>this</code> 值，非严格模式下，指定为 <code>null</code> 和 <code>undefined</code>，那么 <code>this</code> 指向全局对象；</li>
<li>**arg1，arg2，…**：指定的参数列表</li>
<li><strong>返回值</strong>：是个函数，函数名是<code>bound</code>。（打印出来就是<code>bound加上一个空格</code>）</li>
</ul>
<p>所以实际使用需要：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function func(a, b)&#123;</span><br><span class="line">	console.log(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">	name: &#x27;张三&#x27;,</span><br><span class="line">	age: 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let bindF = func.bind(obj, 1, 2)</span><br><span class="line">bindF()</span><br><span class="line">// 或者func.bind(obj,1,2)()</span><br><span class="line">// 支持函数柯里化 func.bind(obj)(1,2) 或者 func.bind(obj, 1)(2)</span><br></pre></td></tr></table></figure>

<h3 id="bind-的实现"><a href="#bind-的实现" class="headerlink" title="bind 的实现"></a>bind 的实现</h3><p>详情请见单独文章 《apply，call，bind的实现》</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>作者：limingru<br>链接：<a href="https://juejin.cn/post/6844903573428371464">https://juejin.cn/post/6844903573428371464</a></p>
<p><a href="https://github.com/axuebin/articles/issues/6">JavaScript基础心法——this · Issue #6 · axuebin/articles (github.com)</a></p>
<p>作者：若川<br>链接：<a href="https://juejin.cn/post/6844903728147857415">https://juejin.cn/post/6844903728147857415</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-原型，原型链，继承</title>
    <url>/2022/02/25/JavaScript-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%8C%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h2><blockquote>
<p>谈JavaScript原型离不开构造函数，在 JavaScript 中，用 <code>new</code> 关键字来调用的函数，称为构造函数。</p>
</blockquote>
<p>构造函数在书写时，建议首字母大写，用于和普通函数作区分</p>
<h3 id="为什么需要使用构造函数"><a href="#为什么需要使用构造函数" class="headerlink" title="为什么需要使用构造函数"></a>为什么需要使用构造函数</h3><p>构造函数相当于一个模板，能够创建多个共享特定属性和行为的<strong>对象</strong>，例如可以用构造函数创建多个人员对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> zhangSan = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">LiSi</span> = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;李四&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> wangWu = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;王五&#x27;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<h3 id="构造函数的执行过程"><a href="#构造函数的执行过程" class="headerlink" title="构造函数的执行过程"></a>构造函数的执行过程</h3><p>当一个函数在定义的时候我们并不知道他是不是构造函数，只有当以 new 关键字来调用的时候，才能说它是一个构造函数。</p>
<p>1️⃣  当以 <code>new</code> 关键字调用时，会创建一个新的内存空间</p>
<p>2️⃣ 函数体内部的 <code>this</code> 指向该内存</p>
<p>3️⃣ 执行函数体内的代码</p>
<p>4️⃣ 默认返回 <code>this</code></p>
<h3 id="new-的过程发生了什么"><a href="#new-的过程发生了什么" class="headerlink" title="new 的过程发生了什么"></a>new 的过程发生了什么</h3><p>以如下🌰来介绍</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&#x27;Lisa&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son); <span class="comment">//Father &#123;name: &quot;Lisa&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>(1) 创建了一个空对象 <code>son: &#123;&#125;</code></p>
<p>(2) 为 son 准备原型链连接 <code>son.__proto__ = Father.prototype</code></p>
<p>(3) 重新绑定this，使构造函数的this指向新对象 <code>Father.call(son)</code></p>
<h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><p>构造函数执行过程的最后一步是默认返回 <code>this</code> 。言外之意，构造函数的返回值还有其它情况。下面我们就来聊聊关于构造函数返回值的问题。</p>
<p>◾ 没有手动添加返回值，默认返回 <code>this</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person1</span>();</span><br><span class="line"><span class="comment">// this 指向该内存空间，该内存空间被p1接收</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>) <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>

<p>◾ 手动添加一个基本数据类型的返回值，最终还是返回 this</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">28</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person2</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">age</span>);   <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>

<p>◾ 手动添加一个复杂数据类型(对象)的返回值，最终返回该对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">height</span> = <span class="string">&#x27;180&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="title class_">Person3</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3.<span class="property">height</span>);  <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3.<span class="property">length</span>);  <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3[<span class="number">0</span>]);      <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>看了别人手写实现new的过程，简单说明下大致原因</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在重新绑定this的时候执行函数得到返回值</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Father</span>.<span class="title function_">call</span>(son)</span><br><span class="line"><span class="comment">// 如果是一个对象类型的话，直接返回构造函数的返回值，不是的话返回son对象</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> || result <span class="keyword">instanceof</span> <span class="title class_">Function</span> ? result : son;</span><br></pre></td></tr></table></figure>

<h2 id="二、原型与原型链"><a href="#二、原型与原型链" class="headerlink" title="二、原型与原型链"></a>二、原型与原型链</h2><blockquote>
<p>原型又叫原型对象，Father.prototype 就是原型</p>
</blockquote>
<p>原型的作用 —— <strong>共享数据和方法，不用开辟新的空间存储</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">log</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;姓名：&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>, <span class="string">&#x27; 年龄：&#x27;</span>, <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title function_">A</span>(<span class="string">&#x27;ls&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">a.<span class="title function_">log</span>() <span class="comment">// 姓名： zs  年龄： 18</span></span><br><span class="line">b.<span class="title function_">log</span>() <span class="comment">// 姓名： ls  年龄： 18</span></span><br></pre></td></tr></table></figure>

<p>上面的🌰还能发现个特点：<strong>原型中的 <code>this</code> 指向的是实例</strong></p>
<blockquote>
<p>原型与原型层层相链接的过程即为原型链。</p>
</blockquote>
<p>先从构造函数为🌰，梳理几个关键点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>()</span><br></pre></td></tr></table></figure>

<p>1️⃣ <code>__proto__</code> 叫做对象的原型，每个对象实例都会有</p>
<p>2️⃣ 实例a(对象)的原型指向A(构造函数)的原型对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __proto__ 叫做对象的原型，每个对象实例都会有</span></span><br><span class="line"><span class="comment">// 实例a(对象)的原型指向A(构造函数)的原型对象</span></span><br><span class="line">a.<span class="property">__proto__</span> === A.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="comment">// 因为这一点，所以对象可以使用构造函数prototype中的属性和方法</span></span><br></pre></td></tr></table></figure>

<p>3️⃣ A(构造函数)的原型对象的constructor指向构造函数本身</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === A</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%9B%BE.png" alt="原型链图"></p>
<h3 id="原型查找方式"><a href="#原型查找方式" class="headerlink" title="原型查找方式"></a>原型查找方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Star</span>(<span class="params">name</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">	<span class="comment">// (1)首先看obj对象身上是否有dance方法，如果有，则执行对象身上的方法</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">dance</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (2)如果没有dance方法，就去构造函数原型对象prototype身上去查找dance这个方法。</span></span><br><span class="line"><span class="title class_">Star</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">dance</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// (3)如果再没有dance方法，就去Object原型对象prototype身上去查找dance这个方法。</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">dance</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// (4)如果再没有，则会报错。</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">&#x27;小红&#x27;</span>);</span><br><span class="line">obj.<span class="title function_">dance</span>();</span><br></pre></td></tr></table></figure>

<h2 id="三、继承-ES5"><a href="#三、继承-ES5" class="headerlink" title="三、继承 - ES5"></a>三、继承 - ES5</h2><p>ES6之前并没有给我们提供extends继承，我们可以通过构造函数+原型对象模拟实现继承。</p>
<p>继承属性，利用call改变this指向。但该方法只可以继承属性，实例不可以使用父类的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">dance</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am dancing&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">son.<span class="title function_">dance</span>();   <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<p>如何继承父类的方法？</p>
<p>利用<code>Son.prototype = Father.prototype</code>改变原型指向，但是，子类原型增加方法，父类的原型也会被影响。所以可以让子类的原型指向父类的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">dance</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am dancing&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">  <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>()</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sing</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am singing&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//&#123;dance: ƒ, constructor: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h2><blockquote>
<p>类的本质还是一个函数，类就是构造函数的另一种写法。</p>
</blockquote>
<p>通过构造函数创建实例，是可以变量提升的。 es6中的类，必须先定义，才可以实例化。</p>
<h3 id="类中定义的方法都是体现在class-prototype中的"><a href="#类中定义的方法都是体现在class-prototype中的" class="headerlink" title="类中定义的方法都是体现在class.prototype中的"></a><strong>类中定义的方法都是体现在class.prototype中的</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sing</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> red = <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&#x27;小红&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> green = <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&#x27;小绿&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(red.<span class="property">sing</span> === green.<span class="property">sing</span>); <span class="comment">//true</span></span><br><span class="line">red.<span class="title function_">sing</span>() <span class="comment">// 小红</span></span><br><span class="line">green.<span class="title function_">sing</span>() <span class="comment">// 小绿</span></span><br></pre></td></tr></table></figure>

<h3 id="向类中添加方法"><a href="#向类中添加方法" class="headerlink" title="向类中添加方法"></a><strong>向类中添加方法</strong></h3><p>通过Object.assign，在原型上追加方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>,&#123;</span><br><span class="line">  <span class="title function_">dance</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> red = <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&#x27;小红&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(red.<span class="title function_">dance</span>());<span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h3 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<h2 id="五、继承-ES6"><a href="#五、继承-ES6" class="headerlink" title="五、继承 - ES6"></a>五、继承 - ES6</h2><p>使用 <code>extends</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dance</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我在跳舞&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name,score</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">score</span> = score;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sing</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span> +<span class="string">&#x27;,&#x27;</span>+<span class="variable language_">this</span>.<span class="title function_">dance</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;小红&#x27;</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>1️⃣ 子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>
<p>2️⃣ 由于上述原因，constructor方法中的super方法必须先定义，然后才能调用this对象。</p>
<p>3️⃣ 如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code>作为函数调用时，代表父类的构造函数。</p>
<p><code>super</code>返回的是子类的实例，即<code>super</code>内部的<code>this</code>指的是子类的实例，相当于Father.call(this)</p>
<p>作者：零和幺<br>链接：<a href="https://juejin.cn/post/6844903571306053640">https://juejin.cn/post/6844903571306053640</a></p>
<p>作者：萌m子<br>链接：<a href="https://juejin.cn/post/6844904093828251662">https://juejin.cn/post/6844904093828251662</a></p>
<p>作者：何方圆<br>链接：<a href="https://juejin.cn/post/7039228671911002149">https://juejin.cn/post/7039228671911002149</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>面试</tag>
      </tags>
  </entry>
</search>
