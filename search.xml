<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git Flow &amp; 常用Git命名和操作</title>
    <url>/2021/12/10/Git%20Flow%20&amp;%20%E5%B8%B8%E7%94%A8Git%E5%91%BD%E5%90%8D%E5%92%8C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="简述-Git-Flow"><a href="#简述-Git-Flow" class="headerlink" title="# 简述 Git Flow"></a># 简述 Git Flow</h2><p>简单来说，<code>Git Flow</code> 就是一套规范的代码管理流程</p>
<h2 id="分支应用情景"><a href="#分支应用情景" class="headerlink" title="# 分支应用情景"></a># 分支应用情景</h2><ul>
<li>在<code>Git Flow</code>中，主要的分支有<code>master</code>、<code>develop</code>、<code>hotfix</code>、<code>release</code>、<code>feature</code> 这五种分支  </li>
<li><code>develop</code> 和 <code>master</code>会被保留，其他的随任务结束而删除  <h3 id="master-分支"><a href="#master-分支" class="headerlink" title="# master 分支"></a># master 分支</h3></li>
<li>存放稳定上线版本</li>
<li>这个分支的来源只能从别的分支合并过来，开发者不会直接commit到这个分支上。</li>
<li>通常我们也会在这个分支上的提交打上版本号标签。<h3 id="develop-分支"><a href="#develop-分支" class="headerlink" title="# develop 分支"></a># develop 分支</h3></li>
<li>这个分支主要是所有开发的基础分支。</li>
<li>当要添加功能时，所有功能都是从这个分支切出去的，而功能分支实现后，也都会合并回来这个分支中。<h3 id="hotfix-分支"><a href="#hotfix-分支" class="headerlink" title="# hotfix 分支"></a># hotfix 分支</h3></li>
<li>用途：处理紧急线上问题</li>
<li>基于master分支创建</li>
<li>修复完成，合并到master分支和develop分支中<h3 id="release-分支-预上线分支"><a href="#release-分支-预上线分支" class="headerlink" title="# release 分支 (预上线分支)"></a># release 分支 (预上线分支)</h3></li>
<li>当<code>develop</code>分支完成需求后，就可以从<code>develop</code>分支中开一个<code>release</code>分支，进行上线前最后的测试。</li>
<li>测试完成后，释放<code>release</code>分支将会同时合并到<code>master</code>以及<code>develop</code>分支中。<h3 id="feature分支"><a href="#feature分支" class="headerlink" title="# feature分支"></a># feature分支</h3></li>
<li>当我们需要补充功能的时候，就会从develop分支中开一个feature分支进行功能开发。</li>
<li>当功能实现后，在将feature分支合并到develop分支中，等待最后的测试发布。</li>
</ul>
<h3 id="具体场景"><a href="#具体场景" class="headerlink" title="# 具体场景"></a># 具体场景</h3><h4 id="1-新功能开发"><a href="#1-新功能开发" class="headerlink" title="1. 新功能开发"></a>1. 新功能开发</h4><blockquote>
<p>基于<code>develop</code>，新建功能分支 <code>f1-feature</code>，切换到该分支下进行开发<br>需要多人开发时，可以推到远端分支<br>完成功能开发，将该分支合并到<code>develop</code>分支，**并删除<code>f1-feature</code>**分支</p>
</blockquote>
<p><strong>2021/12/24 – 更新：使用 <code>rebase</code> 整理提交</strong><br>关于新分支（命名<code>f1-feature</code> 或者 <code>feat/xxx</code> ）<br><strong>1. develop有更新内容需要同步</strong>  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">提交代码</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;message&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换 develop 拉取代码</span></span><br><span class="line">git checkout develop</span><br><span class="line">git pull</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换 本地分支（例：feature），合并代码</span></span><br><span class="line">git checkout feature</span><br><span class="line">git rebase -i develop</span><br></pre></td></tr></table></figure>
<p>-i 意为合并多次提交，运行后显示前几次的提交内容如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 281812b message1  </span><br><span class="line">pick e60c7f4 message2  </span><br></pre></td></tr></table></figure>
<p>当需要合并所有提交的时候，保留一个<code>pick</code>，其余修改为 <code>s</code>，如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 281812b message1  </span><br><span class="line">s e60c7f4 message2  </span><br></pre></td></tr></table></figure>
<p><code>:wq</code> 提交修改</p>
<p><strong>代码冲突时，修改冲突后，重新<code>add</code>提交，执行<code>git commit</code>，展示<code>message</code>，根据需求自行修改，再 <code>git rebase --continue</code></strong>  </p>
<p><strong>2. 本地分支开发完毕需要合并到develop</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">先提交本地分支代码 add --&gt; commit</span></span><br><span class="line">git rebase -i develop</span><br><span class="line"><span class="meta"># </span><span class="language-bash">后面的操作如1所示</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">需要新增的步骤：切换到develop分支，merge 本地分支</span></span><br><span class="line">git merge feature</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">最后 git push</span></span><br></pre></td></tr></table></figure>
<p>需要注意的点：在 <code>git rebase -i develop</code> 的时候，根据自身情况选择对commit是否进行合并</p>
<h4 id="2-发布上线"><a href="#2-发布上线" class="headerlink" title="2. 发布上线"></a>2. 发布上线</h4><p>基于<code>develop</code>分支创建<code>release-0.1</code>分支作为预上线分支,有问题，在该分支上修改，最后切换到<code>develop</code>和<code>master</code>分支下合并该分支，删除<code>release-0.1</code>分支</p>
<h4 id="3-紧急bug修复"><a href="#3-紧急bug修复" class="headerlink" title="3.紧急bug修复"></a>3.紧急bug修复</h4><p>基于<code>master</code>分支新建<code>hotfix-bug1</code>分支进行修改，修改完切换到<code>develop</code>和<code>master</code>分支下合并该分支，删除<code>hotfix-bug1</code>分支</p>
<h3 id="常用git操作"><a href="#常用git操作" class="headerlink" title="# 常用git操作"></a># 常用git操作</h3><p><strong>分支相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 查看本地分支</span><br><span class="line">git branch</span><br><span class="line">返回🌰</span><br><span class="line">*master</span><br><span class="line"></span><br><span class="line">// 查看远程分支</span><br><span class="line">git branch -r</span><br><span class="line">返回🌰</span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line">// 查看本地和远程分支</span><br><span class="line">git branch -a</span><br><span class="line">返回🌰</span><br><span class="line">*master</span><br><span class="line"> remotes/origin/master</span><br><span class="line"> </span><br><span class="line">// 切换分支</span><br><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line">// 创建并切换到该分支</span><br><span class="line">git checkout -b &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line">// 删除分支</span><br><span class="line">git branch -d &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line">// 删除远端分支</span><br><span class="line">git push origin -d &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line">// 重命名分支</span><br><span class="line">git branch -m &lt;oldbranch-name&gt; &lt;newbranch-name&gt;</span><br><span class="line"></span><br><span class="line">// 合并指定分支到当前分支</span><br><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git flow</tag>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Js防抖与节流</title>
    <url>/2021/12/06/Js%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="函数防抖（debounce）"><a href="#函数防抖（debounce）" class="headerlink" title="函数防抖（debounce）"></a>函数防抖（debounce）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</span><br></pre></td></tr></table></figure>
<p>实际🌰：监听input输入来请求接口，未进行防抖时，键入内容就会请求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟一段ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">content</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ajax request &#x27;</span> + content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inputa = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;unDebounce&#x27;</span>)</span><br><span class="line"></span><br><span class="line">inputa.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title function_">ajax</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模拟一段ajax请求</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">content</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ajax request &#x27;</span> + content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fun, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(fun.<span class="property">id</span>)</span><br><span class="line">        fun.<span class="property">id</span> = <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fun.<span class="title function_">call</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;, delay) </span><br><span class="line">        <span class="comment">// setTimeout 返回一个唯一id，在delay时间内clearTimeout 该id可阻止事件</span></span><br><span class="line">        <span class="comment">// 该处的作用是：事件触发时间内再次触发事件则停止原事件，重新计时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> inputb = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;debounce&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> debounceAjax = <span class="title function_">debounce</span>(ajax, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">inputb.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="title function_">debounceAjax</span>(e.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>函数防抖就像法师发技能的时候要读条，技能读条没完再按技能就会重新读条。</strong></p>
<h3 id="函数节流（throttle）"><a href="#函数节流（throttle）" class="headerlink" title="函数节流（throttle）"></a>函数节流（throttle）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</span><br></pre></td></tr></table></figure>

<p>实际🌰：需求：无论多快输入，但每1s执行一次请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function throttle(fun, delay) &#123;</span><br><span class="line">    let last, deferTimer</span><br><span class="line">    return function (args) &#123;</span><br><span class="line">        let that = this</span><br><span class="line">        let _args = arguments</span><br><span class="line">        let now = +new Date()</span><br><span class="line">        clearTimeout(deferTimer) // 重复调用清空上一次的setTime</span><br><span class="line">        // 当第一次调用 或者 键入操作持续一秒后（此时由于clear的作用，last一直没更新，last + delay 会小于now） 会走 else分支</span><br><span class="line">        if (last &amp;&amp; now &lt; last + delay) &#123;</span><br><span class="line">            deferTimer = setTimeout(function () &#123;</span><br><span class="line">                last = now</span><br><span class="line">                fun.apply(that, _args)</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            last = now</span><br><span class="line">            fun.apply(that,_args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let throttleAjax = throttle(ajax, 1000)</span><br><span class="line"></span><br><span class="line">let inputc = document.getElementById(&#x27;throttle&#x27;)</span><br><span class="line">inputc.addEventListener(&#x27;keyup&#x27;, function(e) &#123;</span><br><span class="line">    throttleAjax(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li>
<li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li>
</ul>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><ul>
<li>debounce<ul>
<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
</li>
<li>throttle<ul>
<li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li>
</ul>
</li>
</ul>
<h2 id="lodash-中的防抖节流方法"><a href="#lodash-中的防抖节流方法" class="headerlink" title="lodash 中的防抖节流方法"></a>lodash 中的防抖节流方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 安装 `lodash`</span><br><span class="line">npm i --save lodash</span><br><span class="line">// 引用</span><br><span class="line">import _ from &#x27;lodash&#x27;</span><br><span class="line"></span><br><span class="line">// 使用防抖</span><br><span class="line">const debounced = _.debounced(func, wait, options)</span><br></pre></td></tr></table></figure>
<p><strong>各参数</strong><br><code>func</code> (Function): 要防抖动的函数。<br><code>[wait=0]</code> (number): 需要延迟的毫秒数。<br><code>[options=]</code> (Object): 选项对象。<br><code>[options.leading=false]</code> (boolean): 指定在延迟开始前调用。<br><code>[options.maxWait]</code> (number): 设置 func 允许被延迟的最大值。<br><code>[options.trailing=true]</code> (boolean): 指定在延迟结束后调用。</p>
<p><strong>需要注意的点</strong><br><code>_.debounced()</code>的返回值为<code>func</code>的返回值，默认参数情况（例如：<code>_.debounced(func, 500)</code>）在防抖阶段，因为还未执行<code>func</code>的<code>return</code>，返回为<code>undefined</code>  </p>
<p><strong>节流<code>_.throttle()</code></strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>作者：薄荷前端<br>链接：<a href="https://juejin.cn/post/6844903669389885453">https://juejin.cn/post/6844903669389885453</a><br>来源：稀土掘金</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>防抖节流</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 chunk</title>
    <url>/2021/12/20/lodash%E6%BA%90%E7%A0%81%20chunk/</url>
    <content><![CDATA[<h2 id="chunk-array-size-1"><a href="#chunk-array-size-1" class="headerlink" title="_.chunk(array, [size=1])"></a>_.chunk(array, [size=1])</h2><blockquote>
<p>介绍：将数组（<code>array</code>）拆分成多个 <code>size</code> 长度的区块，并将这些区块组成一个新数组。 如果array 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。<br>参数：<br><code>array</code> (Array): 需要处理的数组<br><code>[size=1]</code> (number): 每个数组区块的长度</p>
</blockquote>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p><code>chunk</code> 函数在前端可以用来缓解一些性能问题。例如大量的 <code>DOM</code> 操作，可以分块让浏览器在空闲的时候处理，避免页面卡死。如下面的代码，向页面中插入大量的 <code>DOM</code> 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [] <span class="comment">// 1万条数据</span></span><br><span class="line"><span class="keyword">const</span> chunks = _.<span class="title function_">chunk</span>(arr, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> append = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (chunks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> current = chunks.<span class="title function_">pop</span>()</span><br><span class="line">    current.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> node = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">      node.<span class="property">innerText</span> = item</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(node)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">setTimeout</span>(append, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">append</span>()</span><br></pre></td></tr></table></figure>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> slice <span class="keyword">from</span> <span class="string">&#x27;./slice.js&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><code>chunk</code> 的原理归结起来就是切割和放置。  </p>
<p><code>chunk</code> 最后返回的结果如<code>[[1],[1],[1]]</code>的形式，放置就是将切割下来的块放置到数组容器中。  </p>
<p>那要怎样切割呢？</p>
<p>因为指定了大小，因此切割跟切蛋糕很像，参数 <code>size</code> 是尺子，测好每块的长度，<code>slice</code> 函数是刀， 将数组一块一块切出来。  例如有 <code>[1,2,3,4,5]</code> 这个数组，<code>size</code> 指定为 <code>2</code>，则第一次切割会得到 <code>[1,2]</code> 的块，第二次切割得到 <code>[4,5]</code>，剩下的是 <code>[5]</code> 。这个数组最终会被切为三块。</p>
<h4 id="源码总览"><a href="#源码总览" class="headerlink" title="源码总览"></a>源码总览</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chunk</span>(<span class="params">array, size</span>) &#123;</span><br><span class="line">  <span class="comment">// 确保 length 存在 且 size 比 1 大</span></span><br><span class="line">  size = <span class="title class_">Math</span>.<span class="title function_">max</span>(size, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> length = array == <span class="literal">null</span> ? <span class="number">0</span> : array.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 否则 返回空数组</span></span><br><span class="line">  <span class="keyword">if</span> (!length || size &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> resIndex = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 新建数组result，长度为分割后块的数量</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="title class_">Math</span>.<span class="title function_">ceil</span>(length / size))</span><br><span class="line">  <span class="comment">// 切割 array 放于 result 中，注意 index，每次切割，index增加size长度</span></span><br><span class="line">  <span class="keyword">while</span> (index &lt; length) &#123;</span><br><span class="line">    result[resIndex++] = <span class="title function_">slice</span>(array, index, (index += size))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p><code>Math.round()</code>  “四舍五入”， 该函数返回的是一个四舍五入后的的整数<br><code>Math.ceil()</code>  “向上取整”， 即小数部分直接舍去，并向正数部分进1<br><code>Math.floor()</code>  “向下取整” ，即小数部分直接舍去</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 compact</title>
    <url>/2021/12/20/lodash%E6%BA%90%E7%A0%81%20compact/</url>
    <content><![CDATA[<h2 id="compact-array"><a href="#compact-array" class="headerlink" title="_.compact(array)"></a>_.compact(array)</h2><blockquote>
<p>介绍：创建一个新数组，包含原数组中所有的非假值元素。例如<code>false</code> , <code>null</code> , <code>0</code> , <code>&quot;&quot;</code> , <code>undefined</code> , 和 <code>NaN</code> 都是被认为是“假值”。<br>🌰</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="literal">false</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="title class_">NaN</span>,<span class="number">5</span>,<span class="literal">undefined</span>]</span><br><span class="line">_.<span class="title function_">compact</span>(arr) <span class="comment">// 返回 [1，2，3，4，5]</span></span><br></pre></td></tr></table></figure>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compact</span>(<span class="params">array</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> resIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (array == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      result[resIndex++] = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么使用-for-of"><a href="#为什么使用-for-of" class="headerlink" title="为什么使用 for  of"></a>为什么使用 <code>for  of</code></h4><blockquote>
<p>遍历除了 <code>for  of</code> 还有 <code>for</code>、<code>for in</code>，使用 <code>for</code>的话，不够间接，下面讨论为什么不使用<code>for in</code></p>
</blockquote>
<h5 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h5><p>for in是以<strong>任意顺序</strong>遍历一个对象的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举属性</a>。  </p>
<p>在数组中，数组的索引是可枚举属性，可以用 for…in 来遍历数组的索引，数组中的稀疏部分不存在索引，可以避免用 for 循环造成无效遍历的弊端。</p>
<p>但是，for…in 的遍历顺序依赖于执行环境，不同执行环境的实现方式可能会不一样。单凭这一点，就断然不能在数组遍历中使用 for…in，大多数情况下，顺序对于数组的遍历都相当重要。</p>
<p>另外，先看个🌰</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.<span class="property">foo</span> = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，你期望输出的是 0,1,2，但是最后输出的可能是 0,1,2,foo （for…in 不能保证顺序）。因为 foo 也是可枚举属性，在 for..in 会被遍历出来。</p>
<h5 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h5><p><code>for...of</code> 循环内部调用的就是数组原型链上的 <code>Symbol.iterator</code> 方法。</p>
<p><code>Symbol.iterator</code> 在调用的时候会返回一个遍历器对象，这个遍历器对象中包含 <code>next</code> 方法，<code>for...of</code> 在每次循环的时候都会调用 <code>next</code> 方法来获取值，直到 <code>next</code> 返回的对象中的 <code>done</code>属性值为 <code>true</code> 时停止。</p>
<p>手动调用来模拟遍历的过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = a[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">iterator.<span class="title function_">next</span>() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>因此在不改写 <code>Symbol.iterator</code> 的情况下, 使用 <code>for...of</code> 来遍历数组是安全的，因为这个方法(<code>Symbol.iterator</code>)是数组的原生方法。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 eq</title>
    <url>/2021/12/27/lodash%E6%BA%90%E7%A0%81%20eq/</url>
    <content><![CDATA[<h3 id="eq-value-other"><a href="#eq-value-other" class="headerlink" title="_.eq(value, other)"></a>_.eq(value, other)</h3><blockquote>
<p>介绍：执行 <code>SameValueZero</code> 比较两者的值，来确定它们是否相等。</p>
</blockquote>
<h4 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123; <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> other = &#123; <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span> &#125;;</span><br><span class="line"> </span><br><span class="line">_.<span class="title function_">eq</span>(object, object);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"> </span><br><span class="line">_.<span class="title function_">eq</span>(object, other);</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"> </span><br><span class="line">_.<span class="title function_">eq</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br><span class="line"> </span><br><span class="line">_.<span class="title function_">eq</span>(<span class="string">&#x27;a&#x27;</span>, <span class="title class_">Object</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// =&gt; false</span></span><br><span class="line"> </span><br><span class="line">_.<span class="title function_">eq</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>);</span><br><span class="line"><span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<h4 id="规则比较"><a href="#规则比较" class="headerlink" title="规则比较"></a>规则比较</h4><blockquote>
<p>前排提示：以下提到的规则，<code>SameValueNonNumber</code> 是基本，<code>Strict Equality Comparison</code> 、<code>SameValue</code> 和 <code>SameValueZero</code> 只是在对待 <code>+0</code>、<code>-0</code> 和 <code>NaN</code> 上有区别。</p>
</blockquote>
<h5 id="基础规则：SameValueNonNumber"><a href="#基础规则：SameValueNonNumber" class="headerlink" title="基础规则：SameValueNonNumber"></a>基础规则：SameValueNonNumber</h5><p>这个规范规定比较的值 x 和 y 都不为 Number 类型，照抄规范如下：</p>
<ol>
<li><code>x</code> 的类型不为 <code>Number</code> 类型</li>
<li><code>y</code> 的类型与 <code>x</code> 的类型一致</li>
<li>如果 <code>x</code> 的类型为 <code>Undefined</code> ，返回 <code>true</code></li>
<li>如果 <code>x</code> 的类型为 <code>Null</code> ，返回 <code>true</code></li>
<li>如果 <code>x</code> 的类型为 <code>String</code>，并且 <code>x</code> 和 <code>y</code> 的长度及编码相同，返回 <code>true</code>，否则返回 <code>false</code></li>
<li>如果 <code>x</code> 的类型为 <code>Boolean</code> ，并且 <code>x</code> 和 <code>y</code> 同为 <code>true</code> 或同为 <code>false</code> ，返回 <code>true</code>，否则返回 <code>false</code></li>
<li>如果 <code>x</code>的类型为 <code>Symbol</code> ，并且 <code>x</code> 和 <code>y</code> 具有相同的 <code>Symbol</code> 值，返回 <code>true</code>，否则返回 <code>false</code></li>
<li>如果 <code>x</code> 和 <code>y</code> 指向同一个对象，返回 <code>true</code>， 否则返回 <code>false</code><h5 id="Strict-Equality-Comparison"><a href="#Strict-Equality-Comparison" class="headerlink" title="Strict Equality Comparison"></a>Strict Equality Comparison</h5>js 中的全等（<code>===</code>）便是遵循这个规范，照搬规范如下：</li>
<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>
<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>
<li>a. 如果 <code>x</code> 为 <code>NaN</code> ，返回 <code>false</code></li>
<li>b. 如果 <code>y</code> 为 <code>NaN</code> ，返回 <code>false</code></li>
<li>c. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>
<li>d. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>true</code></li>
<li>e. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>true</code></li>
<li>f. 返回 <code>false</code></li>
</ul>
</li>
<li>按照 <code>SameValueNonNumber</code> 的结果返回<h5 id="SameValue"><a href="#SameValue" class="headerlink" title="SameValue"></a>SameValue</h5></li>
<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>
<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>
<li>a. 如果 <code>x</code> 为 <code>NaN</code> 并且 <code>y</code> 为 <code>NaN</code> ，返回 <code>true</code></li>
<li>b. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>false</code></li>
<li>c. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>false</code></li>
<li>d. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>
<li>e. 返回 <code>false</code></li>
</ul>
</li>
<li>按照 <code>SameValueNonNumber</code> 的结果返回<h5 id="SameValueZero"><a href="#SameValueZero" class="headerlink" title="SameValueZero"></a>SameValueZero</h5>这个是 <code>_.eq</code> 遵循的规范，如下：</li>
<li>如果 <code>x</code> 和 <code>y</code> 的类型不同，返回 <code>false</code></li>
<li>如果 <code>x</code> 的为 <code>Number</code> 类型：<ul>
<li>a. 如果 <code>x</code> 为 <code>NaN</code> 并且 <code>y</code> 为 <code>NaN</code> ，返回 <code>true</code></li>
<li>b. 如果 <code>x</code> 为 <code>+0</code> 并且 <code>y</code> 为 <code>-0</code> ，返回 <code>true</code></li>
<li>c. 如果 <code>x</code> 为 <code>-0</code> 并且 <code>y</code> 为 <code>+0</code> ，返回 <code>true</code></li>
<li>d. 如果 <code>x</code> 和 <code>y</code> 的数值一致，返回 <code>true</code></li>
<li>e. 返回 <code>false</code></li>
</ul>
</li>
<li>按照 <code>SameValueNonNumber</code> 的结果返回</li>
</ol>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eq</span>(<span class="params">value, other</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value === other || (value !== value &amp;&amp; other !== other)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Strict Equality Comparison</code> 和 <code>SameValueZero</code> 只在对待 <code>NaN</code> 上有区别。<br>所以在此基础上使用<code>value !== value &amp;&amp; other !== other</code> 修改 <code>NaN</code> 的处理即可</p>
<h4 id="可以用-Object-is-替代吗？"><a href="#可以用-Object-is-替代吗？" class="headerlink" title="可以用 Object.is() 替代吗？"></a>可以用 Object.is() 替代吗？</h4><p><strong>不能</strong>，<code>Object.is</code> 同样是比较两个值是否一样，遵循是的 <code>SameValue</code> 规范，<code>Object.is(+0, -0)</code> 返回的是 <code>false</code>， 所以不能</p>
<p>可以用来判断 <code>NaN</code>, <code>Object.is(NaN, NaN)</code> 返回的是 <code>true</code> ，所以 <code>eq</code> 同样可以改成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eq</span>(<span class="params">value, other</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value === other || <span class="title class_">Object</span>.<span class="title function_">is</span>(value, other)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以用-isNaN-吗？"><a href="#可以用-isNaN-吗？" class="headerlink" title="可以用 isNaN() 吗？"></a>可以用 isNaN() 吗？</h4><p><strong>不能</strong>，如果传入的参数不为 Number 类型，会尝试转换成 Number 类型之后再做是否为 NaN 的判断。所以类似 isNaN(‘notNaN’) 返回的也是 true ，因为字符串 notNaN 会先被转换成 NaN 再做判断，这不是我们想要的结果。</p>
<h4 id="可以用-Number-isNaN-吗？"><a href="#可以用-Number-isNaN-吗？" class="headerlink" title="可以用 Number.isNaN() 吗？"></a>可以用 Number.isNaN() 吗？</h4><p>为了修复 <code>isNaN</code> 的缺陷，<code>es6</code> 在 <code>Number</code> 对象上扩展了 <code>isNaN</code> 方法，只有是 <code>NaN</code> 时才会返回 <code>true</code>，因此用 Number.isNaN 来判断是安全的。所以 <code>eq</code> 同样可以改成以下形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eq</span>(<span class="params">value, other</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value === other || (<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(value) &amp;&amp; <span class="title class_">Number</span>.<span class="built_in">isNaN</span>(other))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 slice</title>
    <url>/2021/12/15/lodash%E6%BA%90%E7%A0%81%20slice/</url>
    <content><![CDATA[<h2 id="slice-array-start-0-end-array-length"><a href="#slice-array-start-0-end-array-length" class="headerlink" title="_.slice(array, [start=0], [end=array.length])"></a>_.slice(array, [start=0], [end=array.length])</h2><blockquote>
<p><strong>介绍:</strong>   裁剪数组<code>array</code>，从<code>start</code> 位置开始到<code>end</code>结束，但不包括<code>end</code> 本身的位置。<strong>这个方法用于代替Array#slice 来确保数组正确返回</strong>  </p>
</blockquote>
<p><strong>为什么需要替代:</strong><br>lodash 的 slice 会将数组当成密集数组对待，原生的 slice 会将数组当成稀疏数组对待。</p>
<h4 id="密集数组VS稀疏数组"><a href="#密集数组VS稀疏数组" class="headerlink" title="密集数组VS稀疏数组"></a>密集数组VS稀疏数组</h4><blockquote>
<p>稀疏数组就是包含从0开始的不连续索引的数组。通常，数组的length属性值代表数组中元素的个数。如果数组是稀疏的，length属性值大于元素的个数。</p>
</blockquote>
<p>如果数组是稀疏的，那么这个数组中至少有一个以上的位置不存在元素（undefined算元素）。<br>🌰</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sparse 的 length 为10，但是 sparse 数组中没有元素，是稀疏数组</span></span><br><span class="line"><span class="keyword">var</span> sparse = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>) </span><br><span class="line"><span class="comment">// dense 每个位置都是有元素的，虽然每个元素都为undefined，为密集数组</span></span><br><span class="line"><span class="keyword">var</span> dense = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">fill</span>(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>
<h4 id="源码总览"><a href="#源码总览" class="headerlink" title="源码总览"></a>源码总览</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">slice</span>(<span class="params">array, start, end</span>) &#123;</span><br><span class="line">  <span class="comment">// array == null, 非 === ,包含undefined的判断 undefined == null true</span></span><br><span class="line">  <span class="keyword">let</span> length = array == <span class="literal">null</span> ? <span class="number">0</span> : array.<span class="property">length</span></span><br><span class="line">  <span class="comment">// 不传参的情况</span></span><br><span class="line">  <span class="keyword">if</span> (!length) &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此部分判断是否带start或end的参</span></span><br><span class="line">  <span class="comment">// 不带的时候赋予初始值</span></span><br><span class="line">  start = start == <span class="literal">null</span> ? <span class="number">0</span> : start</span><br><span class="line">  end = end === <span class="literal">undefined</span> ? length : end</span><br><span class="line">  <span class="comment">// start 为负数的情况</span></span><br><span class="line">  <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果负数取反后比数组的长度还要大，即超出了数组的范围，则取值为0</span></span><br><span class="line">    start = -start &gt; length ? <span class="number">0</span> : (length + start)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// end最大取数组长度</span></span><br><span class="line">  end = end &gt; length ? length : end</span><br><span class="line">  <span class="comment">// end 小于0</span></span><br><span class="line">  <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    end += length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新数组的长度</span></span><br><span class="line">  length = start &gt; end ? <span class="number">0</span> : ((end - start) &gt;&gt;&gt; <span class="number">0</span>)</span><br><span class="line">  start &gt;&gt;&gt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(length)</span><br><span class="line">  <span class="comment">// 截取并返回新数组</span></span><br><span class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">    result[index] = array[index + start]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>start</strong>  </p>
<blockquote>
<ul>
<li>如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取。</li>
<li>如果省略，则从索引0开始</li>
</ul>
</blockquote>
<p><strong>end</strong></p>
<blockquote>
<ul>
<li>如果该参数为负数，则它表示在原数组中的倒数第几个元素结束制取。</li>
<li>如果end被省略，则slice会一直提取到原数组的末尾。</li>
<li>如果end大于数组长度，slice也会一直提取到原数组末尾。</li>
</ul>
</blockquote>
<p><strong>关于 <code>start &gt;&gt;&gt;= 0</code></strong>  </p>
<ul>
<li>使用 <code>&gt;&gt;&gt;</code> 来确保 <code>start</code> 参数为整数或0。  </li>
<li>因为 <code>lodash</code> 的 <code>slice</code> 除了可以处理数组外，也可以处理类数组( <code>arguments</code> 对象和 <code>DOM</code> 方法的返回结果)，因此第一个参数 <code>array</code> 可能为一个对象， <code>length</code> 属性不一定为数字。</li>
<li>更多知识请参考“移位运算符”</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 内部 Hash缓存</title>
    <url>/2021/12/29/lodash%E6%BA%90%E7%A0%81%20%E5%86%85%E9%83%A8%20Hash%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="作用与用法"><a href="#作用与用法" class="headerlink" title="作用与用法"></a>作用与用法</h2><p><code>Hash</code> 顾名思义，就是要有一个离散的序列，根据 <code>key</code> 来储取数据。而在 javascript 中，最适合的无疑是对象了。</p>
<p><code>Hash</code> 在 lodash 的 <code>.internal</code> 文件夹中，作为内部文件来使用。lodash 会根据不同的数据类型选择不同的缓存方式，<code>Hash</code> 便是其中的一种方式，这种方式只能缓存 <code>key</code> 的类型符合对象键要求的数据。</p>
<p> <code>Hash</code> 只接收一个二维数组作为参数，调用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Hash</span>([[<span class="string">&#x27;test1&#x27;</span>, <span class="number">1</span>],[<span class="string">&#x27;test2&#x27;</span>,<span class="number">2</span>],[<span class="string">&#x27;test3&#x27;</span>,<span class="number">3</span>]])</span><br></pre></td></tr></table></figure>

<p>其中子项中的第一项会作为 <code>key</code> ，第二项是需要缓存的值。</p>
<p><code>Hash</code> 实例化的结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">size</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">__data__</span>: &#123;</span><br><span class="line">    <span class="attr">test1</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">test2</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">test3</span>: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缓存的数量储存在 <code>__data__</code> 的对象中。</p>
<h2 id="Hash与Map"><a href="#Hash与Map" class="headerlink" title="Hash与Map"></a>Hash与Map</h2><p>后面将会讲到，除了使用 <code>Hash</code> 方式缓存数据外，还会用到 <code>Map</code>，lodash 在设计 <code>Hash</code> 的数据管理接口时，也与 <code>Map</code> 的接口一致，但是不会包含 <code>Map</code> 的遍历方法。</p>
<p>先来看看这些接口都有那些：</p>
<p><img src="/images/hash.png"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">HASH_UNDEFINED</span> = <span class="string">&#x27;__lodash_hash_undefined__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hash</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">entries</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> length = entries == <span class="literal">null</span> ? <span class="number">0</span> : entries.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">clear</span>()</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">      <span class="keyword">const</span> entry = entries[index]</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">set</span>(entry[<span class="number">0</span>], entry[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">__data__</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">delete</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">has</span>(key) &amp;&amp; <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">__data__</span>[key]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> -= result ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">    <span class="keyword">const</span> result = data[key]</span><br><span class="line">    <span class="keyword">return</span> result === <span class="variable constant_">HASH_UNDEFINED</span> ? <span class="literal">undefined</span> : result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">    <span class="keyword">return</span> data[key] !== <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">size</span> += <span class="variable language_">this</span>.<span class="title function_">has</span>(key) ? <span class="number">0</span> : <span class="number">1</span></span><br><span class="line">    data[key] = value === <span class="literal">undefined</span> ? <span class="variable constant_">HASH_UNDEFINED</span> : value</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Hash</span></span><br></pre></td></tr></table></figure>

<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">entries</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> length = entries == <span class="literal">null</span> ? <span class="number">0</span> : entries.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">clear</span>()</span><br><span class="line">    <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">      <span class="keyword">const</span> entry = entries[index]</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">set</span>(entry[<span class="number">0</span>], entry[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>constructor</code> 中并没有看到初始化 <code>__data__</code> 属性和 <code>size</code> 属性，这个其实在 <code>clear</code> 方法中初始化了，后面会解释。</p>
<p>接着遍历传入的二维数组，调用 <code>set</code> 方法，初始化缓存的值。将子项的第一项作为 <code>key</code> ，第二项为缓存的值。</p>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">__data__</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>clear</code> 的作用是清空缓存，因此需要将 <code>size</code> 重置为 <code>0</code>。</p>
<p>将缓存的数据 <code>__data__</code> 设置为空对象。</p>
<p>这里并没有用 <code>this.__data__ = &#123;&#125;</code> 置空，而是调用了 <code>Object.create</code> 方法，并且将 <code>null</code> 作为参数。我们都知道， <code>Object.create</code> 的第一个参数为创建对象的原型对象，传入 <code>null</code> 的时候，返回的就是一个真空对象，即没有原型的对象，因此不会有原型属性的干扰，用来做缓存对象十分适合。</p>
<h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">has</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">  <span class="keyword">return</span> data[key] !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>has</code> 用来判断是否已经有缓存数据，如果缓存数据已经存在，则返回 <code>true</code> 。</p>
<p>判断也十分简单，只需要判断取出来的值是否为 <code>undefined</code> 即可。</p>
<p>这个判断有一个坑，后面会讲到。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> += <span class="variable language_">this</span>.<span class="title function_">has</span>(key) ? <span class="number">0</span> : <span class="number">1</span></span><br><span class="line">  data[key] = value === <span class="literal">undefined</span> ? <span class="variable constant_">HASH_UNDEFINED</span> : value</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set</code> 用来增加或者更新需要缓存的值。<code>set</code> 的时候需要同时维护 <code>size</code> 和在缓存的值。</p>
<p>首先调用 <code>has</code> 方法，判断对应的 <code>key</code> 是否已经被缓存过，如果已经缓存过，则 <code>size</code> 保持不变，否则 <code>size</code> 加 <code>1</code> 。</p>
<p>缓存值其实就是设置缓存对象 <code>this.__data__</code> 对应 <code>key</code> 属性的值。</p>
<p>在 <code>has</code> 中说到用 <code>data[key] !== undefined</code> 有一个坑，因为要缓存的值也可以是 <code>undefined</code> ，如果不做处理，肯定会导致判断错误。</p>
<p>lodash 的处理方式是将 <code>undefined</code> 的值转换成 <code>HASH_UNDEFINED</code> ，也即一开始便定义的 <code>__lodash_hash_undefined__</code> 字符串来储存。</p>
<p>所以在缓存中，是用字符串 <code>__lodash_hash_undefined__</code> 来替代 <code>undefined</code> 的。</p>
<p><code>set</code> 在最后还将实例 <code>this</code> 返回，以支持链式操作。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="variable language_">this</span>.<span class="property">__data__</span></span><br><span class="line">  <span class="keyword">const</span> result = data[key]</span><br><span class="line">  <span class="keyword">return</span> result === <span class="variable constant_">HASH_UNDEFINED</span> ? <span class="literal">undefined</span> : result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get</code> 方法是从缓存中取值。</p>
<p>取值其实就是返回缓存对象中对应 <code>key</code> 的值即可。因为 <code>undefined</code> 在缓存中是以 <code>__lodash_hash_undefined__</code> 来表示的，因此遇到值为 <code>__lodash_hash_undefined__</code> 时，返回 <code>undefined</code> 。</p>
<p>其实这样还是有小小的问题的，如果需要缓存的值刚好是 <code>__lodash_hash_undefined__</code>，那取出来的值跟预设的就不一致了。但是这样情况应该很少出现吧。</p>
<p>如果是自己写的函数，可以用数组、对象或者 <code>Symbol</code> 来替代字符串，就不会出现字符串冲突的情况了。lodash 为什么不用呢，因为 lodash 是分模块发布的，不同的模块可能依赖不同版本的 <code>Hash</code> 类，这样 <code>HASH_UNDEFINED</code> 指向的内存或者 <code>Symbol</code> 值就不一致了，也就无法区分出 <code>undefined</code> 了。具体见作者的回复：<a href="https://github.com/lodash/lodash/issues/3573">HASH_UNDEFINED why not use Object or Array</a></p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">delete</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="variable language_">this</span>.<span class="title function_">has</span>(key) &amp;&amp; <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">__data__</span>[key]</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">size</span> -= result ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>delete</code> 方法用来删除指定 <code>key</code> 的缓存。成功删除返回 <code>true</code>， 否则返回 <code>false</code>。 删除操作同样需要维护 <code>size</code> 属性和缓存值。</p>
<p>首先调用 <code>has</code> 方法来判断缓存是否存在，如果存在，用 <code>delete</code> 操作符将 <code>__data__</code> 中对应的属性删除。</p>
<p><code>delete</code> 操作符在成功删除属性时会返回 <code>true</code>，如果成功删除，则需要将 <code>size</code> 减少 <code>1</code> 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://es6.ruanyifeng.com/#docs/set-map#Map">Set 和 Map 数据结构</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">Object.create()</a></li>
</ol>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>
<p>作者：对角另一面</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 内部 assocIndexOf</title>
    <url>/2022/01/04/lodash%E6%BA%90%E7%A0%81%20%E5%86%85%E9%83%A8%20assocIndexOf/</url>
    <content><![CDATA[<h1 id="lodash源码分析之自减的两种形式"><a href="#lodash源码分析之自减的两种形式" class="headerlink" title="lodash源码分析之自减的两种形式"></a>lodash源码分析之自减的两种形式</h1><blockquote>
<p>这个世界需要一个特定的恶人，可以供人们指名道姓，千夫所指：“全都怪你”。</p>
<p>——村上春树《当我谈跑步时我谈些什么》</p>
</blockquote>
<p>本文为读 lodash 源码的第六篇，后续文章会更新到这个仓库中，欢迎 star：<a href="https://github.com/yeyuqiudeng/pocket-lodash">pocket-lodash</a></p>
<p>gitbook也会同步仓库的更新，gitbook地址：<a href="https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details">pocket-lodash</a></p>
<p>本篇分析的是 <code>assocIndexOf</code> 函数。</p>
<h2 id="作用与用法"><a href="#作用与用法" class="headerlink" title="作用与用法"></a>作用与用法</h2><p><code>assocIndexOf</code> 是 lodash 的内部函数，之前在《<a href="hash.md">lodash源码分析之Hash缓存</a>》介绍过一种这样的数据结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> caches = [[<span class="string">&#x27;test1&#x27;</span>, <span class="number">1</span>],[<span class="string">&#x27;test2&#x27;</span>,<span class="number">2</span>],[<span class="string">&#x27;test3&#x27;</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>

<p>这是一个二维数组，每项中的第一项作为缓存对象的 <code>key</code>，第二项为缓存的值。</p>
<p><code>assocIndexOf</code> 的作用是找出指定的 <code>key</code> 在数组中的索引值。</p>
<p>例如要找 <code>key</code> 为 <code>tes1</code> 的索引 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">assocIndexOf</span>(caches, <span class="string">&#x27;test1&#x27;</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> eq <span class="keyword">from</span> <span class="string">&#x27;../eq.js&#x27;</span></span><br></pre></td></tr></table></figure>

<p><a href="../eq.md">lodash源码分析之NaN不是NaN</a></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assocIndexOf</span>(<span class="params">array, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; length &#125; = array</span><br><span class="line">  <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">eq</span>(array[length][<span class="number">0</span>], key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码很精简，让 <code>length</code> 自减，调用 <code>eq</code> 函数，从二维数组的最后一项开始，逐项获取 <code>key</code> 值，与传入的 <code>key</code> 比较，遇到匹配的，马上将该项的索引返回。如果都没找到，返回 <code>-1</code> 。返回结果的规则与 <code>indexOf</code> 一致。</p>
<h2 id="length–和–length"><a href="#length–和–length" class="headerlink" title="length–和–length"></a>length–和–length</h2><p>我们都知道自减还有另外一种前置的形式，即 <code>--length</code>，那将上面的代码改成 <code>while(--length)</code> 可不可以呢？试一下就知道了。</p>
<p>改了之后，用 <code>caches</code> 来测试下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">assocIndexOf</span>(caches, <span class="string">&#x27;test3&#x27;</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">assocIndexOf</span>(caches, <span class="string">&#x27;test2&#x27;</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">assocIndexOf</span>(caches, <span class="string">&#x27;test1&#x27;</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>可以看到，改了之后，只影响到了第一项的结果，也就是终止条件有问题，根本没有遍历到第一项，但是后面的结果是正确的，也就说循环体里的 <code>length</code> 没有受到影响。</p>
<p>你可能会有点疑惑，<code>while</code> 的终止条件比较的不是 <code>length</code> 吗？为什么 <code>length--</code> 正确，而 <code>--length</code> 不正确呢？</p>
<p>其实 <code>while</code> 的终止条件并不是 <code>length</code> ，而是 <code>length--</code> 表达式所返回的结果。现在来看一下 <code>length--</code> 和 <code>--length</code> 所返回的结果有什么差别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">3</span></span><br><span class="line">length-- <span class="comment">// 3</span></span><br><span class="line">length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>可以看到， <code>length--</code> 返回的结果和自减前的一致，但是 <code>length</code> 已经减少 <code>1</code> 了。因此使用 <code>length--</code> ，最后一次进入循环体应该在 <code>length</code> 等于 <code>1</code> 的时候。</p>
<p>再来看 <code>--length</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">3</span></span><br><span class="line">--length <span class="comment">// 2</span></span><br><span class="line">length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>--length</code> 返回的结果跟自减后的结果一致，因此最后一次进入循环体应该是 <code>length</code> 为 <code>2</code> 的时候，因此如果换成这种形式，会漏掉一次循环。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://justjavac.com/codepuzzle/2012/10/28/codepuzzle-expression-and-statement.html">代码之谜（二）- 语句与表达式</a></li>
</ol>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>
<p>最后，所有文章都会同步发送到微信公众号上，欢迎关注，欢迎提意见：  <img src="https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg"> </p>
<p>作者：对角另一面</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载) lodash源码 内部 baseFindIndex</title>
    <url>/2022/01/20/lodash%E6%BA%90%E7%A0%81%20%E5%86%85%E9%83%A8%20baseFindIndex/</url>
    <content><![CDATA[<h1 id="lodash源码分析之baseFindIndex中的运算符优先级"><a href="#lodash源码分析之baseFindIndex中的运算符优先级" class="headerlink" title="lodash源码分析之baseFindIndex中的运算符优先级"></a>lodash源码分析之baseFindIndex中的运算符优先级</h1><blockquote>
<p>我悟出权力本来就是不讲理的——蟑螂就是海米；也悟出要造反，内心必须强大到足以承受任何后果才行。</p>
<p>——北岛《城门开》</p>
</blockquote>
<p>本文为读 lodash 源码的第十篇，后续文章会更新到这个仓库中，欢迎 star：<a href="https://github.com/yeyuqiudeng/pocket-lodash">pocket-lodash</a></p>
<p>gitbook也会同步仓库的更新，gitbook地址：<a href="https://www.gitbook.com/book/yeyuqiudeng/pocket-lodash/details">pocket-lodash</a></p>
<h2 id="作用与用法"><a href="#作用与用法" class="headerlink" title="作用与用法"></a>作用与用法</h2><p><code>baseFindIndex</code> 是内部方法，其作用类似于ES6的 <code>findIndex</code>，查找符合条件的第一个元素的索引。</p>
<p><code>baseFindIndex</code> 除了从前向后查找外，还可以从后向前查找。</p>
<p>用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">baseFindIndex</span>([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="keyword">function</span>(<span class="params">val, index, array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val &gt; <span class="number">1</span></span><br><span class="line">&#125;, <span class="number">1</span>) <span class="comment">// 从前向后查找，从索引1开始查找，返回2</span></span><br><span class="line"><span class="title function_">baseFindIndex</span>([<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="keyword">function</span>(<span class="params">val, index, array</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val &gt; <span class="number">1</span></span><br><span class="line">&#125;, <span class="number">1</span>, <span class="literal">true</span>) <span class="comment">// 从后向前查找，从索引1开始查找，返回3</span></span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baseFindIndex</span>(<span class="params">array, predicate, fromIndex, fromRight</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line">  <span class="keyword">let</span> index = fromIndex + (fromRight ? <span class="number">1</span> : -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((fromRight ? index-- : ++index &lt; length)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">predicate</span>(array[index], index, array)) &#123;</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码再次展示了 lodash 的特点，短小精悍！</p>
<p>这次读源码我们从里往外看。</p>
<p>从代码中很容易看到，<code>predicate</code> 是传递进来的函数，在 <code>baseFindIndex</code> 调用该函数，如果返回的结果为真值，则中止查找，返回索引。</p>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>我们再往外看，看看 <code>while</code> 的循环条件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fromRight ? index-- : ++index &lt; length</span><br></pre></td></tr></table></figure>

<p>现在问题来了，这个三元表达式有两种可能，一种是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(fromRight ? index-- : ++index) &lt; length</span><br></pre></td></tr></table></figure>

<p>一种是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fromRight ? index-- : (++index &lt; length)</span><br></pre></td></tr></table></figure>

<p>究竟是那一种呢？这就要看运算符的优化级了，下面这个表是 MDN 上的截图：</p>
<p><img src="../images/baseFindIndex.png"></p>
<p>这个表将优化级划分成了20个级别，数字越大，优化级越高。</p>
<p>从表中可以看到，比较运算符的优先级为11，而三元表达式（条件运算符）的优化级为4，因此可以确定比较运算符的优先级要比三元表达式的要高，循环条件其实等价于第二种写法。</p>
<h3 id="增减迷局"><a href="#增减迷局" class="headerlink" title="增减迷局"></a>增减迷局</h3><p>再往上看，可以看到这句代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index = fromIndex + (fromRight ? <span class="number">1</span> : -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>在向后查找时， <code>index</code> 减少了1，而向前查找时，<code>index</code> 增加了1，为什么要这样做呢？</p>
<p>再结合循环条件看下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fromRight ? index-- : ++index &lt; length</span><br></pre></td></tr></table></figure>

<p>在向前查找时，使用的是 <code>index--</code> 表达式的运算结果，向后查找时，使用的是 <code>++index &lt; lenth</code> 表达式的运算结果。</p>
<p>从上表中也可以看出前缀自增比比较运算符的优化级要高。</p>
<p>前缀自增返回的是自增后的结果，而在循环条件中就要将索引 <code>index</code> 增加1，这样会忽略掉第一个需要遍历的元素，作为补救，在开始遍历前，需要将 <code>index</code> 减少1。</p>
<p>同理，在向前查找时，需要将索引增加1，因为在遍历开始时就已经将索引减少1。</p>
<p>那又为什么向前查找时用的是后缀自减，而不是用前缀自减呢？</p>
<p>因为在向前查找时，最终要查找到数组索引 <code>0</code> 的位置，后缀自减返回的是自减前的数值，因此当 <code>index</code> 为 <code>1</code> 时，自减后的 <code>index</code> 为 <code>0</code> ，但是在循环条件中依然拿 <code>1</code> 来进行判断，所以使得索引 <code>0</code> 得以进入循环体。</p>
<p>关于前缀自增/减和后缀自增/减的区别可以看《<a href="./assocIndexOf.md">lodash源码分析之自减的两种形式</a>》。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN:运算符优先级</a></li>
</ol>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="http://creativecommons.org/licenses/by-nc-nd/4.0/">署名-非商业性使用-禁止演绎 4.0 国际 (CC BY-NC-ND 4.0)</a></p>
<p>最后，所有文章都会同步发送到微信公众号上，欢迎关注,欢迎提意见：  <img src="https://raw.githubusercontent.com/yeyuqiudeng/resource/master/images/qrcode_front-end-article.jpg"> </p>
<p>作者：对角另一面</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title>promise</title>
    <url>/2021/12/03/promise/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Promise 是异步编程的一种解决方案： 从语法上讲，promise是一个对象，从它可以获取异步操作的消息；从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p>
<h3 id="promise-有哪三种状态："><a href="#promise-有哪三种状态：" class="headerlink" title="promise 有哪三种状态："></a>promise 有哪三种状态：</h3><p>pending(等待态)、fulfiled(成功态)、rejected(失败态)</p>
<h3 id="promise-使用来解决什么问题的？"><a href="#promise-使用来解决什么问题的？" class="headerlink" title="promise 使用来解决什么问题的？"></a>promise 使用来解决什么问题的？</h3><p>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象<br>promise可以支持多个并发的请求，获取并发请求中的数据<br>这个promise可以解决异步的问题，本身不能说promise是异步的</p>
<h3 id="promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。"><a href="#promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。" class="headerlink" title="promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。"></a>promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。</h3><p>promise的构造函数接收一个参数：函数，并且这个函数需要传入两个参数：  </p>
<ul>
<li>resolve ：异步操作执行成功后的回调函数</li>
<li>reject：异步操作执行失败后的回调函数  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行完成&#x27;</span>);</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;我是成功！！&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>then中可以传递两个参数–请求成功（resolved）的函数和请求失败（reject）的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">10</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;数字太大了&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data); <span class="comment">// resolved 5</span></span><br><span class="line">    &#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err); <span class="comment">// rejected 数字太大了</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a>catch的用法</h3><p>其实它和then的第二个参数一样，用来指定reject的回调。用法是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 效果和写在then第二个参数里面一样</span></span><br><span class="line"><span class="keyword">catch</span>会把then中的报错展示出来，例如:</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(somedata); <span class="comment">//此处的somedata未定义</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>控制台输出 ： rejected ReferenceError：somedata is not defined at p.then<br>与try/catch有相同的功能</p>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>all 方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调，即all中promise 的 resolve 或者 reject执行完了再执行then<br>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Promise1</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>))</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Promise2</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;<span class="title function_">resolve</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>))&#125;)</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Promise3</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;<span class="title function_">resolve</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>))&#125;)</span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title class_">Promise1</span>, <span class="title class_">Promise2</span>, <span class="title class_">Promise3</span>])</span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 三个都成功则成功</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;aaaaaa&#x27;</span>)  <span class="comment">// 如果promise123 不通过resolve输出，这段话不执行</span></span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 只要有失败，则失败 </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>all的作用：<br>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。  </p>
<p>参考： 作者：蔓蔓雒轩  链接：<a href="https://juejin.cn/post/6844903607968481287%E3%80%82">https://juejin.cn/post/6844903607968481287。</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack</title>
    <url>/2022/02/06/webpack/</url>
    <content><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="/images/webpack_01.jpg" alt="Image text"></p>
<center>核心概念脑图</center>
****
#### 入口   `entry`
默认：`./src`

<p>单个入口用法：<code>entry: string|Array&lt;string&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry 属性的单个入口语法，是下面的简写：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">main</span>: <span class="string">&#x27;./path/to/my/entry/file.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象语法：<code>entry: &#123;[entryChunkName: string]: string|Array&lt;string&gt;&#125;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">    <span class="attr">vendors</span>: <span class="string">&#x27;./src/vendors.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="输出-output"><a href="#输出-output" class="headerlink" title="输出  output"></a>输出  <code>output</code></h4><p>默认：<code>./dist</code><br>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 webpack 中配置 output 属性的最低要求是，将它的值设置为一个对象，包含 filename 和 path</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home/proj/public/assets&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = config;</span><br></pre></td></tr></table></figure>
<p><strong>多个起点的情况（使用占位符确保文件具有唯一名称）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&#x27;./src/app.js&#x27;</span>,</span><br><span class="line">    <span class="attr">search</span>: <span class="string">&#x27;./src/search.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure>
<h4 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式  mode"></a>模式  <code>mode</code></h4><p>描述：提供 <code>mode</code> 配置选项，告知 <code>webpack</code> 使用相应模式的内置优化。<br>分 <code>development</code> 和 <code>production</code></p>
<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><ul>
<li>用于处理非 JavaScript 文件，webpack 自身只理解 JavaScript</li>
<li>在 webpack 配置中定义 loader 时，要定义在 module.rules 中</li>
</ul>
<p>🌰：你可以使用 <code>loader</code> 告诉 <code>webpack</code> 加载 <code>CSS</code> 文件，或者将 <code>TypeScript</code> 转为 <code>JavaScript</code>。为此，首先安装相对应的 <code>loader</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br><span class="line">npm install --save-dev ts-loader</span><br></pre></td></tr></table></figure>

<p>三种方式使用loader<br><strong>配置  <code>Configuration</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="attr">use</span>: [</span><br><span class="line">        &#123; <span class="attr">loader</span>: <span class="string">&#x27;style-loader&#x27;</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">modules</span>: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内联</strong><br>可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Styles</span> <span class="keyword">from</span> <span class="string">&#x27;style-loader!css-loader?modules!./styles.css&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>CLI</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">webpack --<span class="variable language_">module</span>-bind jade-loader --<span class="variable language_">module</span>-bind <span class="string">&#x27;css=style-loader!css-loader&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader。</p>
<h4 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件  plugins"></a>插件  <code>plugins</code></h4>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn和npm命令对比</title>
    <url>/2022/01/25/yarn%E5%92%8Cnpm%E5%91%BD%E4%BB%A4%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm                                     yarn</span><br><span class="line"></span><br><span class="line">npm init                                yarn init              <span class="comment">// 初始化</span></span><br><span class="line">npm i | install                         yarn  (install)        <span class="comment">// 安装依赖包</span></span><br><span class="line">npm i x --S | --save                    yarn add  x            <span class="comment">// 安装生产依赖并保存包名</span></span><br><span class="line">npm i x --D | --save-dev                yarn add x -D          <span class="comment">// 安装开发依赖并保存包名</span></span><br><span class="line">npm un | uninstall  x                   yarn remove            <span class="comment">// 删除依赖包</span></span><br><span class="line">npm i -g | npm -g i x                   yarn <span class="variable language_">global</span> add x      <span class="comment">// 全局安装</span></span><br><span class="line">npm un -g x                             yarn <span class="variable language_">global</span> remove x   <span class="comment">// 全局下载</span></span><br><span class="line">npm run dev                             yarn dev | run dev     <span class="comment">// 运行命令</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>事件循环Eventloop</title>
    <url>/2021/09/07/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFEventLoop/</url>
    <content><![CDATA[<h3 id="1-javascript是单线程语言"><a href="#1-javascript是单线程语言" class="headerlink" title="1. javascript是单线程语言"></a>1. javascript是单线程语言</h3><h3 id="2-所有的线程，都是有同步队列，和异步队列"><a href="#2-所有的线程，都是有同步队列，和异步队列" class="headerlink" title="2. 所有的线程，都是有同步队列，和异步队列"></a>2. 所有的线程，都是有同步队列，和异步队列</h3><p>立即执行，如函数 是同步；promise，ajax为异步</p>
<h3 id="3-任务队列-事件循环"><a href="#3-任务队列-事件循环" class="headerlink" title="3. 任务队列-事件循环"></a>3. 任务队列-事件循环</h3><p>同步任务会立刻执行，进入到主线程当中，异步任务会被放到任务队列（Event Queue）当中。<br>等待同步代码执行完毕后，返回来，再将异步中的任务放到主线程中执行,反复这样的循环，这就是事件循环。也就是先执行同步，返回来按照异步的顺序再次执行</p>
<h3 id="4-宏观任务和微观任务（先执行微观任务，再执行宏观任务）"><a href="#4-宏观任务和微观任务（先执行微观任务，再执行宏观任务）" class="headerlink" title="4. 宏观任务和微观任务（先执行微观任务，再执行宏观任务）"></a>4. 宏观任务和微观任务（先执行微观任务，再执行宏观任务）</h3><p>宏观任务主要包含：setTimeout、setInterval、script(整体代码)、I/O、UI 交互事件、setImmediate(Node.js 环境)<br>微观任务主要包括：Promise、MutaionObserver、process.nextTick(Node.js 环境)</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>地址</title>
    <url>/2021/12/03/%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><p>Hongwei Blog： <a href="https://yin-hongwei.github.io/">https://yin-hongwei.github.io/</a><br>飞鸟：<a href="https://lzxjack.top/">https://lzxjack.top/</a><br>Hexo 博客主题个性化：<a href="https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/">https://www.itrhx.com/2018/08/27/A04-Hexo-blog-topic-personalization/</a></p>
<h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2><h3 id="1-Soybean-Admin"><a href="#1-Soybean-Admin" class="headerlink" title="1.Soybean Admin"></a>1.Soybean Admin</h3><p>简介：Soybean Admin 是一个基于 Vue3、Vite、Naive UI、TypeScript 的中后台解决方案，它使用了最新的前端技术栈，并提炼了典型的业务模型，页面，包括二次封装组件、动态菜单、权限校验、粒子化权限控制等功能，它可以帮助你快速搭建企业级中后台项目，相信不管是从新技术使用还是其他方面，都能帮助到你。<br>地址：<a href="https://github.com/honghuangdc/soybean-admin">https://github.com/honghuangdc/soybean-admin</a></p>
<h2 id="CSS-样式类"><a href="#CSS-样式类" class="headerlink" title="CSS 样式类"></a>CSS 样式类</h2><p>1.渐变按钮 <a href="https://gradientbuttons.colorion.co/">https://gradientbuttons.colorion.co/</a></p>
<h2 id="icon"><a href="#icon" class="headerlink" title="icon"></a>icon</h2><p>1.xicons <a href="https://www.xicons.org/#/">https://www.xicons.org/#/</a></p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>移位运算符</title>
    <url>/2021/12/15/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="# 简述"></a># 简述</h2><blockquote>
<p>移位运算就是对二进制进行有规律低移位</p>
</blockquote>
<h2 id="“-lt-lt-”运算符"><a href="#“-lt-lt-”运算符" class="headerlink" title="# “&lt;&lt;”运算符"></a># “&lt;&lt;”运算符</h2><blockquote>
<p>“&lt;&lt;”运算符执行左移位运算。在移位运算过程中，符号位始终保持不变。如果右侧空出位置，则自动填充为 0；超出 32 位的值，则自动丢弃。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> &lt;&lt; <span class="number">2</span>);  <span class="comment">// 返回值20</span></span><br></pre></td></tr></table></figure>
<h2 id="“-gt-gt-”运算符"><a href="#“-gt-gt-”运算符" class="headerlink" title="# “&gt;&gt;”运算符"></a># “&gt;&gt;”运算符</h2><blockquote>
<p>“&gt;&gt;”运算符执行有符号右移位运算。与左移运算操作相反，它把 32 位数字中的所有有效位整体右移，再使用符号位的值填充空位。移动过程中超出的值将被丢弃。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000</span> &gt;&gt; <span class="number">8</span>);  <span class="comment">// 返回值3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">1000</span> &gt;&gt; <span class="number">8</span>);  <span class="comment">//返回值 -4，负数涉及二进制的原码、反码、补码</span></span><br></pre></td></tr></table></figure>

<h2 id="“-gt-gt-gt-”运算符"><a href="#“-gt-gt-gt-”运算符" class="headerlink" title="# “&gt;&gt;&gt;”运算符"></a># “&gt;&gt;&gt;”运算符</h2><blockquote>
<p>“&gt;&gt;&gt;”运算符执行五符号右移位运算。它把无符号的 32 位整数所有数位整体右移。对于无符号数或正数右移运算，无符号右移与有符号右移运算的结果是相同的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000</span> &gt;&gt; <span class="number">8</span>);  <span class="comment">//返回值3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1000</span> &gt;&gt; <span class="number">8</span>);  <span class="comment">//返回值3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于负数来说，无符号右移将使用 0 来填充所有的空位，同时会把负数作为正数来处理，所得结果会非常大所以，使用无符号右移运算符时要特别小心，避免意外错误。</p>
</blockquote>
<h2 id="something-gt-gt-gt-0"><a href="#something-gt-gt-gt-0" class="headerlink" title="# something &gt;&gt;&gt; 0"></a># something &gt;&gt;&gt; 0</h2><p><code>&gt;&gt;&gt;</code> 确保 <code>something</code> 为整数或0。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>箭头函数的部分简写方式</title>
    <url>/2021/06/23/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E9%83%A8%E5%88%86%E7%AE%80%E5%86%99%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="简写一"><a href="#简写一" class="headerlink" title="简写一"></a>简写一</h3><p>参数列表只有单个参数时，左边括号（）可以省去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(singleParam) =&gt; &#123; statements &#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
<h3 id="简写二"><a href="#简写二" class="headerlink" title="简写二"></a>简写二</h3><p>函数体是返回一个表达式的值时，右边大括号 {} 可以省去</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(param1, param2) =&gt; &#123;</span><br><span class="line">	 <span class="keyword">return</span> param1 + param2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">(param1, param2)=&gt; param1 + param2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者返回一个字符串，布尔值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">func1</span> = param1 =&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="简写三"><a href="#简写三" class="headerlink" title="简写三"></a>简写三</h3><p>返回一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(x) =&gt; &#123; <span class="keyword">return</span> &#123;<span class="string">&#x27;name&#x27;</span>:x&#125;; &#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">(x) =&gt; (&#123;<span class="string">&#x27;name&#x27;</span>:x&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS BFC</title>
    <url>/2022/02/06/CSS-BFC/</url>
    <content><![CDATA[<p>关于BFC</p>
<h4 id="BFC概念"><a href="#BFC概念" class="headerlink" title="BFC概念"></a>BFC概念</h4><p><code>BFC</code> 全称：<code>Block Formatting Context</code>， 名为 “块级格式化上下文”。</p>
<p><code>W3C</code>官方解释为：<code>BFC</code>它决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用，当涉及到可视化布局时，<code>Block Formatting Context</code>提供了一个环境，<code>HTML</code>在这个环境中按照一定的规则进行布局。</p>
<p>简单来说就是，<code>BFC</code>是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用<code>BFC</code>呢，<code>BFC</code>可以看做是一个<code>CSS</code>元素属性</p>
<h4 id="触发BFC"><a href="#触发BFC" class="headerlink" title="触发BFC"></a>触发BFC</h4><ul>
<li>根元素，即<code>html</code></li>
<li><code>overflow</code>不为<code>visible</code></li>
<li><code>float</code>的值不为<code>none</code></li>
<li><code>display</code>的值为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code></li>
<li><code>position</code>的值为<code>absolute</code>或<code>fixed</code></li>
</ul>
<p>作者：蛙人<br>链接：<a href="https://juejin.cn/post/6950082193632788493">https://juejin.cn/post/6950082193632788493</a><br>来源：稀土掘金</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css基础复习</title>
    <url>/2022/01/30/css%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><code>css</code>的基本定位和布局机制是<strong>文档流</strong>，默认自上而下，从左到右</p>
<h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p><code>div、ul、li、p、table、h1</code> 等元素，他们的默认<code>display</code>默认是<code>block、table、list-item</code></p>
<h3 id="内联元素（行内元素）"><a href="#内联元素（行内元素）" class="headerlink" title="内联元素（行内元素）"></a>内联元素（行内元素）</h3><p>如<code>span、a、em、i、img、td</code>等，这些元素的display值默认是<code>inline、inline-block、inline-table、table-cell</code>等。</p>
<h3 id="关于-width-auto-和-height-auto"><a href="#关于-width-auto-和-height-auto" class="headerlink" title="关于 width: auto  和 height: auto"></a>关于 <code>width: auto</code>  和 <code>height: auto</code></h3><p><code>width</code>、<code>height</code>的默认值都是<code>auto</code>。</p>
<p><strong>对于width</strong></p>
<p>块级元素：流体布局之下<code>width: auto</code>自适应撑满父元素宽度。这里的撑满并不同于<code>width: 100%</code>的固定宽度，而是像水一样能够根据<code>margin</code>不同而自适应父元素的宽度。</p>
<p>内联元素：<code>width: auto</code>则呈现出包裹性，即由子元素的宽度决定。</p>
<p><strong>对于height</strong></p>
<p>无论内联元素还是块级元素，<code>height: auto</code>都是呈现包裹性，即高度由子级元素撑开。</p>
<p>父元素<code>height: auto</code>会导致子元素<code>height: 100%</code>百分比失效。</p>
<p><code>css</code>的属性非常有意思，正常流下，如果块级元素的<code>width</code>是个固定值，<code>margin</code>是<code>auto</code>，则<code>margin</code>会撑满剩下的空间；如果<code>margin</code>是固定值，<code>width</code>是<code>auto</code>，则<code>width</code>会撑满剩下的空间。这就是流体布局的根本所在。</p>
<h3 id="css权重"><a href="#css权重" class="headerlink" title="css权重"></a><code>css</code>权重</h3><table>
<thead>
<tr>
<th>权重值</th>
<th>选择器</th>
</tr>
</thead>
<tbody><tr>
<td>1,0,0,0</td>
<td>内联样式：style=””</td>
</tr>
<tr>
<td>0,1,0,0</td>
<td>ID选择器：<code>#idName&#123;...&#125;</code></td>
</tr>
<tr>
<td>0,0,1,0</td>
<td>类、伪类、属性选择器：<code>.className&#123;...&#125;</code> / <code>:hover&#123;...&#125;</code> / <code>[type=&quot;text&quot;] =&#123;...&#125;</code></td>
</tr>
<tr>
<td>0,0,0,1</td>
<td>标签、伪元素选择器：<code>div&#123;...&#125;</code> / <code>:after&#123;...&#125;</code></td>
</tr>
<tr>
<td>0,0,0,0</td>
<td>通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）</td>
</tr>
</tbody></table>
<h3 id="盒模型（盒尺寸）"><a href="#盒模型（盒尺寸）" class="headerlink" title="盒模型（盒尺寸）"></a>盒模型（盒尺寸）</h3><p>元素的内在盒子是由<code>margin box</code>、<code>border box</code>、<code>padding box</code>、<code>content box</code>组成的，这四个盒子由外到内构成了盒模型。</p>
<p>IE模型： <code>box-sizing: border-box</code>  此模式下，元素的宽度计算为<code>border+padding+content</code>的宽度总和。</p>
<p>w3c标准盒子模型： <code>box-sizing: content-box</code> 此模式下，元素的宽度计算为<code>content</code>的宽度。</p>
<p>由于<code>content-box</code>在计算宽度的时候不包含<code>border pading</code>很烦人，而且又是默认值，业内一般采用以下代码重置样式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">:root &#123;</span><br><span class="line">    box-<span class="attr">sizing</span>: border-box;    </span><br><span class="line">&#125;</span><br><span class="line">* &#123;</span><br><span class="line">    box-<span class="attr">sizing</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内联盒模型"><a href="#内联盒模型" class="headerlink" title="内联盒模型"></a>内联盒模型</h3><p><img src="/images/%E5%86%85%E8%81%94%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="Image text"><br>内联元素是指外在盒子是内联盒子的元素。从表现来说，内联元素的典型特征就是可以和文字在一行显示。文字也是内联元素。图片、按钮、输入框、下拉框等替换元素也是内联元素。内联盒模型是指内联元素包含的几个盒子，理解记忆下面的几个概念对css的深入学习极其重要。</p>
<ol>
<li><p>内容区域：本质上是字符盒子。在浏览器中，文字选中状态的背景色就是内容区域。</p>
</li>
<li><p>内联盒子：内联盒子就是指元素的外在盒子是内联的，会和其他内联盒子排成一行。</p>
</li>
<li><p>行框盒子：由内联元素组成的每一行都是一个行框盒子。如果一行里面没有内联元素如一个空的<code>div</code>标签，则不会形成行框盒子。行框盒子由一个个内联盒子组成，如果换行，那就是两个行框盒子。比如一个包含了很多字符的换行的的<code>p</code>标签，每一行都存在一个行框盒子。值得注意的是，如果给元素设置<code>display: inline-block</code>，则创建了一个独立的行框盒子。<code>line-height</code>是作用在行框盒子上的，并最终决定高度。</p>
</li>
<li><p>包含盒子：就是包含块。多行文字组成一个包含块，一个包含块有若干个行框盒子。</p>
</li>
<li><p>幽灵空白节点：内联元素的每个行框盒子前面有一个“空白节点”，这个“空白节点”不占据任何宽度，无法选中获取，但是又实实在在存在，表现就如同文本节点一样（本文中大量例子会用字母x模拟幽灵空白节点）。  </p>
</li>
</ol>
<h3 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h3><p>替换元素是指内容可以替换的元素，实际上就是<code>content box</code>可以被替换的元素。</p>
<ol>
<li><p>存在<code>src=&quot;&quot;</code>属性的<code>&lt;img&gt; &lt;audio&gt; &lt;video&gt; &lt;iframe&gt;</code>元素</p>
</li>
<li><p>可以输入文本的<code>&lt;input&gt; &lt;select&gt; &lt;textarea&gt;</code>元素等。</p>
</li>
</ol>
<p>所有替换元素都是内联元素，默认<code>display</code>属性是<code>inline</code>或<code>inline-block</code>（除了<code>input[type=&quot;hidden&quot;]</code>默认<code>display: none;</code>）。</p>
<h3 id="盒模型四大金刚-gt-content-、-padding-、-margin-、-border"><a href="#盒模型四大金刚-gt-content-、-padding-、-margin-、-border" class="headerlink" title="盒模型四大金刚 ===&gt; content 、 padding 、 margin 、 border"></a>盒模型四大金刚 ===&gt; <code>content</code> 、 <code>padding</code> 、 <code>margin</code> 、 <code>border</code></h3><h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>对于非替换元素如<code>div</code>,其<code>content</code>就是div内部的元素。 而对于替换元素，其<code>content</code>就是可替换部分的内容。</p>
<p>CSS中的<code>content</code>属性主要用于伪元素<code>:before/:after</code>中，除了做字体库或少写个<code>div</code>，对于一般开发来说并无卵用。</p>
<h4 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h4><ol>
<li><p>设置<code>box-sizing: border-box</code>，宽高计算<code>padding</code>，但内容区域的宽高只是<code>content box</code>的宽高。</p>
</li>
<li><p><code>padding</code>不可为负值，但是可以为百分比值。为百分比时水平和垂直方向的<code>padding</code>都是相对于父级元素<strong>宽度</strong>计算的。将一个<code>div</code>设为<code>padding: 100%</code>就能得到一个正方形，<code>padding: 10% 50%</code>可以得到一个宽高比 5:1 的矩形。</p>
</li>
<li><p><code>padding</code>配合<code>background-clip</code>属性，可以制作一些特殊形状。</p>
</li>
</ol>
<h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><ol>
<li><p><code>margin</code>属性并不会参与盒子宽度的计算，但在<strong>流体布局下，即元素<code>width</code>是默认的<code>auto</code>并且可以撑满一行的时候</strong>，通过设置<code>margin</code>为负值，却能改变元素水平方向的尺寸；如果元素设定了宽度，或者元素设置了<code>float: left</code> / <code>position: absolute</code>这样的属性改变了流体布局，那么<code>margin</code>为负也无法改变元素的宽度了。</p>
</li>
<li><p>块级元素的垂直方向会发生<code>margin</code>合并，存在以下三种场景：</p>
<ul>
<li><p>相邻兄弟元素之间<code>margin</code>合并</p>
</li>
<li><p>父元素<code>margin-top</code>和子元素<code>margin-top</code>，父元素<code>margin-bottom</code>和子元素<code>margin-bottom</code></p>
</li>
<li><p>空块级元素自身的<code>margin-top</code>和<code>margin-botom</code>合并</p>
<p><strong>如何阻止<code>margin</code>合并：</strong></p>
<ul>
<li>把元素放到<code>bfc</code>中</li>
<li>设置<code>border</code>或<code>padding</code>阻隔<code>margin</code></li>
<li>用内联元素（如文字）阻隔</li>
<li>给父元素设定高度</li>
<li>具体使用请参考文章<code>css bfc</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>margin</code>的百分比值跟<code>padding</code>一样，垂直方向的<code>margin</code>和水平方向上的一样都是相对于父元素<strong>宽度</strong>计算的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: lightblue;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &gt; <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时 .box 是一个宽高比 2:1 的矩形，因为空块级元素自身的垂直方向的<code>margin</code>发生了合并。</p>
</li>
<li><p><code>margin: auto</code>能在块级元素设定宽高之后自动填充剩余宽高</p>
<p>如果一侧<code>margin</code>是固定的，另一侧是<code>auto</code>，则这一侧<code>auto</code>为剩余宽度</p>
<p>垂直方向的margin也能实现垂直居中，但是需要元素在垂直方向具有自动填充特性，而这个特性可以利用position实现：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="border"><a href="#border" class="headerlink" title="border"></a>border</h4><ol>
<li><p><code>border-style</code>属性的值有<code>none/solid/dashed（虚线）/dotted（点线）/double（双实线）</code>等</p>
</li>
<li><p><code>border-width</code>属性的默认值是<code>3px</code>，是为了照顾小弟<code>border-style: double</code></p>
</li>
<li><p><code>border-color</code>默认是跟随字体的颜色，相当于默认设置了<code>border-color: currentColor</code>一样。</p>
</li>
<li><p><code>border</code>另一广受欢迎的功能就是图形构建，特别是做应用广泛的三角形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">20px</span> solid;</span><br><span class="line">  <span class="attribute">border-color</span>: blue red orange green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">20px</span> solid;</span><br><span class="line">  <span class="attribute">border-color</span>: blue transparent transparent transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">20px</span> solid;</span><br><span class="line">  <span class="attribute">border-color</span>: blue transparent transparent transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">4</span>)&#123;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">40px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: blue transparent transparent transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(<span class="number">5</span>)&#123;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">40px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: blue red transparent transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/border%E5%9B%BE%E5%BD%A2%E6%9E%84%E5%BB%BA.png" alt="Image text"></p>
<p>其实就是将其他三个边框的颜色设置透明，并把宽高设为 0 。图中4-5两个图形，是通过调整边框宽度和颜色调整三角形的形状，把最后一个图的红色改为蓝色，则是一个直角三角形了。</p>
</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>作者：幻灵尔依<br>链接：<a href="https://juejin.cn/post/6844903894313598989">https://juejin.cn/post/6844903894313598989</a><br>来源：稀土掘金</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
